## Lecture 1: 操作系统概述

### 操作系统

操作系统 (Operating System) 是一个大型且复杂的软件系统，用于管理计算机的所有硬件资源，并使其易于使用。

**功能**：

*   **引导系统**：启动机器至可用状态。
*   **API与系统调用**：应用通过API和系统调用与OS交互。
*   **并发环境**：处理并发任务，优化资源利用。
*   **用户交互**：通过GUI或CLI与用户交互。

**操作系统主要任务**：

- **资源管理和优化**：在进程间分配和管理资源，最大化资源利用率，提高系统吞吐量。
- **提供接口**：提供用户和应用程序接口。
- **并发协调**：协调并发活动和设备，处理I/O，保证同步和通信。
- **安全保护**：保护系统资源免受恶意或意外滥用。

### 内核 (Kernel)

内核是操作系统的核心，负责管理 CPU、内存、进程间通信和底层硬件等关键资源和服务，运行在特权模式下，是不同操作系统发行版的基础。

*   **核心服务**：管理CPU、内存、进程间通信、底层硬件。
*   **发行版组件**：包括文件系统、数据库、网络、GUI等。

### 云操作系统

云操作系统是指将数据和应用程序远程托管在第三方数据中心，通过租用资源并使用Web界面或API进行访问，比如Office 365。

---

## Lecture 2: 进程管理

> 教授：现在我们开始讲操作系统的第一部分——虚拟化。
>
> 学生：尊敬的教授，什么是虚拟化？
>
> 教授：想象我们有一个桃子。
>
> 学生：桃子？（不可思议）
>
> 教授：是的，一个桃子，我们称之为物理（physical）桃子。但有很多想吃这个桃子的人，我们希望向每个想吃的人提供一个属于他的桃子，这样才能皆大欢喜。我们把给每个人的桃子称为虚拟（virtual）桃子。我们通过某种方式，从这个物理桃子创造出许多虚拟核子。重要的是，在这种假象中，每个人看起来都有一个物理桃子，但实际上不是。
>
> 学生：所以每个人都不知道他在和别人一起分享一个桃子吗？
>
> 教授：是的。
>
> 学生：但不管怎么样，实际情况就是只有一个桃子啊。
>
> 教授：是的，所以呢？
>
> 学生：所以，如果我和别人分享同一个桃子，我一定会发现这个问题。
>
> 教授：是的！你说得没错。但吃的人多才有这样的问题。多数时间他们都在打盹或者做其他事情，所以，你可以在他们打盹的时候把他手中的桃子拿过来分给其他人，这样我们就创造了有许多虚拟桃子的假象，每人一个桃子！
>
> 学生：这听起来就像糟糕的竞选口号。教授，您是在跟我讲计算机知识吗？
>
> 教授：年轻人，看来需要给你一个更具体的例子。以最基本的计算机资源CPU 为例，假设一个计算机只有一个CPU（尽管现代计算机一般拥有2个、4个或者更多CPU），虚化要做的就是将这个CPU 虚拟成多个虚拟 CPU并分给每一个进程使用，因此，每个应用都以为自己在独占 CPU，但实际上只有一个CPU。这样操作系统就创造了美丽的假象——它虚拟化了CPU。
>
> 学生；听起来好神奇，能再多讲一些吗？它是如何工作的?
>
> 教授：问得很及时，听上去你已经做好开始学习的准备了。
>
> 学生；是的，不过我还真有点担心您又要讲桃子的事情了。
>
> 教授；不用担心，毕竟我也不喜欢吃桃子。那我们开始学习吧……

### 进程、程序和处理器

#### 进程 (Processes)

人们都常常希望同时运行多个程序。比如：在使用电脑的时候，我们会同时运行浏览器、邮件、游戏、音乐播放器，等等。但是我们的电脑一般只有一个 CPU ，我们需要制造出一个几乎能提供无数 CPU的假象。进程是一个程序的实例 (instance)，是操作系统的一个抽象概念。其包含了一个执行上下文，包含了内核管理的、进程运行时所需的信息集合。

#### 程序 (Program)

程序是一系列指令的集合，是将算法翻译成编程语言的结果，描述了明确的执行顺序。编译器将程序代码映射为特定处理器的机器指令，并存储在目标文件中，然后使用链接器链接上库文件就变成了可执行文件 (程序)。

#### 处理器 (Processor)

处理器是执行进程的代理 (agent)，通过执行存储在内存映像中的指令来运行进程。

### 时分共享

时分共享 (time sharing) 是操作系统共享资源所使用的最基本的技术之一。通过允许责源由一个实体使用一小段时间，然后由另一个实体使用一小段时间，如此下去，所谓的资源 (例如，CPU或网络链接) 可以被许多人共享。

> 时分共享的自然对应技术是空分共享，资源在空间上被划分给希望使用它的人。 例如，磁盘空间自然是一个空分共享资源，因为一旦将块分配给文件，在用户删除文件之前，不可能将它分配给其他文件。

### 进程抽象表示

#### 进程状态

进程在运行过程中会处于不同的状态。以下是三种基本状态：

- **运行 (Running)**：进程正在处理器上执行指令。
- **就绪 (Ready)**：进程已准备好运行，但操作系统尚未选择它运行。
- **阻塞 (Blocked)**：进程因为等待某个事件发生（例如，I/O完成）而暂停运行。 进程发起I/O请求时通常会进入阻塞状态。
- **僵尸 (Zombie)**: 进程处于已经退出但是尚未清理的状态，这种状态非常有用，因为它能允许其他进程 (通常是创建进程的父进程) 检查进程的返回代码，并且查看刚刚完成的进程是否正确运行。

![img](https://s2.loli.net/2025/02/27/bLGWVDMri3m4SJI.png)

#### 进程控制块 (PCB)

操作系统是一个程序，和其他程序一样，它有一些关键的数据结构来跟踪各种相关的信息。它的最基础的任务就是进程管理，包含创建、控制、终止、管理执行环境等方面。操作系统还必须以某种方式跟踪被阻塞的进程。当 I/O 事件完成时，操作系统应确保唤醒正确的进程，让它准备好再次运行。因此我们需要一个数据结构 (PCB) 来维护这些数据。当一个进程停止时，它的寄存器将被保存到通过恢复这些寄存器，它被称为**上下文切换 (context switch)**。

例如 XV6 的proc结构如下：

```c
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
  int eip;
  int esp;
  int ebx;
  int ecx;
  int edx;
  int esi;
  int edi;
  int ebp;
};

// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };

// the information xv6 tracks about each process
// including its register context and state
struct proc {
  char *mem;                   // Start of process memory
  uint sz;                     // Size of process memory
  char *kstack;                // Bottom of kernel stack for this process
  enum proc_state state;           // Process state
  int pid;                     // Process ID
  struct proc *parent;             // Parent process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  struct file *ofile[NOFILE];     // Open files
  struct inode *cwd;                  // Current directory
  struct context context;          // Switch here to run process
  struct trapframe *tf;          // Trap frame for the current interrupt
};
```

#### 生命周期

PCB可以在过程寿命中在不同队列之间移动，具体取决于其执行的优先级或状态。

![img](https://s2.loli.net/2025/02/27/t6W3LaqmXTPpjAQ.png)

#### 通信

出于安全性和可靠性原因，与OS进行通信，无关过程之间的直接通信只能通过使用特定机制来实现。

- 进程间通信：操作系统提供了进程间通信的函数，这些函数可以将消息（message） 从一个进程映射到另一个进程。

- 与操作系统通信：是通过系统调用（system call）机制完成的，对于程序来说，操作系统就是上帝，没有操作系统，程序连杀死自己都做不到！

### 处理器执行模式

为了加强硬件保护，某些处理器指令受到限制，普通用户进程无法执行。

处理器以两种模式之一执行：用户模式或监管模式。 当执行用户进程时，进程在用户模式下，并且只能执行其指令集的一个子集。 为了执行操作系统代码，必须以受控方式将处理器切换到监管模式，然后才能执行其完整指令集。

一种称为软件中断的特殊处理器指令可以切换到监管模式。

![img](https://s2.loli.net/2025/02/27/nm5Uls4Fvdt2o83.png)

### 系统调用

进程自己只能计算，如果要访问硬件、与其他进程通信、创建新进程，必须要先跟操作系统通信，使用系统调用，等进程一觉醒来，自己要的东西就准备好了。

- 通常通过与用户空间进程链接的包装器库来访问。
- 包装器函数检查是否使用了正确的参数，并将调用软件中断机制。
- 系统调用的包装器 API 有助于应用程序代码在不同的内核和语言实现之间实现可移植性。

### 硬件中断

硬件中断可用来实现硬件与操作系统的通信。是硬件设备向操作系统发出异步事件通知的主要方式。设备无需等待操作系统主动查询 (轮询) ，而是主动告知。

- **高效设备管理**：硬件中断机制使得操作系统能够高效地管理大量的硬件设备。操作系统不必定期轮询每个设备的状态，而是只在设备需要关注时才会被中断。这大大提高了系统的效率。

- **防止CPU占用**：定时器（Timer）被用于防止某个用户程序进入死循环而持续占用 CPU 资源。在程序初始化时，定时器被设置为允许程序运行的最大时间。定时器每秒产生一个中断，当倒计时到零时，操作系统强制终止该程序的运行，保证了系统的公平性和稳定性。