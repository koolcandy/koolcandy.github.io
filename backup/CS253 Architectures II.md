## CS253 Architectures II



### Lecture 1: CPU

#### 计算机架构

计算机主要采用两种架构：  
- **冯诺依曼架构**：使用同一个存储器，经由同一个总线传输指令和数据。  
- **哈佛架构**：使用独立的指令存储器和数据存储器，提升执行效率。  

> [!NOTE]
>
> 现代高性能CPU通常结合冯诺依曼和哈佛架构的特点，例如通过“拆分缓存”设计来优化性能。

![img](https://s2.loli.net/2025/01/13/sJDwESPr8o4dnvm.png)

具体而言，冯诺依曼架构和哈佛架构的区别体现在以下几点：  
1. **存储器结构**：冯诺依曼架构使用统一存储器，而哈佛架构使用独立的指令和数据存储器。  
2. **总线设计**：冯诺依曼架构使用单条总线，哈佛架构使用多条独立总线。  

#### 8086的硬件组成

8086 CPU主要由以下两部分组成：  

![img](https://s2.loli.net/2025/01/13/m2kdoTtbw8MYcWz.png)

##### BIU: 总线接口单元  
- **功能**：负责发送地址，从内存中获取指令，并执行端口和内存的读写操作。  
- **特点**：BIU通过总线与外部设备通信，是CPU与内存之间的桥梁。  

##### EU: 执行单元  
- **功能**：解码指令并执行指令，包含算术逻辑单元（ALU）和控制电路。  
- **特点**：EU是CPU的核心执行模块，负责完成具体的计算任务。  

**指令周期**是8086 CPU的基本工作单位，具体流程如下：  
1. **Fetch**：从内存中获取指令。  
2. **Decode**：对指令进行解码。  
3. **Execute**：执行解码后的指令。  

> [!NOTE]
>
> 8086 CPU的指令周期通常占用4个时钟周期，因此1GHz的处理器每秒约可执行2.5亿条指令。

#### ALU: 算术逻辑单元

8086的ALU支持以下基本操作：  
- **算术运算**：  
  - **ADD**：加法  
  - **SUB**：减法  
  - **INC**：自增  
  - **DEC**：自减  
- **逻辑运算**：  
  - **AND**：逻辑与  
  - **OR**：逻辑或  
  - **XOR**：逻辑异或  
  - **NOT**：取反  

此外，ALU还支持**移位操作**，具体包括：  
- **逻辑移位**：在移位操作中，空出的位置填充逻辑0。  
- **算术移位**：在移位操作中，空出的位置填充符号位（最高位）。  

> [!NOTE]
>
> 移位操作在二进制运算中非常重要，常用于快速实现乘除法。

![img](https://s2.loli.net/2025/01/13/jqoGxpcAhRwQDuS.png)

左移和右移的实现方法如下：  
- **左移**：将二进制数的所有位向左移动一位，最低位填充0。  
- **右移**：将二进制数的所有位向右移动一位，最高位填充符号位（逻辑移位时填充0，算术移位时填充符号位）。  

![img](https://s2.loli.net/2025/01/13/jq8DOK7XleVby6m.png)
---

### Lecture 2: Assembly Language (Ⅰ)

#### 寄存器们

##### 通用寄存器
- **通用寄存器**：8086有8个通用寄存器，可以将它们视为8个变量，某些指令可以成对使用寄存器，从而提供16位操作。当用作寄存器对时，它们被赋予集体名称**AX**、**BX**、**CX**、**DX**。

![img](https://s2.loli.net/2025/01/13/6XusCizPvyElda5.png)

##### 指针和变址寄存器
- **SP (堆栈指针)**：指向堆栈顶部。
- **BP (基址指针)**：用于访问堆栈中的参数和局部变量。
- **SI (源变址寄存器)**：用于字符串操作中的源地址。
- **DI (目的变址寄存器)**：用于字符串操作中的目的地址。

##### 段寄存器
- **CS (代码段)**：指向当前代码段。
- **DS (数据段)**：指向当前数据段。
- **SS (堆栈段)**：指向当前堆栈段。
- **ES (附加段)**：指向附加数据段。

##### 控制寄存器
- **IP (指令指针)**：指向下一条要执行的指令。
- **FLAGS (标志寄存器)**：存储状态和控制标志。

##### 标志位寄存器
8086在特殊的16位标志寄存器中跟踪某些计算的结果：
- **U: Undefined (未定义)**  
- **OF: Overflow flag (溢出标志)**  
- **DF: String direction flag (字符串方向标志)**  
- **IF: Interrupt enable flag (中断启用标志)**  
- **TF: Single step trap flag (单步陷阱标志)**  
- **SF: Sign flag (符号标志, 结果的最高有效位)**  
- **ZF: Zero flag, set if result=0 (零标志, 如果结果为零则设置)**  
- **AF: BCD Carry flag (BCD 进位标志)**  
- **PF: Parity flag (奇偶校验标志)**  
- **CF: Carry flag (进位标志)**  

![img](https://s2.loli.net/2025/01/13/gKDLaGo7bkx8ApV.png)

#### 8086的分段内存模型

##### 分段内存模型概述
- 因为8086的寄存器只有16位，为了让它能访问20位的地址，需要使用**CS寄存器**给出代码段地址，**IP寄存器**给出偏移距离，然后计算出指令的内存地址位置。

![img](https://s2.loli.net/2025/01/13/jVTmYHvgo5yWqn4.png)

##### 数据段寄存器 (DS)
- **DS (Data Segment Register)**：指向程序的数据所在的内存段。DS寄存器存储程序数据段的起始地址。访问数据时，需要指定一个偏移量，指明数据在数据段内的位置，通过**DS:偏移量**配合工作。

> [!NOTE]
>
> 偏移量的来源包括：
>
> - **直接寻址**：偏移量可以是指令中直接给出的一个常量（例如 `mov ax, [0x1234]`）。
> - **寄存器寻址**：偏移量可以使用通用寄存器（例如 `BX`, `SI`, `DI`）（例如 `mov ax, [bx]`）。
> - **寄存器 + 常量**：偏移量可以是寄存器值 + 常量（例如 `mov ax, [bx+0x10]`）。

##### 堆栈段寄存器 (SS)
- **SS (Stack Segment Register)**：指向堆栈所在的内存段。SS寄存器存储堆栈段的起始地址。
- **SP寄存器**：指向当前栈顶的地址，它始终指向栈中最后一个被压入（pushed）的值的位置。
- **BP寄存器**：通常指向当前栈帧的基地址，主要用途是：
  - 在函数调用过程中，BP作为访问函数局部变量、函数参数的基址。
  - 方便函数内部访问栈上的数据。
  - 可以在函数返回时恢复栈帧。

##### 附加段寄存器 (ES)
- **ES (Extra Segment Register)**：用于字符串操作的额外数据段，通常作为目标段使用，通过**ES:DI**配合工作。

#### MASM 程序结构

##### 程序结构
![img](https://s2.loli.net/2025/01/13/upM8tPTJZV7G6Ys.png)

##### 编译过程
![img](https://s2.loli.net/2025/01/13/KgnFof1tA2mGOVy.png)

##### 运算符和操作数
![img](https://s2.loli.net/2025/01/13/xihBSNqcRGupv5V.png)

> [!NOTE]
>
> 这里的**Operand**也可以称作**立即数**。

#### Hello, world !

##### 详细实现
```assembly
.MODEL medium
.STACK
.DATA

msg1 db "Hello, world.$"

.CODE
.STARTUP

mov ax,@data                    ; 将 ax 寄存器的值设置为 @data 段的值
mov ds,ax                       ; 将 DS 寄存器的值设置为 @data 段的值
lea bx,msg1                     ; 获得msg1的偏移地址, 在这个情况下(DS<<4+BX)就是实际的存储msg1的地址

back:
    mov dl,[bx]                 ; 间接寻址, 获取bx寄存器对应的内存地址的第一个值到dx寄存器
    cmp dl,'$'                  ; 将 dl 寄存器中的字符与字符 $ 进行比较
    jz done                     ; 如果 dl 寄存器中的字符和$相等 (即 ZF 标志位为 1 ), 则跳转到done执行

    mov ah,02h                  ; 设置 DOS 中断 21h 的功能号为 02h, 表示调用显示字符的功能
    int 21h                     ; 调用 DOS 中断 21h, 将 dl 寄存器中的字符显示在屏幕上

    inc bx                      ; 将 bx 寄存器的值加 1, 指向字符串 msg1 的下一个字符
    jmp back                    ; 无条件跳转到 back 标签处

done:
    nop                         ; 空操作指令

.EXIT

END
```

##### 简洁实现
```assembly
.MODEL small
.STACK
.DATA
    msg DB 'Hello, World!$'    ; 定义字符串，以$结尾
    
.CODE
.STARTUP

    mov ax, @data
    mov ds, ax

    mov ah, 09h               ; 打印字符串
    lea dx, msg
    int 21h

.EXIT

END
```

##### 常用 21h 功能号
- **01h**: 从键盘读取一个字符, 并将字符存入 AL 寄存器
- **02h**: 在屏幕上输出 DL 寄存器中的字符
- **09h**: 在屏幕上输出以 DS:DX 指向的、以 $ 结尾的字符串
- **0Ah**: 从键盘读取一个字符串
- **3Ch**: 创建一个文件
- **3Dh**: 打开一个文件
- **3Eh**: 关闭一个文件
- **3Fh**: 从文件中读取数据
- **40h**: 向文件中写入数据
- **4Ch**: 退出程序

##### 重要ASCII码
- **0x0A**: Line Feed (LF), 换行，等价于 `\n`
- **0x0D**: Carriage Return (CR), 回车，等价于 `\r`

---

### Lecture 3: Assembly Language (Ⅱ)

#### 寻址模式

##### 立即寻址
- **立即寻址**是指运算数以**字面量**形式写在指令里面，如`mov ax, 10`。这里的运算数也称作*立即数*。
- 立即数直接嵌入指令中，无需额外的寻址操作，因此执行速度快。

##### 寄存器寻址
- **寄存器寻址**指运算数保存在某个通用寄存器当中，如`mov ax, bx`。
- 寄存器的访问是在CPU内部的，速度非常快，因此这种寻址方式效率高。

##### 直接寻址
- **直接寻址**如`mov ax, Count`，把data段当中的变量`Count`作为操作数。
- 实际上，变量`Count`在汇编器的眼里，只是对应数据所在的地址。因此，这相当于把`Count`所在地址的值赋给`ax`。
- 如果要指定其他的段，可以写作`mov ax, ES:Count`，即表示在额外段上的内容。

##### 寄存器间接寻址
- **寄存器间接寻址**是把偏移地址存在寄存器（通常是索引寄存器BX, BP, SI或DI）当中。如果是BP，对应的段就是栈段，否则是数据段。
- 这种寻址方式与高级语言中的数组访问类似：
  - `mov ax, [bx]`表示`ax = array[bx]`
  - `mov [bx], ax`表示`array[bx] = ax`

#### 8086 指令格式

![img](https://s2.loli.net/2025/01/13/ENAvqQBwh7eMtfO.png)

##### Byte 1
- **Opcode (操作码):** 决定指令的具体动作（如`MOV`）。
- **D (方向旗标):** 指明数据传输的方向，是从源到目标，还是从目标到源。

##### Byte 2
- **W (字/字节):** 指定数据大小，16位字还是8位字节。
- **Mod (寻址模式):** 确定操作数地址的获取方式。
- **Reg (寄存器):** 指示一个寄存器。
- **R/M (寄存器/内存):** 指示另一个操作数是寄存器还是内存。

##### Low Byte/High Byte
- 可选字段，用于存放立即数或内存地址偏移量。

#### 8086 寄存器编号

![img](https://s2.loli.net/2023/04/06/oshgKL6aU9YIAEW.png)

#### 8086 寻址模式

![img](https://s2.loli.net/2025/01/13/cSqZUoIT2Of1tY4.png)

##### 寻址模式详解
- **Mod=00:** **没有偏移量**，或只是使用寄存器进行内存间接寻址。
- **Mod=01:** **8位偏移量**（d8），需要额外的1个字节来存储偏移量。
- **Mod=10:** **16位偏移量**（d16），需要额外的2个字节来存储偏移量。
- **Mod=11:** **寄存器寻址**，直接使用寄存器作为操作数，不涉及内存访问。

##### 示例
`mov SP, BX`的二进制指令是：

| opcode | D           | W    | Mod            | Reg   | R/M   |
| ------ | ----------- | ---- | -------------- | ----- | ----- |
| 100010 | 1           | 1    | 11             | 100   | 011   |
| `mov`  | to register | word | 寄存器寻址模式 | to SP | to BX |

---

### Lecture 4: Assembly Language (Ⅲ)

#### 算数运算命令

| **指令** | **代码**     | **作用**                                             |
| -------- | ------------ | ---------------------------------------------------- |
| **ADD**  | `ADD AX, BX` | 加法运算, 将 AX 和 BX 相加, 结果存入 AX              |
| **ADC**  | `ADC AX, BX` | 带进位的加法运算, 将 AX, BX, CF 相加, 结果存入 AX    |
| **SUB**  | `SUB AX, BX` | 减法运算, 将 AX 减去 BX, 结果存入 AX                 |
| **MUL**  | `MUL BX`     | 无符号乘法, 将 AX 和 BX 相乘, 结果存入 DX:AX         |
| **IMUL** | `IMUL BX`    | 有符号乘法, 将 AX 和 BX 相乘, 结果存入 DX:AX         |
| **DIV**  | `DIV BX`     | 无符号除法, 将 DX:AX 除以 BX, 商存入 AX, 余数存入 DX |
| **IDIV** | `IDIV BX`    | 有符号除法, 将 DX:AX 除以 BX, 商存入 AX, 余数存入 DX |

> [!NOTE]
>
> `DIV` 与 `IDIV`在除数是word(16bit)的时候, 被除数是 32 位的 `DX:AX`,`DX`的值可能会产生意想不到的结果
>
> `MUL` 与 `IMUL`在乘数是word(16bit)的时候, 结果是32位的, 低 16 位保存在 `AX` 里面, 高 16 位保存到 `DX` 里面, 导致`DX`寄存器的值被覆盖

#### 十进制算数

了解即可, 看不懂, 去死吧！[介绍](https://goo.su/Q3MVxu)

![img](https://s2.loli.net/2025/01/14/gFcZlVukbrEM7zt.png)

##### ASCII调整指令

```assembly
mov al, '9'  ; AL = 39h ('9'的ASCII码)
add al, '8'  ; AL = 39h + 38h = 71h
aaa          ; 调整AL为09h, AH += 1 (AH = 01h)
; 结果: AL = 09h, AH = 01h (表示BCD格式的17)
mov ax, 0507h  ; AH = 05h, AL = 07h (表示未压缩BCD的57)
aad            ; AX = 0037h (37的二进制形式)
mov bl, 6      ; BL = 6
div bl         ; AX / BL, AL = 6 (商), AH = 1 (余数)
; 结果: AL = 06h, AH = 01h
```

##### BCD调整指令

```assembly
mov al, 59h  ; AL = 59h (59的压缩BCD格式)
add al, 27h  ; AL = 59h + 27h = 80h
daa          ; 调整AL为86h (86的压缩BCD格式)
; 结果: AL = 86h
mov al, 47h  ; AL = 47h (47的压缩BCD格式)
sub al, 59h  ; AL = 47h - 59h = EEh (借位发生)
das          ; 调整AL为88h (88的压缩BCD格式)
; 结果: AL = 88h
```

#### 逻辑指令

![img](https://s2.loli.net/2025/01/14/21jtb5mxlWLsIKk.png)

| 指令  | 示例               | 含义                            |
| ----- | ------------------ | ------------------------------- |
| `AND` | `AND A, B`         | 按位与                          |
| `OR`  | `OR A, B`          | 按位或                          |
| `XOR` | `XOR A, B`         | 异或                            |
| `BT`  | `BT Base, Offset`  | 指定地址的值赋给 CF             |
| `BTC` | `BTC Base, Offset` | 指定地址位的值赋给 CF, 该位取反 |
| `BTR` | `BTR Base, Offset` | 指定地址位的值赋给 CF, 该位设零 |
| `BTS` | `BTS Base, Offset` | 指定地址位的值赋给 CF, 该位设一 |
| `BSF` | `BSF A, B`         | B 最低的 1 是第几位, 赋给 A     |
| `BSR` | `BSR A, B`         | B 最高的 1 是第几位, 赋给 A     |

#### 逻辑偏移

![img](https://s2.loli.net/2025/01/17/SVDghbI2UTnLW8J.png)

| 指令 | 示例             | 含义                                                        |
| ---- | ---------------- | ----------------------------------------------------------- |
| SHL  | `SHL AX, 1`      | 将AX寄存器的内容逻辑左移1位, 空出的位用0填充                |
| SHR  | `SHR BX, 2`      | 将BX寄存器的内容逻辑右移2位, 空出的位用0填充                |
| SAL  | `SAL CX, 1`      | 将CX寄存器的内容算术左移1位, 空出的位用0填充 (与SHL相同 )   |
| SAR  | `SAR DX, 3`      | 将DX寄存器的内容算术右移3位, 空出的位用符号位填充           |
| ROL  | `ROL AL, 1`      | 将AL寄存器的内容循环左移1位, 移出的位重新填充到右侧         |
| ROR  | `ROR BL, 2`      | 将BL寄存器的内容循环右移2位, 移出的位重新填充到左侧         |
| RCL  | `RCL AX, 1`      | 将AX寄存器的内容带进位循环左移1位, 进位标志 (CF) 参与循环   |
| RCR  | `RCR BX, 1`      | 将BX寄存器的内容带进位循环右移1位, 进位标志 (CF) 参与循环   |
| SHLD | `SHLD AX, BX, 4` | 将AX和BX寄存器的内容一起逻辑左移4位, AX的高位由BX的低位填充 |
| SHRD | `SHRD CX, DX, 3` | 将CX和DX寄存器的内容一起逻辑右移3位, CX的低位由DX的高位填充 |

> [!NOTE]
>
> **逻辑右移 (SHR )用0填充空出的高位, 而算术右移 (SAR )用符号位填充空出的高位**

#### 标志位指令

| 指令  | 含义              |
| ----- | ----------------- |
| `CLC` | 进位标志置零      |
| `STC` | 进位标志设一      |
| `CMC` | 进位标志取反      |
| `CLD` | 方向标志置零      |
| `STD` | 方向标志设一      |
| `CLI` | IF 置零, 关闭中断 |
| `STI` | IF 设一, 打开中断 |

#### 分支控制

条件跳转是短跳转, 操作数是一个字节, 允许向后跳转 -128 或向前跳转 +127

无条件跳跃可以跳得更远, 可以直接地址跳转, 允许 +/-32K 的跳转, 甚至允许跳转到AX寄存器！

##### 常用指令

| 指令   | 含义             | flag             | 反指令 | 反含义               | 反 flag          |
| ------ | ---------------- | ---------------- | ------ | -------------------- | ---------------- |
| `JA`   | Above            | `ZF=0 and CF=0`  | `JNA`  | Not Above            | `ZF=1 or CF=1`   |
| `JAE`  | Above or Equal   | `CF=0`           | `JNAE` | Not Above or Equal   | `CF=1`           |
| `JB`   | Below            | `CF=1`           | `JNB`  | Not Below            | `CF=0`           |
| `JBE`  | Below or Equal   | `ZF=1 or CF=1`   | `JNBE` | Not Below or Equal   | `ZF=0 and CF=0`  |
| `JC`   | Carry            | `CF=1`           | `JNC`  | Not Carry            | `CF=0`           |
| `JCXZ` | CX is Zero       | `CX=0`           | -      | -                    | -                |
| `JE`   | Equal            | `ZF=1`           | `JNE`  | Not Equal            | `ZF=0`           |
| `JG`   | Greater          | `ZF=0 and SF=OF` | `JNG`  | Not Greater          | `ZF=1 or SF!=OF` |
| `JGE`  | Greater or Equal | `SF = OF`        | `JNGE` | Not Greater or Equal | `SF != OF`       |
| `JL`   | Less             | `SF != OF`       | `JNL`  | Not Less             | `SF = OF`        |
| `JLE`  | Less or Equal    | `ZF=1 or SF!=OF` | `JNLE` | Not Less or Equal    | `ZF=0 and SF=OF` |
| `JO`   | Overflow         | `OF=1`           | `JNO`  | No Overflow          | `OF=0`           |
| `JP`   | Parity           | `PF=1`           | `JNP`  | Not Parity           | `PF=0`           |
| `JPE`  | Parity is Even   | `PF=1`           | `JPO`  | Parity is Odd        | `PF=0`           |
| `JS`   | Signed           | `SF=1`           | `JNS`  | Not Signed           | `SF=0`           |
| `JZ`   | Zero             | `ZF=1`           | `JNZ`  | Not Zero             | `ZF=0`           |

#### 循环

主要有三种: 

- `LOOP`, 相当于

  ```c
  do {
      // 循环体代码
      CX--;
  } while (CX != 0);
  ```

- `LOOPZ`, 相当于

  ```c
  do {
      // 循环体代码
      CX--;
  } while (CX != 0 && ZF == 1);
  ```

- `LOOPNZ`, 相当于

  ```c
  do {
      // 循环体代码
      CX--;
  } while (CX != 0 && ZF == 0);
  ```

#### 延迟

通过调整运行的语句来延迟特定的时间，和CPU的频率有关

##### 短延迟

对于如下程序

```assembly
  mov cx, N  ; 消耗 4 时钟周期, 这里 N 是字面量, 但是取值还未确定
tag:
  nop        ; 消耗 3 时钟周期
  nop        ; 消耗 3 时钟周期
  loop tag   ; 消耗 17 个时钟周期, 退出循环时仅 5 个时钟周期
```

总延迟时间的计算公式为: $C = 4 + N \times 23 - 12$

假设需要延迟 1000 个时钟周期, 可以通过以下步骤计算循环次数 \( N \): 

$1000 = 4 + N \times 23 - 12$

解方程得到: 

$N = \frac{1000 - 4 + 12}{23} \approx 43.65$

因此, 设置 \( N = 44 \) 即可实现大约 1000 个时钟周期的延迟

##### 长延迟

考虑如下程序

```assembly
.STARTUP
mov ah,02
mov dl,'S'
int 021h

mov bx, 30000 ;4

back2: 
  mov cx, 30000 ;4
back1: 
  nop ;3
  loop back1

  dec bx
  jnz back2

  mov ah,02
  mov dl,'F'
  int 021h
EXIT
```

延迟计算公式为: 

$C_{T}=C_{0}+N(C_{BK}){-12}$

先计算内循环: 

$\begin{flalign*}
&C_T = C_0 + N(C_{_{BK}}) - 12 \\
&C_T = 4 + 3000(20) - 12 \\
&C_T = 599992
\end{flalign*}$

然后计算外循环: 

$\begin{flalign*}
&C_T = C_0 + N(C_{BK}) - 12 \\
&C_T = 4 + 30000(59992 + 2 + 16) - 12 \\
&C_T = 1.8 \times 10^{10} \text{ Clock cycles}
\end{flalign*}$

实际上程序只花了15s来运行, 计算出来的时钟频率是1200MHz, 是目标机器的时钟频率(300MHz)的4倍,原因是现代处理器使用 **指令并行** 技术

#### 打印数字的方法

基于栈的实现: 

```assembly
.MODEL medium
.STACK
.DATA
ten db 10
.CODE
.STARTUP
mov ax, 12345
call Print
.EXIT

Print:
    push bx        ; 函数调用, 储存原来寄存器的值, 固定操作
    push cx
    push dx
    mov cx, 5      ; 初始化循环计数器为 5
    mov bx, 10000

again:
    mov dx, 0h     ; 除法前清空 dx
    div bx         ; dx:ax /= bx
    or al, 030h    ; 数字转 ASCII
    push dx        ; 保存余数
    mov dl, al     ; 传参给 21h 中断
    mov ah, 02h    ; 输出字符模式
    int 021h
    mov dx, 0h     ; 除法前清空 dx
    mov ax, bx     ; bx /= 10
    div ten
    mov bx, ax
    pop ax
    loop again     ; cx 自动减 1, 不为 0 则跳转
    pop dx         ; 函数调用结束, 恢复原来寄存器的值, 固定操作
    pop cx
    pop bx
    ret

END
```

---

### Lecture 5: 汇编语言（Ⅳ）

#### 打印负数

##### 负数打印的原理

- **符号判断**：程序首先检查数值符号位，判断是否为负数。
- **负号输出**：若为负数，则先输出负号 `-`。
- **取绝对值**：对负数取反加一，转换为正数进行打印处理。

##### 打印负数的汇编代码实现

```assembly
.MODEL medium
.STACK
.DATA
ten word 10
    .CODE
    .STARTUP
    mov ax, 32768  ; 将要打印的数值 (示例为 -32768 的补码表示) 放入 AX 寄存器
    call Print     ; 调用 Print 子程序进行打印
    .EXIT

; Print 子程序：负责将 AX 寄存器中的数值以十进制形式打印到屏幕
Print:
    push bx       ; 保护寄存器 BX, CX, DX 的值
    push cx
    push dx
    mov cx, 5       ; 设置循环次数为 5，用于打印五位十进制数
    mov bx, 10000   ; BX 寄存器设置为 10000，用于取出万位数字
    test ax, 8000h  ; 检测 AX 寄存器的最高位 (符号位)
    jz Positive     ; 如果符号位为 0 (正数)，跳转到 Positive 标签
    ; 如果是负数，执行以下代码：
    push ax       ; 暂时保存 AX 的值
    mov ah, 02h   ; 设置 DOS 功能号为 02h (显示字符)
    mov dl, '-'   ; 将 '-' 字符的 ASCII 码放入 DL 寄存器
    int 021h      ; 调用 DOS 中断 21h，显示 '-' 字符
    pop ax        ; 恢复 AX 寄存器的值 (负数)
    not ax        ; AX 取反 (按位非)
    add ax, 1     ; AX 加 1，得到负数的绝对值 (补码转原码)
    jmp Positive    ; 跳转到 Positive 标签，打印绝对值

; Positive 标签：处理正数和负数的绝对值打印
Positive:
    mov dx, 0h    ; DX 寄存器清零，为除法运算做准备
    div bx        ; AX 除以 BX (10000)，商在 AX，余数在 DX。这里用于取出万位数字，但第一次循环BX是10000，实际是取最高位
    or al, 030h   ; 将 AL 寄存器的值与 30h (字符 '0' 的 ASCII 码) 进行按位或运算，将数字转换为 ASCII 字符
    push dx       ; 余数 DX 入栈，暂存个位/十位/百位/千位数字，后续会依次出栈打印
    mov dl, al    ; 将个位数字的 ASCII 码放入 DL 寄存器
    mov ah, 02h   ; 设置 DOS 功能号为 02h (显示字符)
    int 021h      ; 调用 DOS 中断 21h，显示当前数字字符
    mov dx, 0h    ; DX 寄存器清零，为下一次除法运算做准备
    mov ax, bx    ; 将 BX 的值 (当前的除数，初始为 10000) 复制到 AX
    div ten       ; AX 除以 ten (10)，结果商在 AX，余数在 DX。用于将除数降一位 (10000 -> 1000 -> 100 -> 10 -> 1)
    mov bx, ax    ; 将新的除数 (缩小 10 倍) 更新到 BX 寄存器
    pop ax        ; 从栈中弹出之前暂存的余数到 AX，为下一次循环做准备 (实际上这里pop出来的是上一次div的余数，但是后面又被mov dx, 0h覆盖了，应该pop到dx才对，这里代码有误)
    loop Positive   ; 循环 CX 次，打印剩余的数字
    pop dx        ; 恢复寄存器 DX, CX, BX 的值
    pop cx
    pop bx
    ret           ; 子程序返回
END
```

#### 字符串

##### 字符串的定义

**字符串** (String) 是一组用于描述文本的 **ASCII(美国信息交换标准代码)** 字符序列。在汇编语言中，字符串通常以不同的方式进行定义和存储，常见的表示方法包括：

- **NULL 结尾字符串**：以 **NULL 字节** (数值为 0 的字节) 作为字符串的结束符。例如 `"Charles Markham /0"`。这种方式简单直观，但需要遍历字符串才能确定其长度。
- **长度前缀字符串**：字符串的第一个字节用于存储字符串的长度，后续字节存储字符串的内容。例如 `"/15 Charles Markham"`，其中 `/15` 表示字符串长度为 15。这种方式可以快速获取字符串长度，但限制了字符串的最大长度（因为长度信息通常只用一个字节存储）。

##### 字符串的存储方式

- **连续内存空间**：字符串的字符在内存中是连续存储的，以便于程序进行访问和操作。
- **ASCII 编码**：每个字符都使用 ASCII 编码表示，占用一个字节的存储空间。

#### 字符串操作

##### `LEA` 命令：加载有效地址

`LEA` (**Load Effective Address**) 命令用于将**有效地址**加载到指定的寄存器中，常用于获取变量或内存地址。

- **功能**：将源操作数（通常是内存地址）的有效地址传送给目的操作数（寄存器）。
- **示例**：

  ```assembly
  msg1 db "Hello, world.$" ; 定义字符串 msg1
  lea SI, msg1          ; 将 msg1 的有效地址加载到 SI 寄存器
  ```
  **说明**：上述代码中，`lea SI, msg1` 将 `msg1` 字符串在内存中的起始地址加载到 **SI(源变址寄存器)** 寄存器中。此时，SI 寄存器就指向了字符串 `msg1` 的首地址。

##### `MOVSB` 命令：移动字符串字节

`MOVSB` (**Move String Byte**) 命令用于将数据从源地址复制到目标地址，以字节为单位进行操作。

- **功能**：将 **DS:SI** 寄存器指向的内存地址中的一个字节数据复制到 **ES:DI** 寄存器指向的内存地址。
- **寄存器影响**：执行 `MOVSB` 指令后，**SI(源变址寄存器)** 和 **DI(目的变址寄存器)** 寄存器的值会自动递增或递减，递增或递减的方向由 **DF(方向标志位)** 决定。
  - 当 DF = 0 时，SI 和 DI 递增（正向复制）。
  - 当 DF = 1 时，SI 和 DI 递减（反向复制）。
- **应用场景**：常用于字符串复制、内存块移动等操作。
- **示例**：

  ```assembly
  msg1 db "Hello$"  ; 源字符串 msg1
  msg2 db "     $"  ; 目标字符串 msg2，预留空间
  
  lea SI, msg1      ; SI 指向源字符串 msg1 的首地址
  lea DI, msg2      ; DI 指向目标字符串 msg2 的首地址
  
  mov cx, 5         ; 设置循环次数为 5，表示要复制的字节个数
  cld               ; 清除方向标志位 DF，设置正向复制 (SI, DI 递增)
  rep movsb         ; 重复执行 MOVSB 指令 CX 次，完成字符串复制
  ```
  **说明**：这段代码使用 `MOVSB` 命令将 `msg1` 的前 5 个字节复制到 `msg2` 中。`rep` (**repeat**)  前缀使得 `MOVSB` 指令重复执行 `CX` 次，`cld` (**clear direction flag**) 指令清除方向标志位 DF，确保复制过程地址递增。

##### `CMPSB` 命令：比较字符串字节

`CMPSB` (**Compare String Byte**) 命令用于比较两个字符串中的字节。

- **功能**：比较 **DS:SI** 寄存器指向的字节和 **ES:DI** 寄存器指向的字节。
- **标志位影响**：根据比较结果设置 **标志寄存器** 中的标志位，例如 **ZF(零标志位)**、**SF(符号标志位)** 等。
  - 若两个字节相等，则 ZF = 1。
  - 若不相等，则 ZF = 0。
- **寄存器影响**：执行 `CMPSB` 指令后，SI 和 DI 寄存器的值也会根据 DF 的值自动递增或递减。
- **应用场景**：常用于字符串比较、查找等操作。
- **示例**：

  ```assembly
  msg1 db "Hello$" ; 第一个字符串 msg1
  msg2 db "Hello$" ; 第二个字符串 msg2
  
  lea SI, msg1     ; SI 指向字符串 msg1 的首地址
  lea DI, msg2     ; DI 指向字符串 msg2 的首地址
  
  mov cx, 5        ; 设置循环次数为 5，表示要比较的字节个数
  cld              ; 清除方向标志位 DF，设置正向比较 (SI, DI 递增)
  rep cmpsb        ; 重复执行 CMPSB 指令 CX 次，比较字符串
  jz equal         ; 如果 ZF = 1 (比较结果相等)，跳转到 equal 标签
  jmp not_equal    ; 如果 ZF = 0 (比较结果不相等)，跳转到 not_equal 标签
  
  equal:
    ; 字符串相等时执行的代码
  not_equal:
    ; 字符串不相等时执行的代码
  ```
  **说明**：这段代码使用 `CMPSB` 命令比较 `msg1` 和 `msg2` 的前 5 个字节。`rep cmpsb` 会重复比较 `CX` 次，并根据比较结果设置标志位。`jz` (**jump if zero**) 指令检查 ZF 标志位，判断比较结果是否相等。

> [!NOTE] 
>
> **REP(Repeat)** 修饰符可以放在多种字符串指令（如 `MOVSB`, `CMPSB`, `STOSB`, `LODSB` 等）的前面，用于重复执行该指令 `CX` 次。 `REP` 代表 **重复字符串前缀**，它可以简化循环控制，提高字符串操作的效率。

##### CISC 与 RISC 指令集对比

`MOVSB` 和 `CMPSB` 等字符串操作指令是 **CISC(复杂指令集计算机)** 架构的特点之一。为了更好理解 CISC 的特点，以下进行 CISC 和 **RISC(精简指令集计算机)** 的对比：

- **CISC (复杂指令集计算机)**：
    - **定义**：**复杂指令集计算机** (Complex Instruction Set Computer) 是一种微处理器指令集架构，其特点是指令数量众多且功能复杂，每条指令可以执行多个低级操作，例如从存储器读取、存储、计算等，都集成在一条指令中。
    - **特点**：
        - 指令数目多而复杂。
        - 每条指令的长度不固定。
        - 计算机需要进行指令解码和判读，增加了硬件设计的复杂性和性能开销。
    - **代表架构**：x86、AMD Opteron 等。维基百科对 CISC 的描述如下：

      > **复杂指令集计算机** (英语: Complex Instruction Set Computer；缩写: **CISC**) 是一种微处理器指令集架构, 每个指令可执行若干低端操作, 诸如从存储器读取、存储、和计算操作, 全部集于单一指令之中与之相对的是**精简指令集**
      >
      > 复杂指令集的特点是指令数目多而复杂, 每条指令字长并不相等, 电脑必须加以判读, 并为此付出了性能的代价
      >
      > 属于复杂指令集的处理器有 CDC 6600、System/360、VAX、PDP-11、Motorola 68000家族、x86、AMD Opteron 等

- **RISC (精简指令集计算机)**：
    - **定义**：**精简指令集计算机** (Reduced Instruction Set Computer) 架构，其特点是指令集精简，指令数量较少，每条指令只完成单一、基本的操作。复杂的操作通常由多条简单指令组合完成。
    - **特点**：
        - 指令数量少且简单。
        - 指令长度固定。
        - 硬件设计相对简单，指令执行效率高。
    - **代表架构**：ARM、MIPS 等。

##### CISC 和 RISC 实现乘法对比

为了更直观地理解 CISC 和 RISC 的区别，以下通过乘法运算的汇编代码示例进行对比：

**RISC 实现乘法**

```assembly
.STARTUP

mov ax, 0        ; 初始化结果寄存器 AX 为 0
mov dx, 100      ; 乘数 100 放入 DX 寄存器
mov bx, 123      ; 被乘数 123 放入 BX 寄存器
mov cx, 8        ; 循环次数设置为 8 (假设进行 8 位乘法)

back:
    rcr dx, 1    ; 将 DX 寄存器最低位循环移入 CF (进位标志位)
    jnc over     ; 如果 CF = 0 (最低位为 0)，则跳转到 over 标签
    add ax, bx   ; 如果 CF = 1 (最低位为 1)，则将 BX 累加到 AX (部分积)

over:
    shl bx, 1    ; 将 BX 寄存器左移一位，相当于乘以 2
    loop back    ; 循环计数器 CX 减 1，如果 CX != 0，则跳转到 back 标签继续循环

call Print
.EXIT
```
**代码说明**：RISC 实现乘法通常采用移位和加法相结合的方式，通过循环逐步计算乘积。

**CISC 实现乘法**

```assembly
.STARTUP

mov dl, 100    ; 乘数 100 放入 DL 寄存器
mov al, 123    ; 被乘数 123 放入 AL 寄存器

mul dl         ; 执行乘法指令 mul，AL * DL，结果存储在 AX 寄存器

call Print
.EXIT
```
**代码说明**：CISC 架构的 x86 汇编提供了 `mul` (**multiply**) 乘法指令，可以直接完成乘法运算，指令简洁高效。

**对比总结**：

- RISC 实现乘法需要多条指令（移位、判断、加法、循环），代码相对复杂。
- CISC 实现乘法只需要一条 `mul` 指令，代码简洁明了。

这体现了 CISC 指令集复杂但功能强大，RISC 指令集精简但需要组合使用才能完成复杂操作的特点。

> [!NOTE]
>
> 除法运算的 RISC 实现通常也采用类似的思路，通过循环减法和移位操作完成，过程较为复杂，此处省略了除法部分的 RISC 代码示例。

#### 浮点数

##### 浮点数的概念

**浮点数** (Floating-point Number) 是一种用**科学计数法**表示实数的方式，用于在计算机中存储和处理小数或非常大/小的数值。浮点数表示方法通常包含三个关键组成部分：

- **符号位 (Sign)**：用于表示数值的正负，通常 0 表示正数，1 表示负数。
- **指数位 (Exponent)**：用于表示数值的**数量级**或**小数点的位置**。指数位决定了数值的大小范围。
- **尾数位 (Mantissa 或 Fraction)**：用于表示数值的**精度**，即小数点后的有效数字。尾数位决定了数值的精确程度。

![img](https://s2.loli.net/2025/01/17/qo9xS5yJDXslOGp.png)

##### 浮点数的通用表示形式

浮点数的通用数学表示形式为：

$\text{Value} = (-1)^{\text{Sign}} \times \text{Mantissa} \times 2^{\text{Exponent}}$

##### 规格化浮点数

**规格化浮点数** (Normalized Floating-point Number) 是 **IEEE 754 标准** 中最常用的一种浮点数表示形式。

- **特点**：**尾数位 (Mantissa)** 的最高位**隐含为 1**，即尾数的整数部分总是 1。由于最高位固定为 1，因此在存储时可以省略这一位，从而节省一个比特的存储空间，提高精度。

###### 规格化浮点数的表示方法

- **尾数 (Mantissa)**：只存储**小数部分**，整数部分的 `1` 是隐含的。
- **指数 (Exponent)**：存储经过**偏移量 (Bias)** 调整后的指数值。对于单精度浮点数，偏移量 Bias 通常为 127；对于双精度浮点数，偏移量 Bias 通常为 1023。指数位不能全为 0 或全为 1（这两种情况有特殊用途，见下文）。
  - **单精度浮点数指数范围**：1 到 254 (实际指数范围为 -126 到 127)
  - **双精度浮点数指数范围**：1 到 2046 (实际指数范围为 -1022 到 1023)

###### 规格化浮点数的计算公式

$\text{Value} = (-1)^{\text{Sign}} \times 1.\text{Mantissa} \times 2^{\text{Exponent} - \text{Bias}}$

###### 规格化浮点数示例

**单精度浮点数示例**：

假设有一个单精度浮点数，其二进制表示为：

- **符号位 (Sign)**: `0` (表示正数)
- **指数位 (Exponent)**: `10000001` (二进制) = 129 (十进制)。偏移量 Bias = 127，实际指数 = 129 - 127 = 2。
- **尾数位 (Mantissa)**: `10100000000000000000000` (二进制)。隐含前导 `1`，实际尾数为 `1.101` (二进制)。

**计算数值**：

$\text{Value} = 1.101_2 \times 2^{2} = 110.1_2 = 6.5_{10}$

##### 非规格化浮点数

**非规格化浮点数** (Denormalized Floating-point Number) 用于表示**非常接近于零**的数值，其特点是尾数部分的最高位**不隐含为 1**，而是显式表示。

- **应用场景**：用于解决规格化浮点数无法表示零值以及接近零的小数值的问题，扩展了浮点数可以表示的数值范围，使其更接近零。

###### 非规格化浮点数的表示方法

- **尾数 (Mantissa)**：**没有隐含的前导 1**，实际存储的就是完整的小数部分。
- **指数 (Exponent)**：**指数位全为 0**。
  - **单精度浮点数指数位**：`00000000` (二进制) = 0 (十进制)
  - **双精度浮点数指数位**：`00000000000` (二进制) = 0 (十进制)

###### 非规格化浮点数的计算公式

$\text{Value} = (-1)^{\text{Sign}} \times 0.\text{Mantissa} \times 2^{1 - \text{Bias}}$

> [!NOTE]
>
> 非规格化浮点数的指数部分固定为 `1 - Bias`，而不是 `0 - Bias`，这是 IEEE 754 标准的规定，目的是为了平滑地过渡到规格化浮点数。

###### 非规格化浮点数示例

**单精度浮点数示例**：

假设有一个单精度非规格化浮点数，其二进制表示为：

- **符号位 (Sign)**: `0` (表示正数)
- **指数位 (Exponent)**: `00000000` (二进制) = 0 (十进制)。偏移量 Bias = 127，实际指数固定为 `1 - 127 = -126`。
- **尾数位 (Mantissa)**: `00000000000000000000001` (二进制)。没有隐含前导 `1`，实际尾数为 `0.00000000000000000000001` (二进制)。

**计算数值**：

$\text{Value} = 0.00000000000000000000001_2 \times 2^{-126} \approx 1.4 \times 10^{-45}$

[视频讲解 - 浮点数](https://www.bilibili.com/video/BV1VK4y1f7o6/)

#### 浮点数的计算

##### 浮点数加减运算的原则

**浮点数加减运算** 遵循 **先对齐，再计算** 的原则。

- **对齐**：指的是**对齐指数位**。当两个浮点数进行加减运算时，如果它们的**指数位 (Exponent)** 不相同，需要先进行**对阶**操作，将它们的指数位对齐到相同的数量级。
  - **对阶原则**：通常将**较小的指数**对齐到**较大的指数**。
  - **对阶方法**：将较小指数的浮点数的尾数位**右移**，每右移一位，指数位加 1，直到两个浮点数的指数位相同。尾数右移会降低精度，因此对阶操作可能会导致精度损失。

##### 浮点数加法运算示例

例如，计算 0.5 与 0.125 的和。

1.  **浮点数表示**：
    - 0.5 的浮点数表示：$(-1)^0 \times 1.0 \times 2^{-1}$
    - 0.125 的浮点数表示：$(-1)^0 \times 1.0 \times 2^{-3}$

2.  **对阶**：
    - 比较指数位：0.5 的指数为 -1，0.125 的指数为 -3。0.5 的指数较大。
    - 对齐指数位：将 0.125 的指数对齐到 -1，需要将指数增加 2 (从 -3 增加到 -1)，尾数位右移 2 位。
    - 对阶后的 0.125 表示：$(-1)^0 \times 0.01 \times 2^{-1}$ (尾数 1.0 右移两位变为 0.01)

3.  **尾数相加**：
    - 将对阶后的两个浮点数的尾数部分相加：$1.0 + 0.01 = 1.01$

4.  **结果规格化** (本例中已规格化)：
    - 最终结果的浮点数表示：$(-1)^0 \times 1.01 \times 2^{-1}$

5.  **结果转换为十进制**：
    - $(-1)^0 \times 1.01_2 \times 2^{-1} = 1.01_2 \times 2^{-1} = 0.101_2 = 0.625_{10}$ （此处计算有误，应为0.5 + 0.125 = 0.625，但示例中0.5+0.125=0.625的二进制表示应为0.101，而示例结果1.01 * 2^-1 = 1.01/2 = 0.505，计算过程需要修正）

**修正后的计算结果**：

- $1.01_2 \times 2^{-1} = 1.01_2 / 2 = 0.101_2 = 0.5_{10} + 0.125_{10} = 0.625_{10}$
-  二进制 `0.101` 转换为十进制为 `1*2^-1 + 0*2^-2 + 1*2^-3 = 0.5 + 0 + 0.125 = 0.625`。

因此，0.5 + 0.125 = 0.625 的浮点数表示为 $(-1)^0 \times 1.01 \times 2^{-1}$。

#### 8087 数学协处理器

> 处理器都有 CP 了 (╯‵□′)╯︵┻━┻

##### 8087 协处理器的概述

**8087 协处理器** (8087 Coprocessor) 是一种**数学协处理器**，也常被称为 **浮点处理器** (Floating-Point Processor) 或 **数字数据处理器 (Numeric Data Processor, NDP)**。

- **作用**：8087 不是一个独立的 **CPU(中央处理器)**，而是作为 **CPU 的辅助单元**，专门用于**加速浮点数运算**。它与 Intel 8086、8088 等 CPU 协同工作，扩展了 CPU 的数值计算能力，尤其是在浮点数运算方面。
- **历史背景**：在早期计算机系统中，CPU 的浮点运算能力相对较弱，为了提高浮点运算性能，出现了数学协处理器。8087 是 Intel 公司为 8086/8088 处理器设计的协处理器，显著提升了当时计算机的科学计算能力。

![img](https://s2.loli.net/2025/01/17/Nqe5dL6AnGW4b9l.png)
##### 8087 的状态字组

**状态字组 (Status Word)** 是 8087 协处理器中的一个寄存器，用于记录浮点运算的状态和异常信息。

![img](https://s2.loli.net/2025/01/17/9kFJtIMY6uq3oA7.png)

- **作用**：状态字组中的各个标志位反映了最近一次浮点运算的结果状态，例如是否发生溢出、下溢、除零错误、精度丢失等异常情况，以及运算结果的符号、舍入模式等信息。
- **程序应用**：程序员可以通过读取状态字组，检查浮点运算是否发生异常，并根据状态信息进行相应的错误处理或流程控制。

##### 8087 的控制字组

**控制字组 (Control Word)** 是 8087 协处理器中的另一个寄存器，用于控制浮点运算的精度、舍入模式、异常处理方式等。

![img](https://s2.loli.net/2025/01/17/Morvu9qm1d6ZICk.png)

- **作用**：通过设置控制字组中的各个控制位，可以配置 8087 的运算行为，例如：
  - **精度控制**：设置浮点运算的精度 (单精度、双精度、扩展精度)。
  - **舍入控制**：设置浮点数舍入模式 (例如，舍入到最近偶数、向上舍入、向下舍入、截断舍入)。
  - **异常屏蔽**：屏蔽或使能各种浮点异常 (例如，溢出异常、除零异常、无效操作异常)。
- **程序应用**：程序员可以根据具体的应用需求，配置控制字组，以满足不同的精度、性能和可靠性要求。

##### 8087 的栈结构

**栈 (Stack)** 是 8087 协处理器内部用于存储浮点数据的存储区域。

![img](https://s2.loli.net/2025/01/17/cXJCY3xZ6r4gRNV.png)

- **特点**：
  - **8 层栈结构**：8087 栈共有 8 个 **寄存器** 位置，每个寄存器可以存储一个 **10 字节** 的扩展精度浮点数。
  - **栈顶指针**：使用 **栈顶指针** (隐式) 来管理栈的push和pop操作。
  - **循环栈**：当新的数据压入栈时，栈顶指针会移动，栈底的数据会被**覆盖**，类似于循环移位操作。
  - **寄存器命名**：在 **MASM 汇编** 代码中，使用 `ST(0)` 表示**栈顶寄存器**，`ST(1)` ~ `ST(7)` 表示栈中其他寄存器，`ST(1)` 是栈顶的下一个寄存器，以此类推。

##### 8087 常用指令

8087 提供了丰富的指令集，用于执行各种浮点运算和数据操作。以下列举一些常用的 8087 指令：

- **`FADD S1/D, S2` (浮点加法)**：将两个浮点数 `S1` 和 `S2` 相加，结果存储到 `D` 中 (`S1 = D`)。
  - 如果没有指定 `S1` 和 `S2`，则默认操作为 `ST(0) += ST(1)`，即将栈顶元素 `ST(0)` 和次栈顶元素 `ST(1)` 相加，结果覆盖 `ST(0)`，并将栈顶指针减 1。
- **`FSUB S1/D, S2` (浮点减法)**：将 `S1` 减去 `S2`，结果存储到 `D` 中 (`S1 -= S2`)。
- **`FSUBR S1/D, S2` (反向浮点减法)**：将 `S2` 减去 `S1`，结果存储到 `D` 中 (`S1 = S2 - S1`)。
- **`FMUL S1/D, S2` (浮点乘法)**：将 `S1` 和 `S2` 相乘。
- **`FDIV S1/D, S2` (浮点除法)**：将 `S1` 除以 `S2`。
- **`FMULP` (浮点乘法并Pop)**：将栈顶元素 `ST(0)` 和次栈顶元素 `ST(1)` 相乘，结果存储到 `ST(1)`，并将栈顶元素弹出 (栈顶指针减 1)。
- **`FIMUL` (整数浮点乘法)**：将栈顶元素 `ST(0)` 与一个整数相乘。
- **`FDIVR` (反向浮点除法)**：将 `S2` 除以 `S1`。
- **`FDIVP` (浮点除法并Pop)**：将次栈顶元素 `ST(1)` 除以栈顶元素 `ST(0)`，结果存储到 `ST(1)`，并将栈顶元素弹出。
- **`FIDIV` (整数浮点除法)**：将栈顶元素 `ST(0)` 除以一个整数。

---

### Lecture 6: Assembly Language (V)

#### 浮点数计算 —— 毕达哥拉斯问题

<img src="https://s2.loli.net/2025/01/18/yO3klJvp1MThsYD.png" alt="image-20250118下午94629825"  />

使用 FP 处理器  (8087 ) 执行上述计算

```assembly
.8087                                ; 告诉 MASM 协处理器存在
.MODEL medium
.STACK
.DATA

SX dd 5.0                            ; 定义短实数 (4 字节 ), 初始值为 5.0
SY dd 12.0                           ; 定义短实数 (4 字节 ), 初始值为 12.0
HY dd 0.0                            ; 定义短实数 (4 字节 ), 用于存储结果
cntrl dw 03FFh                       ; 定义控制字, 用于设置 8087 协处理器的状态
stat dw 0                            ; 定义状态字, 用于存储 FPU 的状态

.CODE
.STARTUP

FINIT                                ; 初始化 FPU, 将其设置为默认状态
FLDCW cntrl                          ; 加载控制字, 设置舍入模式为偶数, 并屏蔽中断

FLD SX                               ; 将 SX 压入 FPU 栈
FMUL ST, ST(0)                       ; 将栈顶元素与自身相乘, 结果存储在栈顶
FLD SY                               ; 将 SY 压入 FPU 栈
FMUL ST, ST(0)                       ; 将栈顶元素与自身相乘, 结果存储在栈顶
FADD                                 ; 将栈顶的两个数相加
FSQRT                                ; 计算栈顶元素的平方根
FSTSW stat                           ; 将 FPU 的状态字加载到 [stat]
mov ax, stat                         ; 将 [stat] 复制到 AX
and al, 0BFh                         ; 检查所有 6 个状态位
jnz pass                             ; 如果有任何位被设置, 则跳转到 pass
FSTP HY                              ; 将栈顶的结果存储到 HY
jmp print                            ; 跳转到打印函数

print:
    mov bx, OFFSET HY                ; 将 HY 的地址加载到 BX 寄存器
    mov ax, [bx+2]                   ; 将 HY+2 的值加载到 AX 寄存器
    mov cx, 16                       ; 设置循环次数为 16
    call print_num                  
    mov ax, [bx]                     ; 将 HY 的值加载到 AX 寄存器
    mov cx, 16
    call print_num
    jmp pass

print_num:
    push bx                          ; 存储 BX 寄存器
    rol ax, 1                        ; 将 AX 寄存器左移一位
    jc set                           ; 如果 ZF=1 , 则 DL='1'
    mov dl, '0'                      ; DL='0'
    jmp over

set:
    mov dl, '1'

over:
    push ax                          ; 存储 AX 寄存器
    mov ah, 02h
    int 21h
    pop ax                           ; 恢复 AX 寄存器
    loop print_num
    pop bx                           ; 恢复 BX 寄存器
    ret

pass: 
    nop

; 程序结束
mov ah, 4Ch        ; 设置 AH 为 4Ch (DOS 功能调用: 程序退出 )
int 21h

END
```

`HY`在内存中的排列: 

![img](https://s2.loli.net/2025/01/18/UHmLhaO6S5Bqesb.png)

> 汇编的内容终于结束了 ~\(≧▽≦)/~

------

好的，这是根据您的规范重构后的关于半导体的笔记内容：

### Lecture 7: 半导体

#### 能级

##### 原子能级与固体能带的区别

原子和固体的能级结构存在显著差异，理解这些差异有助于认识半导体的特性。

- **原子能级**：
  - **离散能级**：在**原子** (Atom) 中，电子的能量是量子化的，只能占据特定的、**离散的能级**。这些能级对应于电子围绕原子核的不同轨道。
  - **能级结构决定性质**：原子的**能级结构** (Energy Level Structure) 直接决定了原子的化学性质和物理性质，例如原子的光谱特性和化学反应活性。
  - **能带的基础**：原子能级结构是理解固体能带结构的基础，原子能级的变化和相互作用最终形成了固体中的能带。

- **固体能带**：
  - **连续能带**：在**固体** (Solid) 中，由于原子之间的相互作用，原子能级会扩展成**连续的能量带**，称为**能带** (Energy Band)。电子可以在能带内连续地占据不同的能量状态。
  - **电子自由移动**：在固体中，电子不再局限于单个原子，而是在整个固体中相对自由地移动，因此其能量不再是离散的，而是形成能量区间。
  - **能带性质取决于多因素**：**能带的性质** (Band Structure) 取决于多种因素，包括原子间的相互作用强度、晶体结构、化学成分等。

![img](https://s2.loli.net/2025/01/19/m3t47LFRE5oKbPX.png)

##### 能带宽度与材料导电性

能带理论解释了不同材料的导电性差异，主要通过**禁带宽度**来区分**绝缘体**、**导体**和**半导体**。

- **绝缘体 (Insulator)**：
  - **大禁带宽度**：**绝缘体** (Insulator) 具有非常**宽的禁带**，通常**远大于 1eV**。
  - **难导电**：需要**非常大的能量**才能将电子从**价带** (Valence Band) 激发到**导带** (Conduction Band)，因此在通常条件下，绝缘体几乎不导电。

- **导体 (Conductor)**：
  - **无禁带或禁带重叠**：**导体** (Conductor) 的**导带**和**价带**之间**没有禁带**，或者能带发生**重叠**。
  - **易导电**：电子可以自由地在能带间移动，**极小的能量**即可使电子进入导带，因此导体很容易导电。

- **半导体 (Semiconductor)**：
  - **适中禁带宽度**：**半导体** (Semiconductor) 的**禁带宽度适中**，通常在 **1eV 左右**。
  - **导电性可控**：在常温下，半导体的导电性介于导体和绝缘体之间。通过**掺杂**、**光照**、**温度**等外部条件的变化，可以**显著改变半导体的导电性**，这是半导体材料最重要的特性。

![img](https://s2.loli.net/2025/01/19/JuPEMSqH18OAnl6.png)

#### P型硅与N型硅

为了实现半导体的可控导电性，通常需要进行**掺杂**，形成 **P 型半导体** 和 **N 型半导体**。

##### P型硅 (P-type Silicon)

**P 型硅** (P-type Silicon) 是通过**掺杂** **三价元素**（如**硼** (Boron)）到**本征半导体** (Intrinsic Semiconductor) 硅中形成的。

- **掺杂硼**：硼原子最外层有 3 个电子，取代硅晶格中的硅原子后，会**缺少一个电子**，形成一个**空穴** (Hole)。
- **空穴导电**：**空穴**可以被看作是带正电的载流子，在外电场作用下，空穴可以移动，形成**电流**。因此，P 型硅主要依靠**空穴导电**，空穴是 **多数载流子**，电子是 **少数载流子**。

![img](https://s2.loli.net/2025/01/19/p4xkj8gN6bMmHPV.png)

##### N型硅 (N-type Silicon)

**N 型硅** (N-type Silicon) 是通过**掺杂** **五价元素**（如**磷** (Phosphorus)）到本征半导体硅中形成的。

- **掺杂磷**：磷原子最外层有 5 个电子，取代硅晶格中的硅原子后，会**多出一个电子**。这个多余的电子很容易挣脱原子核的束缚，成为**自由电子** (Free Electron)。
- **电子导电**：N 型硅中**自由电子浓度**大大增加，在外电场作用下，自由电子定向移动形成电流。因此，N 型硅主要依靠**电子导电**，电子是 **多数载流子**，空穴是 **少数载流子**。

![img](https://s2.loli.net/2025/01/19/JgZ4YMKTH6GRmku.png)

![img](https://s2.loli.net/2025/01/19/2mHBKhcOuLRwJ8U.png)

#### 二极管

**二极管** (Diode) 是利用 **PN 结** 的单向导电性制成的半导体器件，是电子电路中最基本和重要的元件之一。

##### PN 结的形成

**PN 结** (PN Junction) 形成于 **P 型半导体** 和 **N 型半导体** 的交界面。

- **载流子扩散与复合**：在 P-N 结形成初期，P 区的**空穴**和 N 区的**电子**会自发地向对方**扩散**。在扩散过程中，电子和空穴相遇会发生**复合** (Recombination)，导致**耗尽区** (Depletion Region) 的形成。
- **耗尽区**：**耗尽区**是指在 P-N 结界面附近，由于载流子复合而**几乎没有自由载流子**的区域。耗尽区内存在由 N 区指向 P 区的**内建电场**，阻碍载流子的进一步扩散。
- **势垒**：内建电场形成了**势垒**，阻止电子从 N 区流向 P 区，空穴从 P 区流向 N 区。

![img](https://s2.loli.net/2025/01/19/pmWTBIUyuhcnfQE.png)


##### PN 结的正向偏置

**正向偏置** (Forward Bias) 是指将**外部电源的正极**连接到 **P 区**，**负极**连接到 **N 区**。

- **耗尽区变窄**：正向电压产生的电场方向与内建电场方向相反，**削弱了势垒**，使得**耗尽区变窄**。
- **电流导通**：当正向电压超过一定阈值（**开启电压**或**死区电压**）后，势垒被克服，大量的电子从 N 区注入 P 区，空穴从 P 区注入 N 区，形成**较大的正向电流**，PN 结**导通**。

![img](https://s2.loli.net/2025/01/19/zNbQdSlADr8f5FW.png)

##### PN 结的反向偏置

**反向偏置** (Reverse Bias) 是指将**外部电源的正极**连接到 **N 区**，**负极**连接到 **P 区**。

- **耗尽区变宽**：反向电压产生的电场方向与内建电场方向相同，**增强了势垒**，使得**耗尽区变宽**。
- **电流截止**：势垒进一步增大，阻止了多数载流子的流动。只有少量的**少数载流子**（P 区的电子和 N 区的空穴）在反向电场作用下漂移，形成**很小的反向饱和电流**，PN 结**截止**。理想情况下，反向电流可以忽略不计。

![img](https://s2.loli.net/2025/01/19/KnLS6QTxwrVA4ED.png)

##### PN 结电流方向与导电方向

- **电子流动方向**：在正向偏置时，电子从 **N 型硅 -> P 型硅** 流动。
- **传统电流方向**：**导电方向** (Conventional Current Direction) 与电子流动方向相反，为 **P -> N**。

##### 二极管的伏安特性曲线

**伏安特性曲线** (Current-Voltage Characteristic Curve) 描述了二极管电流随电压变化的规律，体现了二极管的**单向导电性**。

- **正向导通区**：当正向电压超过开启电压后，电流随电压呈**指数增长**。
- **反向截止区**：当施加反向电压时，只有很小的反向饱和电流，电流**接近于零**。
- **击穿区**：当反向电压超过**反向击穿电压**时，反向电流会**急剧增大**，二极管可能损坏。

![img](https://s2.loli.net/2025/01/19/A1KgNmDIkcO52WG.png)

##### 二极管的典型应用

**二极管**因其单向导电性，在电路中有着广泛的应用。

- **整流 (Rectification)**：利用二极管的单向导电性，将**交流电 (AC)** 转换为 **直流电 (DC)**。这是二极管最常见的应用之一，例如在电源电路中，将交流电源转换为电子设备所需的直流电源。
- **电路保护 (Circuit Protection)**：在电路中**反向并联**二极管，可以**限制电压**，**防止过电压**或**极性错误**对敏感元件的损坏。例如，在继电器线圈两端反向并联二极管，可以吸收断电时产生的反向感应电动势，保护开关器件。
- **逻辑电路 (Logic Circuits)**：可以利用二极管的开关特性，搭建各种**逻辑门电路**，例如**与门**、**或门**等。早期的计算机中曾使用二极管逻辑门，但由于体积大、功耗高等缺点，已被晶体管逻辑门取代。

---

### Lecture 8: 晶体管与场效应管

#### 结型晶体管 (BJT)

##### 结型晶体管的结构与原理

**结型晶体管 (Bipolar Junction Transistor, BJT)**，俗称**三极管**，是一种**电流控制电流**型的半导体器件，常用于放大和开关电路中。NPN 型晶体管是最常见的 BJT 类型之一，它由三个区域构成：

- **发射极 (Emitter, E)**：晶体管的**电流注入区**，多数载流子由此注入。
- **基极 (Base, B)**：晶体管的**控制区**，通过**基极电流**控制**集电极电流**。
- **集电极 (Collector, C)**：晶体管的**电流收集区**，收集由发射极注入并受基极控制的载流子。

BJT 的工作原理可以类比为一个**小阀门**：

- **输入控制**：**基极电流 (I<sub>B</sub>)** 作为输入信号，是一个较小的电流。
- **输出放大**：**集电极电流 (I<sub>C</sub>)** 作为输出信号，是一个被放大的较大电流。

![img](https://s2.loli.net/2025/01/19/xFAEpb9w8lIi2jU.png)

##### 结型晶体管的电流增益

**电流增益 (Current Gain)** 是衡量 BJT 放大能力的重要参数，通常用符号 **β** (贝塔) 或 **h<sub>FE</sub>** 表示。它定义为**集电极电流 (I<sub>C</sub>)** 与 **基极电流 (I<sub>B</sub>)** 之比：

$\beta = \frac{I_C}{I_B}$

公式中：

- **I<sub>C</sub> (集电极电流)**：**输出电流**，流经集电极的电流。
- **I<sub>B</sub> (基极电流)**：**输入电流**，流经基极的电流。
- **β (电流增益)**：**电流放大倍数**，无量纲参数，典型 BJT 的 β 值范围为 **20 到 200**，甚至更高。

**电流增益的计算示例**：

假设：

- 基极电流 I<sub>B</sub> = 1 mA (毫安)
- 电流增益 β = 100

则集电极电流 I<sub>C</sub> 为：

$I_C = \beta \times I_B = 100 \times 1 \text{ mA} = 100 \text{ mA}$

**结论**：**1 mA 的输入基极电流** 可以控制 **100 mA 的输出集电极电流**，实现了电流的放大，体现了电流增益的作用。

##### 基于BJT的或非门 (NOR Gate) 实现

**或非门 (NOR Gate)** 是一种基本的**逻辑门**，其输出为**低电平**，当且仅当**所有输入均为低电平**时；否则输出为**高电平**。使用 NPN 型晶体管可以构建 NOR 门电路。

**电路原理**：

- **输入端 (A, B)**：分别连接两个输入信号 I<sub>A</sub> 和 I<sub>B</sub>。
- **输出端 (Output)**：电路的输出信号。
- **晶体管 (T)**：NPN 型晶体管作为核心开关元件。
- **电阻 (R)**：限制电流和提供合适的偏置。

**工作原理**：

- **输入均为低电平 (I<sub>A</sub> = I<sub>B</sub> = 0)**：
  - 此时，基极电流为零，晶体管 **T 处于截止状态**，相当于一个**大电阻**。
  - 电流无法通过晶体管流向 **发射极 (I<sub>E</sub>)**，只能流向 **输出端 (Output)**，因此 **输出为高电平**。
- **输入至少有一个高电平 (I<sub>A</sub> + I<sub>B</sub> ≠ 0)**：
  - 此时，至少有一个基极电流不为零，晶体管 **T 处于导通状态**，相当于一个**小电阻**。
  - 电流主要流经晶体管 **T 到发射极 (I<sub>E</sub>)**，**输出端 (Output) 被短路到地**，因此 **输出为低电平**。

![img](https://s2.loli.net/2025/01/19/ZjXD8wz2sflk1mQ.png)

#### 金属氧化物半导体场效应晶体管 (MOSFET)

**金属氧化物半导体场效应晶体管 (Metal-Oxide-Semiconductor Field-Effect Transistor, MOSFET)** 是一种**电压控制电流**型的半导体器件，相比 BJT，MOSFET 具有**输入阻抗高**、**功耗低**等优点，被广泛应用于**集成电路**中。

##### MOSFET 的基本结构

MOSFET 主要由以下几个部分构成：

- **栅极 (Gate, G)**：通常为**金属层**或**多晶硅层**，通过一层**绝缘层**（通常是**二氧化硅 (SiO<sub>2</sub>)**）与半导体衬底隔离。栅极电压用于控制沟道的导电性。
- **源极 (Source, S)**：**电流的注入端**，载流子由此进入沟道。
- **漏极 (Drain, D)**：**电流的输出端**，载流子由此离开沟道。
- **衬底 (Body/Substrate, B)**：**半导体基体**，通常是**硅材料**。衬底的电位通常与**源极**或**漏极**相连，在某些 MOSFET 中，衬底也可以作为独立的控制端。

![img](https://s2.loli.net/2025/01/19/CvHbphekSDg5JRy.png)

##### NMOS 场效应晶体管的工作原理

以 **N 沟道 MOSFET (NMOS)** 为例，说明 MOSFET 的工作原理。

**工作原理**：

1. **未施加栅极电压 (V<sub>G</sub> = 0)**：
   - 在栅极下方的 **P 型衬底** 中，存在少量**自由电子** (少数载流子) 和大量**空穴** (多数载流子)。
   - 由于没有栅极电压的吸引，自由电子分布稀少，**源极 (S)** 和 **漏极 (D)** 之间**无法形成导电沟道**，器件**截止**。

2. **施加正向栅极电压 (V<sub>G</sub> > 0)**：
   - **电子积累**：正向栅极电压会在栅极下方的 P 型衬底表面**吸引大量的自由电子**。
   - **空穴耗尽**：同时，正向栅极电压会**排斥空穴**，导致栅极下方的空穴浓度降低，形成**耗尽层**。
   - **N 沟道形成**：当栅极电压达到一定阈值后，栅极下方的自由电子**积累到足够多**，在源极和漏极之间形成一条**N 型导电沟道**，称为 **N 沟道 (N-channel)**。
   - **电流导通**：一旦 N 沟道形成，在 **漏极电压 (V<sub>D</sub>)** 的作用下，电子可以从**源极 (S)** 经 **N 沟道** 流向 **漏极 (D)**，形成**漏极电流 (I<sub>D</sub>)**，器件**导通**。

![img](https://s2.loli.net/2025/01/19/H4j15LMIwV6UeWT.png)

> [!NOTE]
>
> MOSFET 的工作原理较为抽象，建议参考[视频讲解](https://www.bilibili.com/video/BV1nL411x7jH/) 以更直观地理解。

#### 互补金属氧化物半导体 (CMOS)

**互补金属氧化物半导体 (Complementary Metal-Oxide-Semiconductor, CMOS)** 电路是现代数字电路中最主流的电路形式。CMOS 电路利用 **PMOS (P 沟道 MOSFET)** 和 **NMOS (N 沟道 MOSFET)** 的互补特性，实现低功耗、高性能的逻辑功能。

##### CMOS 反相器的工作原理

**CMOS 反相器 (Inverter)** 是 CMOS 电路中最基本的逻辑门，它由一个 **PMOS 管** 和一个 **NMOS 管** 串联组成。

**工作原理**：

- **输入高电平**：
  - 当 **输入端 (Input)** 为**高电平**时，**NMOS 管导通**，**PMOS 管截止**。
  - 电路相当于 **输出端 (Output) 通过导通的 NMOS 管接地**，因此 **输出为低电平**。

- **输入低电平**：
  - 当 **输入端 (Input)** 为**低电平**时，**PMOS 管导通**，**NMOS 管截止**。
  - 电路相当于 **输出端 (Output) 通过导通的 PMOS 管连接到电源 (V<sub>DD</sub>)**，因此 **输出为高电平**。

**总结**：CMOS 反相器实现了**输入与输出电平的反转**，是构成更复杂 CMOS 逻辑门的基础。

![img](https://s2.loli.net/2025/01/19/xBEcbQXG4RDseWP.png)

---
### Lecture 9: Digital I/O

#### I/O 基础

##### I/O 操作与地址空间

**I/O (Input/Output)** 操作是计算机系统中 **CPU (中央处理器)** 与外部设备进行数据交换的关键方式。8086 微处理器架构中，I/O 操作的设计特点包括：

- **独立的 I/O 地址空间**：
  - 8086 使用 **20 位地址总线** 用于内存读写，但为 **I/O** 操作划分了 **16 位的 I/O 地址空间**。
  - 这种分离设计允许系统区分**内存访问**和 **I/O 访问**，通过额外的**控制线**进行选择。
- **端口 (Port)** 的概念：
  - **I/O 空间**中的每个位置都被称为 **端口 (Port)**。端口是 CPU 与外部设备通信的接口。
  - 8086 的 16 位 I/O 地址空间，可以映射为 **64K 的 8 位端口 (字节)** 或 **32K 的 16 位端口 (字)**。
- **指令集差异**：
  - 相较于内存控制，用于控制 **I/O 端口** 的汇编指令数量相对较少，体现了 I/O 操作的简洁性。
- **内存映射 I/O**：
  -  值得注意的是，某些硬件设备，例如**屏幕显示**，可能被**映射到内存空间**，而不是传统的 I/O 空间。这种技术称为 **内存映射 I/O (Memory-mapped I/O)**。

##### 常见 I/O 地址示例

下表列出了一些 **常见 I/O 地址** 及其用途，这些地址在早期的 **IBM PC 兼容机** 中被广泛使用，用于控制各种外围设备：

| 地址    | 名称                     | 方向 | 用途                                                                                             |
| :------ | :----------------------- | :--- | :----------------------------------------------------------------------------------------------- |
| **0x378** | Parallel Printer Latch   | 输出 | **并行打印机数据端口**，常用于 **LPT1 (Line Printer 1)**，向打印机发送打印数据。                |
| **0x37A** | Printer Control Latch    | 输出 | **并行打印机控制端口**，常用于 **LPT1**，控制打印机的各种操作，例如初始化、选择打印机等。   |
| **0x379** | Printer Status           | 输入 | **并行打印机状态端口**，常用于 **LPT1**，读取打印机的状态信息，例如是否忙碌、是否有纸等。 |
| **0x3D9** | VDU Colour Register      | 输出 | **视频显示单元 (VDU) 颜色寄存器**，用于设置 **DOS 文本模式** 下的边框颜色。                   |
| **0x278** | Parallel Printer Latch   | 输出 | **并行打印机数据端口**，常用于 **LPT2 (Line Printer 2)**，向打印机发送打印数据。                |

##### 总线共享与内存访问周期

- **总线复用**：由于 8086 处理器硬件引脚数量的限制，**内存地址总线** 和 **数据总线** 实际上是**共享相同的物理引脚**。
- **控制线区分**：因此，需要额外的**控制线**来区分当前的总线操作是**内存访问**还是 **I/O 数据传输**。
- **内存访问时序**：8086 完成一次**内存访问周期** 通常需要 **4 个时钟周期**， 步骤如下：
    1. **周期 1**：CPU 发送**内存地址**到地址总线上。
    2. **周期 2-3**：CPU **等待内存响应**，并进行**数据传输**（读取或写入）。
    3. **周期 4**：**结束周期**，完成本次内存访问。

#### Z80A CPU 架构对比

##### 分离总线设计

与 8086 的总线复用设计不同，**Z80A CPU** 的 **数据总线** 和 **地址总线** 采用了**分离的设计**，拥有独立的引脚，简化了总线控制逻辑，并可能提升总线操作的效率。

![img](https://s2.loli.net/2025/01/19/PXrtv54x8d3UAD2.png)

##### 基于 AND 门的地址解码器

为了实现**地址解码**，Z80A 系统中使用了 **AND 门** 作为**地址解码器 (Address Decoder)**。

- **地址匹配**：当 **16 个输入信号** 与预设的**设备地址** 完全匹配时，AND 门输出**逻辑真 (高电平)**，否则输出**逻辑假 (低电平)**。
- **控制线**：系统使用**两根控制线**（图中绿色和紫色线条）来指示当前操作是**读取**还是**写入**，以及针对哪个设备。

![img](https://s2.loli.net/2025/01/19/oKC2ryEbsckfAG1.jpg)

##### 三态缓冲器与数据传输控制

**三态缓冲器 (Tri-state Buffer)** 在 I/O 接口中扮演着重要的角色，用于控制数据流的方向和连接状态。

- **控制信号**：**AND 门** 的输出（地址匹配结果）和**两根控制线** 的信号，通过另一个 **AND 门** 组合成**最终的控制信号**。
- **三态输出**：**三态缓冲器** 具有三种输出状态：**高电平 (1)**, **低电平 (0)**, 和 **高阻态 (High-Z)**。
  - 根据 **控制信号** 的状态，三态缓冲器决定是否将 **输入信号** 直接**传输到输出**，或者**切换到高阻态**，相当于断开连接。

![img](https://s2.loli.net/2023/05/23/QC4m9yvVDl1XNYr.png)

对于**输出操作**，三态缓冲器会被 **D 触发器 (D Flip-Flop)** 替代，用于锁存输出数据。

![img](https://s2.loli.net/2025/01/19/5QW1Opjd7wDyT6U.jpg)

#### 汇编语言 I/O 指令

##### OUT 指令：端口输出

**OUT 指令** 用于将数据从 **CPU 寄存器** （通常是累加器 `AL`, `AX`, `EAX`） **写入** 到指定的 **I/O 端口**。

```assembly
OUT port, acc
```

- **port**:  **I/O 端口地址**，可以是立即数或存储在 DX 寄存器中。
- **acc**: **累加器** (`AL`, `AX`, 或 `EAX`)，存储着要**输出的数据**。

**OUT 指令的两种寻址模式**：

1.  **立即数模式 (Immediate Mode)**：
    - **端口地址** 直接在指令中指定为 **立即数 (0-255)**。
    - **寻址范围限制**： 这种模式**只能访问 256 个端口** (地址范围 00h-FFh)。

    ```assembly
    OUT 30h, AL  ; 将 AL 寄存器中的 8 位数据写入端口地址 30h
    ```

2.  **DX 寄存器模式 (Register Mode)**：
    - **端口地址** 存储在 **DX 寄存器** 中。
    - **寻址范围扩展**： 这种模式可以访问 **64K 个端口 (0-65535)**，提供了更大的 I/O 空间访问能力。

    ```assembly
    mov dx, 0x378 ; 将端口地址 0x378 放入 DX 寄存器
    OUT DX, AX    ; 将 AX 寄存器中的 16 位数据写入 DX 寄存器指定的端口
    ```

##### IN 指令：端口输入

**IN 指令** 用于从指定的 **I/O 端口** **读取数据** 到 **CPU 寄存器** （通常是累加器 `AL`, `AX`, `EAX`）。

```assembly
IN acc, port
```

- **acc**: **累加器** (`AL`, `AX`, 或 `EAX`)，用于**存储从端口读取的数据**。
- **port**: **I/O 端口地址**，可以是立即数或存储在 DX 寄存器中。

**IN 指令的两种寻址模式**：

1.  **立即数模式 (Immediate Mode)**：
    - **端口地址** 直接在指令中指定为 **立即数 (0-255)**。
    - **寻址范围限制**： 这种模式**只能访问 256 个端口** (地址范围 00h-FFh)。

    ```assembly
    IN AL, 30h  ; 从端口地址 30h 读取 8 位数据，存储到 AL 寄存器
    ```

2.  **DX 寄存器模式 (Register Mode)**：
    - **端口地址** 存储在 **DX 寄存器** 中。
    - **寻址范围扩展**： 这种模式可以访问 **64K 个端口 (0-65535)**，提供了更大的 I/O 空间访问能力。

    ```assembly
    mov dx, 0x379 ; 将端口地址 0x379 放入 DX 寄存器
    IN AX, DX    ; 从 DX 寄存器指定的端口读取 16 位数据，存储到 AX 寄存器
    ```

> [!NOTE] I/O 特权级 (IOPL)
>
> **IOPL (I/O Privilege Level, I/O 特权级)** 是 **x86 架构** 中用于控制 **I/O 端口访问权限** 的保护机制。它存储在 **EFLAGS 寄存器** 的 **第 12 和 13 位**，定义了程序执行 **I/O 指令** （如 `IN`, `OUT`）所需的**最低特权级别 (CPL, Current Privilege Level)**。
>
> **IOPL** 是一个 **2 位** 的值，取值范围为 **0 到 3**，数值越小特权级别越高：
>
> - **特权级检查**：在执行 I/O 指令时，CPU 会**比较当前程序**的 **CPL** 和 **IOPL**。
>   - **当 CPL ≤ IOPL 时**：程序**被允许**直接执行 I/O 指令 （如 `IN`, `OUT`），可以访问 I/O 端口。
>   - **当 CPL > IOPL 时**：程序**没有权限**直接执行 I/O 指令。如果尝试执行，会触发 **一般保护异常 (General Protection Fault, #GP)**，导致程序终止或系统崩溃。
>
> **作用**：IOPL 机制增强了系统的**安全性**和**稳定性**，防止低特权级别的程序非法访问硬件设备，保护系统资源。

#### 中断机制

##### 中断的引入与优势

**中断 (Interrupt)** 是一种重要的**异步事件处理机制**，允许外部设备或软件事件**打断 CPU 的正常执行流程**，转而处理更紧急或重要的任务。

**应用场景**：考虑 CPU 从 **HDD (硬盘驱动器)** 读取数据的场景。

- **传统轮询方式的低效**：若 CPU 采用**轮询 (Polling)** 方式，需要**周期性地查询 HDD** 的状态，等待数据就绪。 **HDD 响应速度**通常较慢（例如**毫秒级**，涉及磁头移动和盘片旋转），CPU 在等待期间会**空耗大量的计算资源**。
- **中断机制的优势**：**中断机制** 提供了更高效的方案。
    - **设备主动通知**：当 HDD **数据就绪**时，**主动向 CPU 发送中断信号**。
    - **CPU 响应**：CPU 接收到中断信号后，**暂停当前任务**，**转而处理数据读取操作**。
    - **资源高效利用**：CPU 在 HDD 准备数据的期间，可以**执行其他任务**，**避免了无谓的等待**，提高了系统资源的利用率。
    - **低功耗**：CPU 可以进入**低功耗模式**等待中断，进一步降低能耗。

##### 中断处理流程

**中断发生时的典型处理流程**：

1. **暂停当前程序**：CPU **暂停** 当前正在执行的**主程序**。
2. **调用中断处理程序**：CPU **跳转** 到一个专门**服务中断的程序**，称为 **中断处理程序 (Interrupt Handler)** 或 **中断服务例程 (ISR, Interrupt Service Routine)**。
3. **返回主程序**：**中断处理程序执行完毕**后，**将控制权返回** 到之前被中断的**主程序**，从断点处继续执行。

##### 8086 的中断类型

8086 架构支持多种类型的中断，可以根据**触发来源**进行分类：

- **硬件中断 (Hardware Interrupt)**：
  - 由**外部硬件设备**通过**处理器的引脚**发出中断请求信号。
    - **INTR (Interrupt Request)** 引脚：**可屏蔽中断**，可以通过设置**中断标志位 (IF)** 来**屏蔽**或**使能**。
    - **NMI (Non-Maskable Interrupt)** 引脚：**非可屏蔽中断**，**优先级高于 INTR**，通常用于处理**更紧急的硬件错误**，如电源故障或内存奇偶校验错误。
- **异常中断 (Exception Interrupt)**：
  - 由 **CPU 内部错误** 或**异常条件**触发。
  - 常见的异常包括：**除以零错误**、**非法操作码**、**页错误** 等。
  - **用途**：通常用于**打印错误信息**、**终止程序** 或进行**错误恢复**。
- **软件中断 (Software Interrupt)**：
  - 由程序**主动执行汇编指令 `INT`** 引起。
  - **指令格式**：`INT n`，其中 `n` 为**中断号** (0-255)。
  - **用途**：一种**软件请求操作系统服务**的机制，例如 **DOS 系统调用** 就是通过**软件中断** 实现的。可以理解为 **调用 BIOS (基本输入/输出系统) 中的函数**。

##### 时间片轮询调度 vs 抢占式调度

**中断机制** 在操作系统中被广泛用于实现**任务调度**，两种典型的调度方式是 **时间片轮询调度** 和 **抢占式调度**。

- **时间片轮询调度 (Time Slice Scheduling)**：
  - **轮流执行**：操作系统将 **CPU 时间** 划分为**固定长度的时间片**（例如 20ms）。
  - **任务切换**：操作系统**轮流** 为每个**就绪任务**分配一个时间片，**顺序执行**。当时间片用完，即使任务未完成，也**强制切换**到下一个任务。
  - **硬件轮询**：CPU 通常需要**主动轮询硬件设备** 的状态，以确定是否有 I/O 请求需要处理。
  - **适用场景**：适用于 **简单的多任务系统**。
  - **缺点**：可能存在**资源浪费**，实时性较差。

- **抢占式调度 (Pre-emptive Scheduling)**：
  - **优先级抢占**：操作系统为每个任务分配**优先级**。**高优先级任务** 可以**中断** 正在执行的**低优先级任务**，**优先获得 CPU 执行权**。
  - **中断驱动**：**硬件设备** 通过**中断** 通知 CPU **I/O 事件** 的发生。
  - **快速响应**：CPU **响应中断** 速度快，能够及时处理外部事件。
  - **适用场景**：适用于 **实时性要求高** 的系统，例如 **实时操作系统 (RTOS)**。
  - **优点**：**实时性好**，**响应速度快**，**资源利用率高**。

##### 中断优先级

**中断优先级 (Interrupt Priority)** 用于**区分不同中断请求的重要性**。在多中断源的系统中，当**多个中断同时发生**时，**优先级较高的中断** 会被**优先处理**。

- **中断嵌套**：**中断服务例程 (ISR)** 可以**嵌套执行**，即在执行一个 ISR 的过程中，可以被**更高优先级的中断** 再次**中断**。
- **优先级编码**：通常使用**中断号** 或 **优先级编码** 来表示中断的优先级。
  - **编号越小的 ISR，优先级越高**。例如，在某些系统中，**硬件中断** 的优先级通常**高于软件中断**，**NMI** 的优先级**高于 INTR**。
- **优先级管理**：**中断控制器** （如 8259A）负责**管理中断优先级**，**仲裁** 中断请求，并**决定** 哪个中断应该被**优先响应**。

#### 中断向量表 (IVT)

**中断向量表 (Interrupt Vector Table, IVT)** 是计算机系统中**管理和处理中断** 的核心数据结构。

- **作用**：**存储中断服务例程 (ISR) 的入口地址**。当**中断发生**时，**CPU** 会根据**中断号** 在 **中断向量表** 中**查找** 相应的 **入口地址**，然后 **跳转到该地址** 执行 **中断处理程序**。
- **存储位置**：**中断向量表** 通常位于 **RAM (随机访问存储器)** 的 **起始地址** 区域，即 **前 1024 字节** （地址范围：**0000:0000 到 0000:03FF**）。
- **条目结构**：**每个中断向量** 在中断向量表中占用 **4 个字节**。
    - **前 2 个字节**：存储 **指令指针 (IP, Instruction Pointer)**，即 **ISR 代码段内的偏移地址**。
    - **后 2 个字节**：存储 **代码段选择器 (CS, Code Segment)**，即 **ISR 代码所在的段地址**。
- **地址计算**：对于给定的**中断号 `n`**，其在中断向量表中的起始地址可以通过以下公式计算：

  `中断向量地址 = 中断号 * 4`

  例如，假设 **中断号为 `0x21` (十进制 33)**：

  - **中断向量表位置**：`0x0000:0084` (`0x21 * 4 = 0x84`)
  - **入口地址解析**：如果 `0x0084` 处存储的值为 `0x1234:0x5678`，则表示 **中断处理程序的入口地址** 为 **代码段 `0x1234`，偏移地址 `0x5678`**。CPU 将跳转到 **物理地址 `0x1234 * 16 + 0x5678`** 处开始执行 ISR 代码。

**中断向量表结构示意图**

![img](https://s2.loli.net/2025/01/20/TXYK9F5cGUJI2a1.jpg)

#### 中断控制器 8259A

##### 8259A 的功能与连接

**8259A 可编程中断控制器 (Programmable Interrupt Controller, PIC)** 是一种常用的**硬件中断管理芯片**，用于**扩展 CPU 的中断处理能力**，**管理多个中断源**，并实现**中断优先级控制**。

- **中断请求处理**：当**外部设备** 的 **IRQ (Interrupt Request)** 线被**触发**（发出中断请求信号）时，**8259A** 会**接收** 这些中断请求，进行**优先级仲裁**，并将**最高优先级的中断请求** **转发给 CPU**。
- **中断号传输**：**中断编号** 会通过 **PC 总线** 传输给 CPU，作为**中断向量索引**。
- **中断向量表查找**：**CPU** 接收到中断号后，会在 **中断向量表 (IVT)** 中**查找** 对应的 **中断服务例程 (ISR) 入口地址**。
- **跳转执行 ISR**：CPU **跳转到 ISR 入口地址**，开始执行 **中断处理程序**。

##### 8259A 级联结构

在 **IBM PC** 架构中，通常使用 **两个 8259A 芯片** **级联** 构成**中断系统**，以**支持更多的中断源**。

- **主芯片 (8259A #1)**：
  - 负责处理 **IRQ0 ~ IRQ7** **共 8 个** 中断请求。
  - **基地址** 通常设置为 **20H**。
- **从芯片 (8259A #2)**：
  - 负责处理 **IRQ8 ~ IRQ15** **共 8 个** 中断请求。
  - **基地址** 通常设置为 **A0H**。
  - **级联连接**：**从芯片** 通过 **IRQ2 引脚** 连接到 **主芯片 (8259A #1)** 的 **IRQ2 输入**，实现级联。

**8259A 中断系统连接示意图**

![img](https://s2.loli.net/2025/01/20/6EnZtBbpJmSFOA7.png)

##### IRQ 与中断向量的映射关系

**8259A** 将 **硬件中断请求 (IRQ)** 信号 **映射** 到 **中断向量 (INT)** 号，从而与 **中断向量表 (IVT)** 关联起来。

- **8259A #1 (主芯片) 的映射**：
  - **IRQ0** 映射到 **INT 08H** (中断向量号 0x08)
  - **IRQ1** 映射到 **INT 09H** (中断向量号 0x09)
  - ...
  - **IRQ7** 映射到 **INT 0FH** (中断向量号 0x0F)
- **8259A #2 (从芯片) 的映射**：
  - **IRQ8** 映射到 **INT 70H** (中断向量号 0x70)
  - **IRQ9** 映射到 **INT 71H** (中断向量号 0x71)
  - ...
  - **IRQ15** 映射到 **INT 77H** (中断向量号 0x77)

**IRQ 与中断向量映射表**

| IRQ | 中断向量 (十六进制) | 描述                       |
| --- | -------------------- | -------------------------- |
| 0   | 0x08                 | **定时器节拍 (Timer Tick)**  |
| 1   | 0x09                 | **键盘 (Keyboard)**          |
| 2   | 0x0A                 | **辅助 8259A (Second 8259A)** |
| 3   | 0x0B                 | **COM2 (串行端口 2)**        |
| 4   | 0x0C                 | **COM1 (串行端口 1)**        |
| 5   | 0x0D                 | **声卡 / LPT2**              |
| 6   | 0x0E                 | **软盘驱动器控制器**         |
| 7   | 0x0F                 | **LPT1 (并行端口)**          |
| 8   | 0x70                 | **实时时钟 (RTC)**           |
| 9   | 0x71                 | **可用 (传统: IRQ2)**        |
| 10  | 0x72                 | **可用**                     |
| 11  | 0x73                 | **可用**                     |
| 12  | 0x74                 | **PS/2 鼠标**                |
| 13  | 0x75                 | **数学协处理器**             |
| 14  | 0x76                 | **主 IDE 控制器**            |
| 15  | 0x77                 | **辅助 IDE 控制器**          |

> [!NOTE]
>
> **中断向量 INT 0-7**  **不由 8259A 控制**，而是**直接** 由 **CPU 硬件** 或 **BIOS** 预留和使用，通常用于处理 **CPU 异常** 和 **早期的硬件中断**，例如：
>
> - **INT 0**: 除法错误异常
> - **INT 1**: 单步中断 (调试)
> - **INT 2**: NMI (非可屏蔽中断)
> - **INT 3**: 断点中断
> - **INT 4**: 溢出中断

#### CPU 中断处理流程详解

**CPU 处理硬件中断请求的详细步骤**：

1.  **中断触发 (Interrupt Trigger)**：
    - **外部设备** 或 **内部异常** 产生**中断请求 (IRQ)**。
    - **中断信号** 通过 **中断线** 发送到 **CPU** 或 **中断控制器 (如 8259A)**。

2.  **中断响应 (Interrupt Acknowledge)**：
    - **CPU** 在**完成当前指令的执行后**，**检测** 到 **中断请求**。
    - 如果**中断允许**（**中断标志位 IF=1**，且**非屏蔽中断**），CPU 发出 **中断响应信号 (INTA, Interrupt Acknowledge)**。

3.  **保存现场 (Save Context)**：
    - **CPU** 自动将 **当前程序的状态** **压入堆栈 (Stack)** 保存，以便在中断处理完成后**恢复执行**。
    - **保存内容** 通常包括：
        - **程序计数器 (PC, Program Counter) / 指令指针 (IP, Instruction Pointer)**：指向**下一条要执行的指令地址**，用于记录中断发生时的程序执行位置。
        - **标志寄存器 (FLAGS)**：保存 **状态标志位** 和 **控制标志位** 的值，如 **进位标志 CF**、**零标志 ZF**、**中断使能标志 IF** 等。

4.  **获取中断向量 (Get Interrupt Vector)**：
    - **CPU** 从 **中断控制器 (如 8259A)** **读取** 或 **直接接收** **中断号** (或称为 **中断向量号**)。
    - **根据中断号** 在 **中断向量表 (IVT)** 中**查找** 对应的 **中断服务例程 (ISR) 入口地址**（代码段地址 CS 和偏移地址 IP）。

5.  **跳转到 ISR (Jump to ISR)**：
    - **CPU** **加载** 从中断向量表读取的 **ISR 入口地址 (CS:IP)** 到 **代码段寄存器 CS** 和 **指令指针寄存器 IP**。
    - **程序控制权** **转移** 到 **中断服务例程 (ISR) 的起始地址**，开始执行 ISR 代码。

6.  **执行中断处理 (Execute ISR)**：
    - **CPU** **执行** **中断服务例程 (ISR)** 代码，完成**特定设备** 或 **异常** 的具体**处理逻辑**。
    - **ISR 代码** 负责：
        - **识别中断源** (如果需要)。
        - **读取** 或 **写入** **I/O 端口**，与设备进行数据交换。
        - **清除中断状态**，**复位设备** (如果需要)。
        - **发送中断结束命令 (EOI)** 给中断控制器 (对于 8259A 等可编程中断控制器)。

7.  **恢复现场 (Restore Context)**：
    - **中断处理完成** 后，**ISR 代码** 通常会执行 **`IRET` (中断返回)** 指令。
    - **`IRET` 指令** 会从 **堆栈 (Stack)** 中 **弹出** 之前 **保存的程序状态** (包括 **FLAGS** 和 **CS:IP**)。
    - **CPU 寄存器** 和 **程序状态** **恢复** 到 **中断发生前的状态**。

8.  **返回原程序 (Return to Original Program)**：
    - **CPU** **恢复执行** 被中断的 **原程序**，从 **断点处** （即 **中断发生时 PC 指向的地址**） **继续运行**。

#### 8259A 操作命令：中断屏蔽

**中断屏蔽寄存器 (IMR, Interrupt Mask Register)** 是 **8259A 可编程中断控制器 (PIC)** 的一个重要寄存器，用于**控制** 哪些 **中断请求 (IRQ)**  **被允许** 或 **禁止** (屏蔽)。

- **端口地址**：**中断屏蔽寄存器 (IMR)** 的端口地址通常为 **21H** (对于主 8259A 芯片)。
- **位屏蔽**：**IMR** 是一个 **8 位寄存器**，**每一位** 对应一个 **IRQ 输入线** (IRQ0 - IRQ7)。
  - **位值为 1**：**屏蔽** 对应的 **IRQ 中断请求**，即 **禁止** 该中断被 8259A 传递给 CPU。
  - **位值为 0**：**允许** 对应的 **IRQ 中断请求**，即 **使能** 该中断可以被 8259A 传递给 CPU。

**设置中断屏蔽的汇编代码示例**：

以下代码示例演示了如何通过设置 **IMR** 来**屏蔽 IRQ 7, IRQ 3 和 IRQ 1 中断**。

```assembly
mov al, 137     ; 十进制 137, 十六进制 89H
                ; 二进制 10001001B
                ; 位 7, 3, 0 设置为 1，对应屏蔽 IRQ7, IRQ3, IRQ1
mov dx, 21h     ; 中断屏蔽寄存器 (IMR) 的端口地址 (主 8259A)
out dx, AL      ; 将屏蔽值写入 IMR 寄存器
```

**屏蔽值 137 (89H) 的二进制表示 10001001B 的含义**：

![img](https://s2.loli.net/2025/01/20/iEPpwNxROh4GHc6.png)

- **位 7 (最高位)**：设置为 **1**，**屏蔽 IRQ7**。
- **位 6 - 位 4**：设置为 **0**，**允许 IRQ6, IRQ5, IRQ4**。
- **位 3**：设置为 **1**，**屏蔽 IRQ3**。
- **位 2**：设置为 **0**，**允许 IRQ2**。
- **位 1**：设置为 **1**，**屏蔽 IRQ1**。
- **位 0 (最低位)**：设置为 **0**，**允许 IRQ0**。

#### 中断结束命令 (EOI)

**中断结束 (End of Interrupt, EOI)** 命令是 **8259A 可编程中断控制器 (PIC)** 中用于**通知控制器**  **中断处理程序 (ISR) 已经完成**，可以**重新接受新的中断请求** 的命令。

- **非特定 EOI (Non-Specific EOI)**：
  - **命令字**：通常为 **20H**。
  - **端口地址**：**命令端口** 地址通常为 **20H** (对于主 8259A 芯片)。
  - **用途**：**最常用的 EOI 命令**。通知 8259A **当前正在处理的中断已经结束**，可以**清除** 8259A 内部的**中断请求状态**，并**允许处理新的中断请求**。
  - **优先级管理**：**非特定 EOI** 会让 8259A **自动** 将**优先级最低的正在服务的中断** 标记为结束。

**发送非特定 EOI 命令的汇编代码示例**：

```assembly
EOI_command:
    mov al, 20h     ; EOI 命令字 (非特定 EOI)
    out 20h, al     ; 发送到 8259A 的主控制器命令端口 (20H)
```

> [!NOTE]
>
> **何时发送 EOI 命令**：
>
> - **在中断服务例程 (ISR) 的末尾**，**`IRET` (中断返回) 指令之前**，**必须发送 EOI 命令** 给中断控制器。
> - **目的**：
>   - **通知 8259A** 中断处理已完成。
>   - **重置** 8259A 的内部状态，**准备** 接收和处理**新的中断请求**。
>   - 如果**忘记发送 EOI 命令**，**8259A** 可能**无法正确响应后续的中断请求**，导致系统功能异常。

#### 自定义中断服务例程 (ISR)

**自定义中断服务例程 (ISR)** 是指**程序员** **自己编写** 的 **中断处理程序**，用于**替换** 系统默认的 **ISR**，以实现特定的中断处理逻辑。

- **应用场景**：
  - **硬件驱动程序**：为特定的硬件设备编写 ISR，处理设备发出的中断请求，实现设备的数据传输、控制等功能。
  - **实时系统**：在实时系统中，需要编写定制化的 ISR，以满足系统对中断响应时间、处理逻辑的特定需求。
  - **系统功能扩展**：通过自定义 ISR，可以扩展系统的功能，例如实现**自定义的定时器**、**热键检测** 等。

**自定义定时器 ISR 的示例**：

**INT 08H (定时器中断)** 是 **IBM PC 架构** 中由 **系统定时器** 周期性触发的 **硬件中断**，**默认情况下**，**INT 08H** 的 **ISR**  通常用于**更新系统时间** 等操作。

- **自定义 ISR 替换**：程序员可以**编写自己的 ISR 代码**，**替换** 原有的 **INT 08H** 中断处理程序，从而实现**自定义的定时器功能**。
- **周期性执行**：由于 **INT 08H**  大约每 **50ms** 左右 **自动执行一次**，因此可以利用它来实现**周期性的任务**，例如 **计时器**、**实时数据采集**、**周期性系统监控** 等。

#### 直接访问屏幕内存 (VRAM)

**直接访问屏幕内存** 是一种**高效的屏幕显示技术**，允许程序**直接** **读写** **视频 RAM (Video RAM, VRAM)**，从而**快速** **控制屏幕显示内容**。

- **DOS 文本模式**：在 **DOS 文本模式** 下，**屏幕内存** 的起始地址通常为 **B800:0000** (段地址 B800H，偏移地址 0000H)。
- **字符和属性存储**：**每个屏幕显示位置** 在内存中占用 **2 个字节**。
  - **第一个字节**：存储 **字符的 ASCII 码**。
  - **第二个字节**：存储 **属性字节 (Attribute Byte)**，用于控制字符的 **颜色**、**闪烁** 等显示属性。
- **屏幕尺寸**：**DOS 屏幕** 通常设置为 **80 列 x 25 行**，总共可以显示 **2000 个字符** (80 * 25 = 2000)。
- **内存占用**：整个屏幕的显存空间占用 **4000 字节** (2000 字符 * 2 字节/字符 = 4000 字节)。

**DOS 屏幕内存组织结构**

![img](https://s2.loli.net/2025/01/20/6aKeHzGnytwgx3Q.png)

##### 属性字节 (Attribute Byte) 结构

**属性字节 (Attribute Byte)** 用于控制 **DOS 文本模式** 下 **字符的显示属性**，例如 **前景色**、**背景色**、**闪烁**、**亮度** 等。

**属性字节的位结构**：

![img](https://s2.loli.net/2025/01/20/4ypTE8rYaFnU523.jpg)

- **背景色 (Background Color)**：
  - **位 7 (F, Flash)**：**闪烁控制位**。
    - **1**: 字符 **闪烁**。
    - **0**: 字符 **不闪烁**。
  - **位 6-4 (R, G, B)**：**背景颜色控制位**。
    - **RGB 三位二进制编码**，控制 **背景颜色**，可以表示 8 种颜色 (黑、蓝、绿、青、红、紫、黄、白)。

- **前景色 (Foreground Color)**：
  - **位 3 (I, Intensity)**：**亮度控制位**。
    - **1**: **高亮度** (亮色)。
    - **0**: **普通亮度** (暗色)。
  - **位 2-0 (R, G, B)**：**前景色控制位**。
    - **RGB 三位二进制编码**，控制 **前景色**，可以表示 8 种颜色 (黑、蓝、绿、青、红、紫、黄、白)。

##### 汇编代码示例：屏幕打印 "Hello, world!"

以下汇编代码示例演示了如何在 **DOS 文本模式** 下，**直接访问屏幕内存**，在屏幕上打印字符串 `"Hello, world!"`。

```assembly
.MODEL small
.STACK
.DATA
    msg db 'Hello, world!'
.CODE
start:
    ; 设置数据段寄存器 DS 指向数据段
    mov ax, @data
    mov ds, ax

    ; 设置附加段寄存器 ES 指向显存段 (B800h)
    mov ax, 0B800h
    mov es, ax

    ; 清空屏幕
    xor dx, dx            ; DX 寄存器清零，用于存储空格字符和属性
    mov cx, 2000          ; 屏幕字符总数 (80列 * 25行)
    xor di, di            ; DI 寄存器清零，作为显存地址偏移量
clear_screen:
    mov es:[di], dx       ; 将空格字符和属性写入显存，清空屏幕
    add di, 2             ; 显存地址偏移量增加 2 (每个字符占 2 字节)
    loop clear_screen     ; 循环清空整个屏幕

    ; 循环写入字符和属性，打印字符串 "Hello, world!"
    mov cx, 13            ; 字符串长度 (13个字符)
    mov di, (12 * 80 + 33) * 2 
    lea bx, msg           ; BX 寄存器指向字符串 msg 的首地址
print_loop:
    mov al, [bx]          ; 从字符串中取出一个字符，放入 AL 寄存器
    mov ah, 07h           ; 设置属性字节为 07h (黑底白字)
    mov es:[di], ax       ; 将字符和属性字节写入显存
    inc bx              ; 字符串指针 BX 加 1，指向下一个字符
    add di, 2             ; 显存地址偏移量增加 2
    loop print_loop       ; 循环打印整个字符串

    ; 等待按键按下后退出程序
wait_for_key:
    mov ah, 1
    int 16h             ; BIOS 键盘输入中断，检测是否有按键按下 (不回显)
    jz wait_for_key     ; 如果没有按键按下，继续等待
    mov ah, 0
    int 16h             ; BIOS 键盘输入中断，读取按键的 ASCII 码 (回显)

    ; 退出程序，返回 DOS
    mov ax, 4C00h
    int 21h             ; DOS 程序结束中断
END
```

#### 驻留程序 (TSR)

**驻留程序 (Terminate and Stay Resident, TSR)** 是一种在 **DOS 系统** 中使用的特殊程序类型。

- **驻留内存**：**TSR 程序** 在 **主程序结束后**，**仍然可以继续驻留在内存中**，**不释放内存资源**。
- **后台运行**：**TSR 程序** 通常在 **后台运行**，**监听系统事件** 或 **用户操作**，并在特定条件触发时**被激活**，执行预定的功能。
- **快速调用**：由于 TSR 程序常驻内存，因此可以被**快速调用**，无需重新加载，**提高了响应速度**。

**TSR 程序的典型应用**：

- **弹出式工具**：例如 **弹出式计算器**、**剪贴板工具**。用户可以通过**热键** 快速激活 TSR 程序，执行计算、复制粘贴等操作，完成后程序仍然驻留在后台。
- **系统监控程序**：例如 **系统资源监视器**、**病毒扫描程序**。TSR 程序可以在后台**监控系统状态**，并在发现异常情况时**及时发出警告** 或 **采取措施**。
- **定时任务**：利用 **定时器中断**，TSR 程序可以**周期性地执行** 某些**后台任务**，例如 **自动备份**、**数据同步** 等。

##### 热键检测

```assembly
; 伪代码：检测热键 Ctrl+Alt+X
check_hotkey:
    mov ah, 02h       ; BIOS 功能号 02h：读取键盘状态
    int 16h           ; 调用 BIOS 键盘中断 16h，读取键盘状态字节到 AL 寄存器
    and al, 00001111b ; 屏蔽 AL 寄存器高 4 位，仅保留低 4 位 (Shift, Ctrl, Alt, Scroll Lock 状态位)
    cmp al, 00001100b ; 与 00001100b (Ctrl+Alt 键按下) 进行比较
    jne no_hotkey     ; 如果比较结果不相等 (Ctrl+Alt 未同时按下)，跳转到 no_hotkey 标签

    ; 如果 Ctrl+Alt 键同时按下，继续检测 X 键是否按下
    mov ah, 00h       ; BIOS 功能号 00h：读取键盘输入
    int 16h           ; 调用 BIOS 键盘输入中断 16h，读取键盘扫描码和 ASCII 码
    cmp al, 'x'       ; 比较 AL 寄存器中的 ASCII 码是否为字符 'x' (小写 x)
    je hotkey_pressed ; 如果比较结果相等 (X 键按下)，跳转到 hotkey_pressed 标签

no_hotkey:
    ret               ; 如果热键未按下，子程序返回

hotkey_pressed:
    ; 在这里编写 TSR 程序的功能代码
    ; 例如：弹出计算器窗口、显示系统信息等
    ret               ; 热键处理程序返回
```
---

### Lecture10: MASM Code for Interrupts

#### 一个显示在屏幕右上角的后台计时器

```assembly
.MODEL small
.STACK 100h

.DATA
    ; 注意：TSR运行时DS可能改变，变量存储在代码段
    ; 以下变量通过CS段前缀访问

.CODE
.STARTUP
jmp install_tsr    ; 跳过数据区

    ; 变量存储在代码段（保持驻留）
    dseg   db '0',0    ; 当前显示字符
    cntr   db 0        ; 中断计数器
    old_ip dw 0        ; 原中断处理程序IP
    old_cs dw 0        ; 原中断处理程序CS

install_tsr:
    ; 保存原INT 8h中断向量
    cli                 ; 禁用中断
    xor ax, ax
    mov es, ax          ; ES=0000h（中断向量表段）
    mov bx, 8*4         ; INT 8h向量地址（8h*4=20h）

    ; 保存原处理程序地址
    mov ax, es:[bx]
    mov old_ip, ax
    mov ax, es:[bx+2]
    mov old_cs, ax

    ; 设置新中断向量
    mov ax, OFFSET isr
    mov es:[bx], ax
    mov ax, cs
    mov es:[bx+2], ax
    sti                 ; 重新启用中断

    ; 计算驻留内存大小并终止驻留
    mov dx, OFFSET tsr_end  ; DX=程序结束地址
    mov cl, 4
    shr dx, cl           ; 转换为段落（除以16）
    inc dx               ; 向上取整
    mov ax, 3100h        ; AH=31h TSR功能，AL=返回码
    int 21h

; 中断服务程序（ISR）
isr PROC far
	pushf
    push di
    push si
    push bp
    push ds
    push es

    ; 使用CS段访问变量
    mov bx, cs
    mov ds, bx

    ; 更新计数器
    inc cs:cntr
    cmp cs:cntr, 18      ; 约1秒（18.2次/秒）
    jb chain_int

    ; 重置计数器并更新显示
    mov cs:cntr, 0
    inc cs:dseg
    cmp cs:dseg, '9'
    jbe update_screen
    mov cs:dseg, '0'

update_screen:
    ; 直接写入显存B800h
    mov ax, 0B800h
    mov es, ax
    mov di, (79)*2
    mov al, cs:dseg
    mov es:[di], al

chain_int:
    ; 恢复环境并链式调用原中断处理程序
    pop es
    pop ds
    pop bp
    pop si
    pop di
    popf
    jmp cs:dword ptr old_ip  ; 跳转到原处理程序

isr ENDP

tsr_end:   ; 标记TSR代码结束
END
```

---

### Lecture 11: 内存层次结构：动态与静态随机存储器

#### 内存的层次结构

##### 内存层次结构的重要性

现代计算机系统采用**内存层次结构 (Memory Hierarchy)** 以平衡 **速度**、**成本** 和 **容量** 之间的矛盾。  这种结构利用了程序访问数据的局部性原理，通过多层不同特性的存储器协同工作，实现高性能的内存系统。

- **高速缓存 (Cache)** -> **主存储器 (Main Memory)** -> **辅助存储器 (Secondary Storage)** 构成金字塔结构。
- **速度递减**：从高速缓存到辅助存储器，访问速度**依次降低**。
- **成本递减**：从高速缓存到辅助存储器，单位存储容量的**成本依次降低**。
- **容量递增**：从高速缓存到辅助存储器，存储**容量依次增大**。

![img](https://s2.loli.net/2025/02/05/WFPhUrcmqHkQwfV.png)

#### 主存储器 (Main Memory)

##### 主存的分类：DRAM 与 SRAM

**主存储器 (Main Memory)**，也常被称为 **内存** 或 **RAM (Random Access Memory)**，是计算机系统中用于 **高速** 存储 **正在运行的程序和数据** 的关键组件。 主存储器主要分为两种类型： **DRAM (动态随机存取存储器)** 和 **SRAM (静态随机存取存储器)**。

##### 静态随机存取存储器 (SRAM)

**静态随机存取存储器 (Static Random Access Memory, SRAM)**  是一种高速的半导体存储器，其特点包括：

- **构造原理**：**SRAM** 基于 **触发器 (Flip-Flops)** 存储数据。每个存储位使用多个晶体管 (通常为 4-6 个) 构成触发器来保持数据状态。
- **单元尺寸**：由于使用触发器结构，**SRAM 存储单元** 的 **尺寸较大**，集成度相对较低。
- **数据保持**：**SRAM** 具有 **易失性 (Volatile)**，断电后数据会丢失。但只要供电，**SRAM** 就能**静态地保持数据**，**无需刷新操作**。
- **访问速度**：**SRAM** 的 **访问速度非常快**，远快于 **DRAM**，常用于构建 **高速缓存 (Cache)**。典型的 **SRAM 访问时间** 约为 **10 纳秒 (10ns)**。

**SRAM 存储单元结构图**

![img](https://s2.loli.net/2025/02/05/sKPQC53i4GehDf8.jpg)

**SRAM 访问方式示意图**

![img](https://s2.loli.net/2025/02/05/UHuO3Z5taWRKqwJ.jpg)

##### 动态随机存取存储器 (DRAM)

**动态随机存取存储器 (Dynamic Random Access Memory, DRAM)**  是另一种常用的半导体存储器，其特性如下：

- **构造原理**：**DRAM** 基于 **MOSFET (金属氧化物半导体场效应晶体管)** 的 **栅极电容** 存储数据。每个存储位使用一个晶体管和一个电容组成存储单元。
- **存储密度**：**DRAM 存储单元** 结构简单，**尺寸小**，可以实现 **更高的存储密度** (更大的存储容量)。
- **成本**：**DRAM** 的 **制造成本较低**，因此被广泛用作 **主存储器**。
- **数据保持与刷新**：**DRAM** 也是 **易失性** 存储器。由于电容会 **漏电**，**DRAM** 存储的数据需要 **定期刷新 (Refresh)** 才能保持。需要 **额外的刷新控制电路** 来完成刷新操作。
- **访问速度**：**DRAM** 的 **访问速度相对较慢**，典型的 **DRAM 访问时间** 约为 **60 纳秒 (60ns)**。 在**非访问状态下**，**DRAM 不消耗能量**。 为了提高读取速度，**DRAM** 在读取操作前会对存储单元进行 **预充电 (Precharge)**。 因此，**DRAM 的速度** 通常以 **总周期时间 T** 来衡量，约为 **访问时间的两倍**。

**DRAM 存储单元结构图**

![img](https://s2.loli.net/2025/02/05/1dtrQVfJh9DweoB.png)

**4-bit DRAM 结构示意图**

**DRAM** 通常以 **阵列形式** 组织，例如 **4 位 DRAM 结构**。 通过 **激活字线 (Word Line)** 来选择 **存储单元行**，然后通过 **列选择 (Column Select)** 来选择 **特定的位** 进行读写操作。

![img](https://s2.loli.net/2025/02/05/SYylcC7O6iIfVwT.png)

#### DRAM 读写与刷新周期

##### DRAM 的读写操作

**DRAM 的读写操作** 流程如下：

1.  **行激活 (Row Activation)**：通过 **激活字线 (Word Line)** 选择 **存储单元阵列中的一行**。 这会将选定行中 **所有存储单元的数据** **读出** 到 **位线 (Bit Line)**。
2.  **列选择与数据传输 (Column Select & Data Transfer)**： 通过 **激活列线 (Column Line)** 和 **列选择信号 (CAS, Column Address Select)**， 从选定行中 **选择特定的列** (即 **特定的存储单元**)。
3.  **数据写入 (Write)** 或 **读回 (Readback)**：
    - **读取模式 (Read Mode)**：**列线被激活**，选定存储单元的数据被 **输出**。同时，**读出的数据** 会被 **写回 (Write Back)** 到 **存储单元**，以 **保持数据**。
    - **写入模式 (Write Mode)**：**列线被激活**，**新的数据** 通过 **列线** 被 **写入** 到选定的 **存储单元**。

##### DRAM 刷新 (Refresh)

**DRAM 刷新 (Refresh)** 是维持 **DRAM 数据完整性** 的关键操作。

- **刷新必要性**：由于 **DRAM** 使用 **电容存储数据**，电容上的电荷会 **随时间泄漏**。为了防止数据丢失，**每个存储单元** 必须 **定期重新写入 (刷新)**。
- **刷新周期**：通常，**DRAM** 的 **刷新周期** 为 **每 2 毫秒 (2ms)** 左右。这意味着 **每个存储单元** 必须 **每 2ms 内至少刷新一次**。
- **刷新机制**：**DRAM 控制器** 负责 **自动执行刷新操作**。 **RAS (Row Address Select)** 和 **CAS (Column Address Select)** 信号线 被用于实现 **刷新控制**。 通常采用 **行刷新 (Row Refresh)** 方式，即 **每次刷新一行存储单元**。

#### 内存封装类型

##### 常见内存封装

**内存芯片** 采用多种 **封装形式 (Package)**，以适应不同的应用场景和安装需求。 常见的内存封装类型包括：

- **DIP (Dual In-line Package)**：**双列直插式封装**，引脚呈双行排列，**穿孔安装 (Through-hole)**，体积较大，已较少使用。
- **SIMM (Single In-line Memory Module)**：**单列直插式内存模块**，引脚呈单行排列，**表面安装 (Surface-mount)**，体积较小，常用于早期计算机。
- **DIMM (Dual In-line Memory Module)**：**双列直插式内存模块**，引脚呈双行排列，**表面安装**，是目前最常见的内存封装形式。

**内存封装类型示意图**

![img](https://s2.loli.net/2025/02/05/6owb4Jl82jd5qKP.png)

---

The user is correct - I over-bolded the previous response. I need to go through the entire document and reduce the amount of bolding.

**Plan:**

1.  **Review each section:** Systematically read through the notes and identify instances of bolding that can be reduced or removed.
2.  **Prioritize Core Concepts:** Ensure *key* concepts are still bolded, but remove unnecessary or less important bolded phrases. Favor bolding individual terms over longer phrases.
3.  **Estimate and Adjust:** While precise calculation isn't feasible, aim to keep bolding visually sparse and ensure it's well under a perceived 10% of the text in each paragraph.  Err on the side of *less* bolding.
4.  **Prioritize Annotations:** Ensure annotated professional terms remain bolded, as that's a fixed requirement.
5.  **Re-read for Flow:** After reducing bolding, read the notes again to ensure they still flow well and the remaining bolded terms effectively highlight the most important information.好的，根据您的最新指示，我将对笔记内容进行再次调整，大幅度减少加粗的使用，力求控制在10%以内，并确保核心概念仍然突出。

### Lecture 12: 内存管理与缓存策略

#### 访问局部性

> 在计算机科学中，**引用局部性**，也称为**局部性原理**，是指处理器在短时间内重复访问同一组内存位置的趋势。引用局部性有两种基本类型——**时间局部性**和**空间局部性**。时间局部性指的是在相对较短的时间内重复使用特定的数据和/或资源。空间局部性（也称为数据局部性）指的是使用相对接近的存储位置中的数据元素。顺序局部性是空间局部性的一种特殊情况，当数据元素以线性方式排列和访问时发生，例如遍历一维数组中的元素。
>
> 局部性是计算机系统中发生的一种可预测的行为。表现出强引用局部性的系统非常适合通过使用诸如**缓存**、**内存预取**以及处理器核心的高级**分支预测器**之类的技术来进行性能优化。

##### 引用局部性的类型

**引用局部性** 是指程序在执行过程中访问存储器的地址倾向于聚集在某些区域的特性。 引用局部性是缓存得以有效工作的理论基础，可以分为两种主要类型：

- **时间局部性 (Temporal Locality)**：
  - **定义**：如果某个内存地址在当前时刻被访问，那么在不久的将来，该地址很可能再次被访问。
  - **原理**：程序倾向于重复使用最近访问过的数据和指令。例如，循环、函数调用、计数器等都会导致时间局部性。
  - **缓存优化**：时间局部性使得将最近访问过的数据 存储在高速缓存 中变得有效，以便后续快速访问。

- **空间局部性 (Spatial Locality)**：
  - **定义**：如果某个内存地址在当前时刻被访问，那么在不久的将来，其附近的内存地址 也很可能被访问。
  - **原理**：程序在访问某个数据时，很可能会访问与其相邻的数据。例如，顺序执行的指令、数组的顺序访问、结构体或对象的成员访问等都表现出空间局部性。
  - **缓存优化**：空间局部性使得可以预取 当前访问地址附近的数据块 到缓存中，以减少未来访问的延迟。 顺序局部性 可以被看作是空间局部性的一种特殊情况，例如线性访问数组。

![img](https://s2.loli.net/2025/02/05/xL3GV1hlsMBknrU.png)

**示例**：

- 数据段中的数据访问倾向于展现空间局部性，因为相关数据通常存储在相邻的内存区域。
- 循环体内部的代码和数据访问倾向于展现时间局部性，因为循环会重复执行相同的指令和访问相同的数据。

#### 缓存 (Cache)

##### 缓存的工作原理

**缓存 (Cache)** 是一种高速、小容量 的存储器，位于 **CPU (中央处理器)** 和 **主存储器 (DRAM)** 之间，用于缓解 CPU 与主存之间速度不匹配 的问题。

- **数据复制**：处理器当前正在使用的代码和数据，会从速度较慢的 **D-RAM (动态随机存取存储器)** 中复制 到速度更快的 **S-RAM (静态随机存取存储器)** 缓存中。
    
    例如，Intel i7 处理器的二级缓存 (L2 Cache) 为 8MB，通常搭配 8GB 的 DRAM 作为主内存。
    
- **缓存命中 (Cache Hit) 与缓存未命中 (Cache Miss)**：
  
  当处理器发出内存地址请求 时，缓存控制器 (Cache Controller) 会首先检查 所需数据是否已存在于缓存中，这称为 缓存查找 (Cache Lookup)。
  
  - **缓存命中 (Cache Hit)**：如果数据已存在于缓存中，则称为 缓存命中。数据会直接从缓存高速传输到处理器，无需访问速度较慢的主内存，从而 减少了访问延迟。
  - **缓存未命中 (Cache Miss)**：如果数据不在缓存中，则称为 缓存未命中。此时，缓存控制器需要从 主内存读取数据 并 发送给处理器 (速度较慢)。 同时，为了利用局部性原理，缓存控制器会将读取的数据 的 副本 也存入缓存，以便后续可能的访问。
  - **缓存命中率 (Hit Rate)**：S-RAM 缓存命中次数 占 总读取次数 的 百分比，称为 缓存命中率，是衡量缓存性能的重要指标。 个人电脑的 缓存命中率 通常可以高达 90% 甚至更高。

**总结**：缓存的工作原理类似于在处理器和主存之间建立一个“快速通道”，通过存储常用数据，减少了处理器访问慢速主存的次数，从而提高了程序的整体执行速度。

**x86 缓存模型**

![img](https://s2.loli.net/2025/02/05/FEn7RvTY9dhbwpt.png)

**典型缓存参数**

![img](https://s2.loli.net/2025/02/05/iB9RzTQH2XlvOoK.png)

##### 缓存组织方式

缓存控制器 包含一个 缓存目录 (Cache Directory)，用于管理缓存中的数据。 常见的缓存组织方式包括：

- **直接映射缓存 (Direct Mapped Cache)**：
  - **单页映射**：缓存被组织成只包含内存中单个页面的副本。
  - **地址冲突与抖动 (Thrashing)**：如果处理器频繁地在不同页面之间快速切换，可能会导致 抖动 (Thrashing) 现象。
    - 抖动 指的是缓存频繁地被新页面替换，而旧页面又很快被重新访问， 导致缓存命中率极低，系统性能急剧下降。
    - 直接映射缓存容易发生抖动，因为它对每个主存块的缓存位置是固定的。
  - **性能影响**：抖动会显著降低系统速度。

- **双路组相联缓存 (Two-Way Set Associative Cache)**：
  - **双缓存组**：使用两个独立的缓存 (或称为 路 (Way)) 来存储数据。
  - **页面快速切换**：允许在两个缓存组之间快速切换页面，降低了抖动的可能性。
  - **提高命中率**：相较于直接映射缓存，组相联缓存 提供了更高的灵活性，可以减少地址冲突，提高缓存命中率。

- **全相联缓存 (Fully Associative Cache)**：
  - **任意位置存放**：主存中的任何数据块 可以被放置在缓存中的任何位置。
  - **缓存目录查找**：每个缓存条目的 缓存目录 需要存储 完整的 DRAM 地址 和 关联的数据。
  - **查找开销**：由于需要搜索整个缓存目录 来查找数据，查找速度可能较慢。
  - **数据替换策略**：需要复杂的数据替换策略 来决定当缓存满时，如何丢弃旧数据。例如：
    - 随机丢弃 (Random Discard)：随机选择缓存行进行替换。
    - 统一丢弃 (Uniform Discard)：按照某种预定规则丢弃缓存行。
    - **最近最少使用 (LRU, Least Recently Used)**：替换最近最少被访问的缓存行。LRU 策略 的实现较为复杂，需要记录每个缓存行的访问历史。
  - **应用局限**：由于成本和复杂性较高，全相联缓存在 PC (个人计算机) 中较少使用 (尤其是在 1995 年左右)。

###### 直接映射缓存的地址映射 (Direct Mapped Cache)

直接映射缓存的地址映射机制如下 (以 80386 处理器为例):

- **地址总线**：80386 处理器具有 32 位地址总线，可以访问 $2^{32} = 4$ GBytes 的内存空间。
- **数据总线**：数据总线 也是 32 位宽，每 4 个字节 组成一个 行 (Line) (或称为 字 (Word))。
- **缓存容量**：80386 缓存包含 8196 行，总容量为 32KB (8196 行 * 4 字节/行 = 32784 字节 ≈ 32KB)。
- **缓存块 (Block)**：缓存将 行 组织成 块 (Block)，每 8 行 组成一个 块，每个块大小为 32 字节 (8 行 * 4 字节/行 = 32 字节)。
- **内存页面划分**：缓存控制器将 4GB 内存空间划分为 $2^{32} / 32768 = 131072$ 个 页面 (Page)，每个页面大小为 32KB。
- **直接映射规则**：主内存 的 特定行 总是 映射到缓存中的相同行位置。
- **缓存目录 (Tag Directory)**：缓存目录 存储 每个缓存行 对应的 主内存页面位置 (称为 标记 (Tag))。 标记 用于区分缓存行中存储的数据来自主内存的哪个页面。

**内存地址分解** (32 位地址):

- A15-A31 (高 17 位)：标记 (Tag) 位，用于 设置主内存中的页面。
- A5-A14 (中间 10 位)：块索引 (Block Index) 位，用于 设置缓存中的块号。
- A2-A4 (低 3 位)：行索引 (Line Index) 位，用于 设置块内的行号。
- A0-A1 (最低 2 位)：字节偏移 (Byte Offset) 位，用于 选择行内的特定字节。

![img](https://s2.loli.net/2025/02/06/F5OZo4ktVp8ceyD.png)

**内存访问流程**：

1.  CPU 输出 32 位地址。
2.  缓存控制器 从地址中提取 标记位 (A15-A31) 和 块索引位 (A5-A14)。
3.  **比较标记**：将地址的 标记位 与 缓存目录中对应块索引位置的标记条目 进行 比较。
4.  **缓存命中 (Cache Hit)**：如果 标记匹配 且 有效位 (Valid Bit) 表明数据有效，则发生 缓存命中。数据 直接从缓存读取。
5.  **缓存未命中 (Cache Miss)**：如果 标记不匹配 或 有效位无效，则发生 缓存未命中。 缓存控制器 需要访问 DRAM 获取数据，并将 数据副本 存储到 缓存 中，更新 缓存目录。

###### 抖动 (Thrashing) 问题

**抖动 (Thrashing)** 问题在 直接映射缓存 中尤为突出。

- **抖动场景**：当程序循环重复访问 内存中 不同页面 的 相同块索引位置 时，例如：
  - 程序访问 页面 0 的 X 块，然后访问 页面 1 的 X 块，如此循环。
- **缓存冲突**：由于 直接映射缓存 的 映射规则，页面 0 的 X 块 和 页面 1 的 X 块 会 映射到缓存中的相同位置。
- **频繁替换**：每次访问都会导致 缓存未命中，需要从 DRAM 重新加载数据到缓存，并 替换 之前缓存的内容。
- **性能下降**：导致 每次内存访问 都变成 DRAM 访问，缓存形同虚设，内存访问延迟增大，系统性能 严重下降。

![img](https://s2.loli.net/2025/02/06/HiNdGcZoKD5JQFI.png)

###### 组相联缓存 (Set Associative Cache)

**组相联缓存** 旨在 缓解直接映射缓存的抖动问题。

- **多路缓存**：将缓存 分成多个组 (Set)，每个组包含 多个路 (Way) (例如 双路组相联 就是每个组包含 两条路，即 两个独立的缓存块)。
- **灵活映射**：主存中的一个块 可以 映射到 组内任意一路的缓存行。
- **地址映射**：内存地址被划分为 标记 (Tag)、组索引 (Set Index) 和 块偏移 (Block Offset) 字段。 组索引 用于 选择缓存组， 标记 用于在 组内 区分不同的主存块。

**双路组相联缓存示意图**

![img](https://s2.loli.net/2025/02/06/ojUrMb957gAY1QO.png)

- **抖动缓解**：在 抖动场景 中，例如程序循环访问 页面 0 的 X 块 和 页面 1 的 X 块， 双路组相联缓存 可以将 页面 0 的 X 块 缓存到 Way 0，将 页面 1 的 X 块 缓存到 Way 1。
- **减少冲突**：从而 避免了缓存冲突，提高了缓存命中率，改善了性能。
- **替换策略**：当缓存组满时，需要替换策略 (如 **LRU (Least Recently Used), 最近最少使用算法**) 来决定替换哪一路的缓存行。 LRU 位 用于 标记每个缓存路 的 最近使用情况，以便 优先替换 最近最少使用 的缓存路。

###### 全相联缓存 (Fully Associative Cache)

**全相联缓存** 提供了 最大的灵活性，但实现成本和复杂度也最高。

- **任意位置映射**：主存中的任何行 可以被写入缓存中的任意位置。
- **缓存目录开销**：缓存目录中的每个标记 必须是 完整的 30 位地址 (或其他位数，取决于地址空间大小)，以 唯一标识 缓存行对应的主存地址。
- **查找开销大**：为了查找数据，必须搜索整个缓存目录，查找时间较长。

**全相联缓存的缺点**：

1.  **查找速度慢**：需要 遍历整个缓存目录 才能确定缓存是否命中。
2.  **替换策略复杂**：当缓存满时，需要复杂的 替换策略 (如 LRU) 来 丢弃旧数据。 LRU 策略 的实现需要维护每个缓存行的 访问历史信息，增加了硬件开销。

全相联缓存 由于实现复杂，成本高昂，在 PC (个人计算机) 中 不常使用 (尤其是在 1995 年左右)。

##### 缓存效率

缓存虽然在空间容量上远小于内存，但它比内存快得多，在程序执行速度上起着至关重要的作用。由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此当 CPU 尝试访问的数据不在缓存中时，就会发生缓存未命中（cache miss），此时 CPU 不得不从速度较慢的内存中加载所需数据。

###### 缓存未命中的原因

- **强制性未命中 (Compulsory Miss)**：
  - **首次访问**：也称为 冷启动未命中 (Cold Start Miss)。当程序第一次访问 某个 内存块 时，该块 不在缓存中， 必须从 DRAM 中读取。 强制性未命中是不可避免的。
- **容量未命中 (Capacity Miss)**：
  - **缓存容量不足**：如果程序频繁使用 的 内存块数量 超过了缓存的容量，就会发生 容量未命中。 即使缓存已经装满了数据，但程序需要访问的数据仍然不在缓存中，需要从 DRAM 读取并替换缓存中的旧数据。
  - 抖动也是容量未命中的一种表现形式。
- **冲突未命中 (Conflict Miss)**：
  - **地址冲突**：在 直接映射缓存 或 组相联缓存 中，由于 地址映射的限制，不同的 主存块 可能 映射到缓存中的相同位置 (或 同一个组)。 当程序 频繁访问 映射到 相同缓存位置 的 不同主存块 时，就会发生 冲突未命中。

###### 缓存的效果评估：Amdahl 定律

**Amdahl 定律 (Amdahl's Law)** 用于 评估 通过 改进系统资源 (例如使用缓存) 所能获得的 性能提升。

**Amdahl 定律公式**：

$Speedup = \frac{1}{(1-p) + \frac{p}{s}}$

公式中：

- Speedup (加速比)： 使用改进资源后，系统性能提升的倍数。
- s (资源改进带来的速度提升)： 改进的资源 (例如缓存) 比原有资源 (例如 DRAM) 的速度提升倍数。
- p (可加速部分占比)： 程序执行时间中，可以受益于资源改进的部分 所占的比例。

**缓存性能提升示例**：

假设：

- 缓存将内存访问速度提升 10 倍 (从 100ns DRAM 访问时间 降低到 10ns 缓存访问时间)，即 $s = 10$。
- 典型程序的缓存命中率 为 95%，即程序执行时间中有 95% 的时间受益于缓存加速， $p = 0.95$。

**计算加速比**：

$Speedup = \frac{1}{(1-0.95) + \frac{0.95}{10}} = \frac{1}{0.05 + 0.095} = \frac{1}{0.145} \approx 6.89$

**结论**： 加入缓存 后，内存访问速度比 仅使用 DRAM 时 提高了约 6.89 倍。

###### 有效访问时间 (EAT) 估算

**有效访问时间 (Effective Access Time, EAT)** 用于 综合评估 包含 缓存 的 内存系统的平均访问性能。

**EAT 计算公式**：

$\text{EAT} = (1 - \text{命中率}) \times \text{缓存访问时间} + \text{命中率} \times (\text{缓存访问时间} + \text{未命中惩罚})$

简化公式 (假设未命中惩罚主要来自 DRAM 访问时间):

$\text{EAT} \approx (1 - p) \times \text{缓存访问时间} + p \times \text{DRAM 访问时间}$        p: 缓存命中率

**EAT 估算示例**：

假设：

- 缓存访问时间: 10 纳秒 (ns)。
- 缓存未命中率: 5% (命中率 95%)， 即 $p = 0.95$, 未命中率 $1-p = 0.05$。
- DRAM 访问时间: 100 纳秒 (ns)。

**计算 EAT**:

$\begin{aligned} \text{EAT} &= (1 - 0.95) \times 10 \text{ns} + 0.95 \times 100 \text{ns} \\ &= 0.05 \times 10 \text{ns} + 0.95 \times 100 \text{ns} \\ &= 0.5 \text{ns} + 95 \text{ns} \\ &\approx 14.5 \text{ns} \end{aligned}$

**加速比验证**：

$\text{加速比} = \frac{\text{DRAM 访问时间}}{\text{EAT}} = \frac{100 \text{ns}}{14.5 \text{ns}} \approx 6.89$

**结论**： 内存系统的 有效访问时间 约为 14.5 纳秒，相较于 100 纳秒的 DRAM 访问时间， 速度提升约为 6.89 倍，与 Amdahl 定律的计算结果一致。

##### 写策略 (Write Policies)

**写策略 (Write Policies)** 定义了 数据写入缓存时，如何保证缓存和主内存数据一致性 的策略。

- **写直通 (Write-Through)**：
  - **同步写入**：每次向缓存写入数据时，同时也 将数据 写入主内存。
  - **数据一致性**：缓存和主内存中的数据始终保持一致。
  - **写操作延迟**：写操作的速度 受限于 DRAM 的速度， 写入速度较慢。
  - **读操作高速**：读操作 可以从 高速缓存 中进行，速度较快。

- **写回 (Write-Back)**：
  - **延迟写入**：数据写入操作 只写入缓存，暂不写入主内存。
  - **数据标记**：被修改过的缓存行 会被 标记为“脏 (Dirty)”。
  - **替换时写回**：只有当 脏缓存行 需要被 替换 (例如，缓存满时) 时，才将 脏数据写回主内存。
  - **写操作高速**：写操作速度 仅受限于 缓存速度， 写入速度较快。
  - **读操作高速**：读操作 也可以从 高速缓存 中进行，速度较快。
  - **数据一致性挑战**：缓存和主内存数据 在一段时间内可能 不一致，数据一致性维护较为复杂。 需要更复杂的机制 (例如 监听 (Snooping) 或 目录 (Directory) 协议) 来保证 多处理器系统 中 缓存一致性。
  - **优点**：减少了对主内存的写操作次数，提高了写性能。

**DMA (直接内存访问) 与缓存一致性**：

**DMA (Direct Memory Access, 直接内存访问)** 允许 某些硬件设备 (例如 DMA 控制器) 直接 读写主存储器， 无需 CPU 的参与。 DMA 操作可能导致 缓存与主内存之间的数据不一致 问题。

- **写直通缓存**：写直通缓存在一定程度上可以 缓解 DMA 缓存一致性问题，因为 每次缓存写入 都会 同步更新主内存。
- **写回缓存**：写回缓存 需要 更复杂的机制 来处理 DMA 缓存一致性，例如 缓存刷新 (Cache Flush) 操作，强制将 脏缓存行写回主内存，以确保 DMA 设备读取到最新的数据。

##### 多级缓存 (Multilevel Caches)

**多级缓存 (Multilevel Caches)** 是现代高性能处理器中常用的缓存组织方式。

- **分级结构**：采用 多层缓存 结构，例如 L1 缓存 (一级缓存)、 L2 缓存 (二级缓存)、 L3 缓存 (三级缓存) 等。
- **速度与容量平衡**：
  - **L1 缓存 (一级缓存)**： 容量最小，速度最快，通常 集成在 CPU 核心内部。 L1 缓存 追求 最低的访问延迟，通常可以实现 零等待状态 (Zero Wait State) 访问，即 `mov ax,[bx]` 指令 可以在 最少的时钟周期内完成。 典型容量为 1KB - 32KB。
  - **L2 缓存 (二级缓存)**： 容量比 L1 大，速度比 L1 慢，但比主存快。通常 集成在 CPU 芯片上，但不一定在核心内部。 典型容量为 2MB - 8MB。
  - **L3 缓存 (三级缓存)**： 容量最大，速度最慢 (但仍比主存快)。 通常 多个 CPU 核心共享 L3 缓存。 典型容量可以达到 数 MB 到 数十 MB。
- **访问顺序**：CPU 访问内存时，首先查找 L1 缓存，如果 L1 未命中，则 查找 L2 缓存， 依此类推，直到 最后一级缓存 或 主内存。

**示例参数**：

- **一级缓存 (L1 Cache)**: 例如 1KB - 32KB， 零等待状态。
- **二级缓存 (L2 Cache)**: 例如 2MB， 500MHz 运行频率。
- **主存储器 (Main Memory)**: 例如 最大 64GB 容量。

##### DMA

**DMA (Direct Memory Access, 直接内存访问)** 技术允许 某些硬件设备 (例如 DMA 控制器) 直接 读写主存储器， 无需 CPU 的参与。

- **CPU 解放**：DMA 技术 可以 解放 CPU， 使 CPU 可以 并行处理其他任务， 提高系统整体效率。
- **高速数据传输**：DMA 适用于 高速数据传输 的场景，例如 硬盘数据读取、 图形图像数据传输、 音频数据传输 等。
- **应用设备**：DMA 常用于 帧捕获卡 (Frame Grabber)、 声卡 (Sound Card) 等设备。

###### DMA 控制器 (DMA Controller)

**DMA 控制器 (DMA Controller)** 是 实现 DMA 传输的关键硬件组件。

**DMA 控制器结构示意图**

![img](https://s2.loli.net/2025/02/06/oCObRVXqmdr2lAv.png)**DMA 传输序列 (DMA Sequence)**

DMA 控制器 通过一系列 握手信号 与 CPU 和 外围设备 协同工作，完成 DMA 数据传输。

1.  **DMA 请求 (DREQ, DMA Request)**：
    - 外围设备 (例如 智能磁盘控制器) 准备好数据 后， 设置 DREQ 信号线为高电平， 请求 DMA 传输。
2.  **HOLD 请求 (HOLD Request)**：
    - DMA 控制器 接收到 DREQ 信号 后，向 CPU 发送 HOLD 请求信号 (HOLD)。
3.  **HOLD 响应 (HLDA, HOLD Acknowledge)**：
    - CPU 在 完成当前总线周期 后，释放总线控制权，并将 HLDA 信号线拉高， 响应 DMA 请求。
4.  **总线控制权转移**：
    - DMA 控制器 接管 数据总线、 地址总线 和 控制总线 的 控制权。 CPU 暂时与内存断开连接。
5.  **DMA 确认 (DACK, DMA Acknowledge)**：
    - DMA 控制器 向 外围设备 发送 DMA 确认信号 (DACK)， 允许设备开始 DMA 传输。
6.  **数据传输**：
    - 外围设备 (例如 智能磁盘驱动器) 通过 DMA 控制器 直接向主内存写入数据 或 从主内存读取数据。
7.  **HOLD 释放**：
    - DMA 传输完成后， DMA 控制器 释放 HOLD 请求。
8.  **CPU 恢复总线控制**：
    - CPU 重新获得总线控制权， HLDA 信号线被拉低。

**总结**： DMA 传输过程 无需 CPU 的持续干预， 数据传输 在 DMA 控制器 和 外围设备 之间 直接进行， 提高了数据传输效率， 减轻了 CPU 负担。

#### ROM (只读存储器)

**ROM (Read-Only Memory, 只读存储器)** 是一种 非易失性存储器， 断电后数据不会丢失。 ROM 通常用于 存储 固件 (Firmware) 和 引导代码 (Boot Sequence Code)，例如 BIOS (基本输入/输出系统)。

##### ROM 的类型

- **掩膜 ROM (Mask Programmed ROM)**：
  - **制造时编程**：程序 在 ROM 芯片制造过程中 被 永久写入， 出厂后无法更改。
  - **成本高，适用于大批量生产**。

- **PROM (可编程 ROM, Programmable ROM)**：
  - **一次性编程**：用户 可以使用 PROM 编程器 写入程序 一次。 编程过程 通常通过 熔断器件内部的熔丝 (Fusible Links) 来实现。 一旦编程，无法修改。

- **EPROM (可擦除可编程 ROM, Erasable Programmable ROM)**：
  - **多次编程**：用户 可以 多次擦除和重写程序。
  - **紫外线擦除**：EPROM 通过 紫外线 (UV Light) 照射 擦除 存储的数据。 擦除过程 需要 将芯片从电路板上取下，并 使用紫外线擦除器照射一段时间。
  - **电荷存储**：EPROM 使用 FET (场效应晶体管) 栅极上的电荷 存储数据。 高电压编程 会在 绝缘栅极 上 注入电荷， 改变 FET 的阈值电压，从而表示不同的数据状态。

**EPROM 编程与擦除原理示意图**

![img](https://s2.loli.net/2025/02/06/QjS1fELiaUhdFsZ.png)

- **EEPROM (电可擦除可编程 ROM, Electrically Erasable Programmable ROM)**：
  - **电可擦除和编程**：EEPROM 可以通过 电信号 进行 擦除和重写， 无需紫外线照射， 也无需从电路板上取下芯片。
  - **字节或块擦除**：EEPROM 可以 按字节 (Byte) 或 按块 (Block) 进行 擦除， 灵活性更高。
  - **应用广泛**：EEPROM 常用于 存储 BIOS 设置、 固件升级 等。 Flash 存储器 (闪存) 是 EEPROM 的一种发展，具有 更高的擦除和写入速度， 更大的存储容量。

**2716 EPROM 引脚图**

![img](https://s2.loli.net/2025/02/06/US56fcp1ByiIbwP.png)

##### ROM 组合 (或与其他类型存储器组合)

ROM 芯片 (或 其他类型的存储器芯片) 可以通过 芯片选择 (CS, Chip Select) 信号线 和 多路复用器 (Demultiplexer) 组合 在 同一内存空间 中。

- **地址解码**：多路复用器 根据 高位地址线 译码 产生 不同的 CS 信号。
- **芯片选择**：每个 ROM 芯片 的 CS 引脚 连接到 多路复用器 的 不同输出端。
- **内存扩展**：通过 控制 CS 信号， 可以 选择访问特定的 ROM 芯片，从而 扩展内存空间。

**ROM 组合应用示意图**

![img](https://s2.loli.net/2025/02/06/SVPh3LTKi2QMJRB.png)

#### 虚拟内存 (Virtual Memory)

##### 虚拟内存的概念与作用

**虚拟内存 (Virtual Memory)** 是一种 内存管理技术， 将 磁盘 (硬盘) 的一部分 作为 内存 的扩展 来使用， 使得程序可以 访问比实际物理内存更大的地址空间。

- **虚拟地址空间 (Virtual Address Space)**： CPU 寻址 的 地址空间 称为 虚拟地址空间。 在 典型的 PC 系统 中， 虚拟地址空间 可以是 64GB 甚至更大。
- **物理内存 (Physical Memory)**： 实际安装在计算机上的 RAM 容量 称为 物理内存 (或 主内存)。 例如 4GB RAM。
- **地址映射**： 虚拟内存系统 负责 将 虚拟地址 映射到 物理地址。 并非所有虚拟地址 都 映射到物理内存。
- **页面交换 (Paging)**： 虚拟内存系统 将 虚拟地址空间 和 物理内存 都 划分成固定大小的块， 称为 页面 (Page)。 数据 以 页面为单位 在 物理内存 和 外部存储器 (硬盘) 之间 交换。

##### 虚拟内存的工作原理

- **外存扩展**：虚拟内存系统 使用 外部存储器 (硬盘) 作为 主内存的扩展。 不常用的数据页面 被 换出 (Swap Out) 到 硬盘 上， 释放物理内存空间。
- **按需调入**： 当 CPU 需要访问 不在物理内存中的数据页面 (称为 缺页 fault, Page Fault) 时， 操作系统 负责将 所需页面 从 硬盘 调入 (Swap In) 物理内存。 如果 物理内存已满， 则需要 替换 物理内存中 暂时不用的页面 到 硬盘 上， 腾出空间 加载新页面。
- **缓存相似性**： 虚拟内存 的 页面交换机制 与 缓存的工作方式 类似。 物理内存 可以看作是 硬盘数据 的 缓存。

##### 虚拟内存的性能

- **性能影响**：虚拟内存的性能 严重依赖于 页面交换的效率。 如果程序 频繁发生缺页 fault， 导致 频繁的硬盘读写操作， 系统性能会 大幅下降， 这被称为 “磁盘抖动 (Disk Thrashing)”。 虚拟内存的 未命中惩罚 (Miss Penalty) 非常高， 可能高达 100,000 个 CPU 时钟周期。
- **内存不足与虚拟内存**： 在 Windows 等操作系统 中， 如果 同时打开多个应用程序， 容易 耗尽物理内存。 此时， 操作系统 会 开始使用虚拟内存。 系统性能 会 显著降低， 运行速度 变得非常缓慢。
