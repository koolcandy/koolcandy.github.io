<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://s2.loli.net/2024/12/26/m9oanbD6ikhuSlN.png"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="## Lecture 1: CPU

### 计算机架构

计算机主要采用两种架构：  
- **冯诺依曼架构**：使用同一个存储器，经由同一个总线传输指令和数据. 
- **哈佛架构**：使用独立的指令存储器和数据存储器，提升执行效率. 

> [!NOTE]
>
> 现代高性能CPU通常结合冯诺依曼和哈佛架构的特点，例如通过“拆分缓存”设计来优化性能。">
<meta property="og:title" content="CS253 Architectures II">
<meta property="og:description" content="## Lecture 1: CPU

### 计算机架构

计算机主要采用两种架构：  
- **冯诺依曼架构**：使用同一个存储器，经由同一个总线传输指令和数据. 
- **哈佛架构**：使用独立的指令存储器和数据存储器，提升执行效率. 

> [!NOTE]
>
> 现代高性能CPU通常结合冯诺依曼和哈佛架构的特点，例如通过“拆分缓存”设计来优化性能。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://koolcandy.github.io/post/CS253%20Architectures%20II.html">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/m9oanbD6ikhuSlN.png">
<title>CS253 Architectures II</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>
<style>.markdown-alert{padding:0.5rem 1rem;margin-bottom:1rem;border-left:.25em solid var(--borderColor-default,var(--color-border-default));}.markdown-alert .markdown-alert-title {display:flex;font-weight:var(--base-text-weight-medium,500);align-items:center;line-height:1;}.markdown-alert>:first-child {margin-top:0;}.markdown-alert>:last-child {margin-bottom:0;}</style><style>.markdown-alert.markdown-alert-note {border-left-color:var(--borderColor-accent-emphasis, var(--color-accent-emphasis));background-color:var(--color-accent-subtle);}.markdown-alert.markdown-alert-note .markdown-alert-title {color: var(--fgColor-accent,var(--color-accent-fg));}</style>



<body>
    <div id="header">
<h1 class="postTitle">CS253 Architectures II</h1>
<div class="title-right">
    <a href="https://koolcandy.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/koolcandy/koolcandy.github.io/issues/3" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2>Lecture 1: CPU</h2>
<h3>计算机架构</h3>
<p>计算机主要采用两种架构：</p>
<ul>
<li><strong>冯诺依曼架构</strong>：使用同一个存储器，经由同一个总线传输指令和数据.</li>
<li><strong>哈佛架构</strong>：使用独立的指令存储器和数据存储器，提升执行效率.</li>
</ul>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>现代高性能CPU通常结合冯诺依曼和哈佛架构的特点，例如通过“拆分缓存”设计来优化性能。</p>
</div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e427bca9d059866bcc4c78e09c1b0d204f60ccf1c0a17b93f3c94028c7903edd/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f734a447745535072386f34646e766d2e706e67"><img src="https://camo.githubusercontent.com/e427bca9d059866bcc4c78e09c1b0d204f60ccf1c0a17b93f3c94028c7903edd/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f734a447745535072386f34646e766d2e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/13/sJDwESPr8o4dnvm.png" style="max-width: 100%;"></a></p>
<p>具体而言，冯诺依曼架构和哈佛架构的区别体现在以下几点：</p>
<ol>
<li><strong>存储器结构</strong>：冯诺依曼架构使用统一存储器，而哈佛架构使用独立的指令和数据存储器.</li>
<li><strong>总线设计</strong>：冯诺依曼架构使用单条总线，哈佛架构使用多条独立总线.</li>
</ol>
<h3>8086的硬件组成</h3>
<p>8086 CPU主要由以下两部分组成：</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/25e6c0c3effcff54b360ede4676b1396e31ef53818f85e4764b43a238456c047/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f6d326b646f54746277384d5963577a2e706e67"><img src="https://camo.githubusercontent.com/25e6c0c3effcff54b360ede4676b1396e31ef53818f85e4764b43a238456c047/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f6d326b646f54746277384d5963577a2e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/13/m2kdoTtbw8MYcWz.png" style="max-width: 100%;"></a></p>
<h4>BIU: 总线接口单元</h4>
<ul>
<li><strong>功能</strong>：负责发送地址，从内存中获取指令，并执行端口和内存的读写操作.</li>
<li><strong>特点</strong>：BIU通过总线与外部设备通信，是CPU与内存之间的桥梁.</li>
</ul>
<h4>EU: 执行单元</h4>
<ul>
<li><strong>功能</strong>：解码指令并执行指令，包含算术逻辑单元 (ALU) 和控制电路.</li>
<li><strong>特点</strong>：EU是CPU的核心执行模块，负责完成具体的计算任务.</li>
</ul>
<p><strong>指令周期</strong>是8086 CPU的基本工作单位，具体流程如下：</p>
<ol>
<li><strong>Fetch</strong>：从内存中获取指令.</li>
<li><strong>Decode</strong>：对指令进行解码.</li>
<li><strong>Execute</strong>：执行解码后的指令.</li>
</ol>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>8086 CPU的指令周期通常占用4个时钟周期，因此1GHz的处理器每秒约可执行2.5亿条指令。</p>
</div>
<h4>ALU: 算术逻辑单元</h4>
<p>8086的ALU支持以下基本操作：</p>
<ul>
<li><strong>算术运算</strong>：
<ul>
<li><strong>ADD</strong>：加法</li>
<li><strong>SUB</strong>：减法</li>
<li><strong>INC</strong>：自增</li>
<li><strong>DEC</strong>：自减</li>
</ul>
</li>
<li><strong>逻辑运算</strong>：
<ul>
<li><strong>AND</strong>：逻辑与</li>
<li><strong>OR</strong>：逻辑或</li>
<li><strong>XOR</strong>：逻辑异或</li>
<li><strong>NOT</strong>：取反</li>
</ul>
</li>
</ul>
<p>此外，ALU还支持<strong>移位操作</strong>，具体包括：</p>
<ul>
<li><strong>逻辑移位</strong>：在移位操作中，空出的位置填充逻辑0.</li>
<li><strong>算术移位</strong>：在移位操作中，空出的位置填充符号位 (最高位) .</li>
</ul>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>移位操作在二进制运算中非常重要，常用于快速实现乘除法。</p>
</div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/db659fd291b7b98c4d5b576ee74715da5f6cd3c095c0d4332a4eed9284dc317f/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f6a716f4778706341685277514475532e706e67"><img src="https://camo.githubusercontent.com/db659fd291b7b98c4d5b576ee74715da5f6cd3c095c0d4332a4eed9284dc317f/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f6a716f4778706341685277514475532e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/13/jqoGxpcAhRwQDuS.png" style="max-width: 100%;"></a></p>
<p>左移和右移的实现方法如下：</p>
<ul>
<li><strong>左移</strong>：将二进制数的所有位向左移动一位，最低位填充0.</li>
<li><strong>右移</strong>：将二进制数的所有位向右移动一位，最高位填充符号位 (逻辑移位时填充0，算术移位时填充符号位) .</li>
</ul>
<h2><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/26c2b7623e17585d1dae26f60c7abc73050a0a9506b9418d0dfcc1ed5d2b3784/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f6a7138444f4b37586c65566279366d2e706e67"><img src="https://camo.githubusercontent.com/26c2b7623e17585d1dae26f60c7abc73050a0a9506b9418d0dfcc1ed5d2b3784/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f6a7138444f4b37586c65566279366d2e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/13/jq8DOK7XleVby6m.png" style="max-width: 100%;"></a></h2>
<h2>Lecture 2: Assembly Language (Ⅰ)</h2>
<h3>寄存器们</h3>
<h4>通用寄存器</h4>
<ul>
<li><strong>通用寄存器</strong>：8086有8个通用寄存器，可以将它们视为8个变量，某些指令可以成对使用寄存器，从而提供16位操作。当用作寄存器对时，它们被赋予集体名称<strong>AX</strong>、<strong>BX</strong>、<strong>CX</strong>、<strong>DX</strong>。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/75278f6b33827f604d991c21a24827751906129b3057703d59c04a1a681637f1/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f3658757343697a507679456c6461352e706e67"><img src="https://camo.githubusercontent.com/75278f6b33827f604d991c21a24827751906129b3057703d59c04a1a681637f1/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f3658757343697a507679456c6461352e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/13/6XusCizPvyElda5.png" style="max-width: 100%;"></a></p>
<h4>指针和变址寄存器</h4>
<ul>
<li><strong>SP (堆栈指针)</strong>：指向堆栈顶部。</li>
<li><strong>BP (基址指针)</strong>：用于访问堆栈中的参数和局部变量。</li>
<li><strong>SI (源变址寄存器)</strong>：用于字符串操作中的源地址。</li>
<li><strong>DI (目的变址寄存器)</strong>：用于字符串操作中的目的地址。</li>
</ul>
<h4>段寄存器</h4>
<ul>
<li><strong>CS (代码段)</strong>：指向当前代码段。</li>
<li><strong>DS (数据段)</strong>：指向当前数据段。</li>
<li><strong>SS (堆栈段)</strong>：指向当前堆栈段。</li>
<li><strong>ES (附加段)</strong>：指向附加数据段。</li>
</ul>
<h4>控制寄存器</h4>
<ul>
<li><strong>IP (指令指针)</strong>：指向下一条要执行的指令。</li>
<li><strong>FLAGS (标志寄存器)</strong>：存储状态和控制标志。</li>
</ul>
<h4>标志位寄存器</h4>
<p>8086在特殊的16位标志寄存器中跟踪某些计算的结果：</p>
<ul>
<li><strong>U: Undefined (未定义)</strong></li>
<li><strong>OF: Overflow flag (溢出标志)</strong></li>
<li><strong>DF: String direction flag (字符串方向标志)</strong></li>
<li><strong>IF: Interrupt enable flag (中断启用标志)</strong></li>
<li><strong>TF: Single step trap flag (单步陷阱标志)</strong></li>
<li><strong>SF: Sign flag (符号标志, 结果的最高有效位)</strong></li>
<li><strong>ZF: Zero flag, set if result=0 (零标志, 如果结果为零则设置)</strong></li>
<li><strong>AF: BCD Carry flag (BCD 进位标志)</strong></li>
<li><strong>PF: Parity flag (奇偶校验标志)</strong></li>
<li><strong>CF: Carry flag (进位标志)</strong></li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/65cbfdfc5f8627b04258b5c909b9175675b844c16775a43bb6776dd55827b3e0/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f674b444c61476f37626b78384170562e706e67"><img src="https://camo.githubusercontent.com/65cbfdfc5f8627b04258b5c909b9175675b844c16775a43bb6776dd55827b3e0/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f674b444c61476f37626b78384170562e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/13/gKDLaGo7bkx8ApV.png" style="max-width: 100%;"></a></p>
<h3>8086的分段内存模型</h3>
<h4>分段内存模型概述</h4>
<ul>
<li>因为8086的寄存器只有16位，为了让它能访问20位的地址，需要使用<strong>CS寄存器</strong>给出代码段地址，<strong>IP寄存器</strong>给出偏移距离，然后计算出指令的内存地址位置。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6db4cde54f84cc2f71fc28d07ab3ff8c52d030a9c108cbdd05ef1b96526bba35/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f6a56546d594876676f357957716e342e706e67"><img src="https://camo.githubusercontent.com/6db4cde54f84cc2f71fc28d07ab3ff8c52d030a9c108cbdd05ef1b96526bba35/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f6a56546d594876676f357957716e342e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/13/jVTmYHvgo5yWqn4.png" style="max-width: 100%;"></a></p>
<h4>数据段寄存器 (DS)</h4>
<ul>
<li><strong>DS (Data Segment Register)</strong>：指向程序的数据所在的内存段。DS寄存器存储程序数据段的起始地址。访问数据时，需要指定一个偏移量，指明数据在数据段内的位置，通过<strong>DS:偏移量</strong>配合工作。</li>
</ul>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>偏移量的来源包括：</p>
<ul>
<li><strong>直接寻址</strong>：偏移量可以是指令中直接给出的一个常量 (例如 <code class="notranslate">mov ax, [0x1234]</code>) 。</li>
<li><strong>寄存器寻址</strong>：偏移量可以使用通用寄存器 (例如 <code class="notranslate">BX</code>, <code class="notranslate">SI</code>, <code class="notranslate">DI</code>)  (例如 <code class="notranslate">mov ax, [bx]</code>) 。</li>
<li><strong>寄存器 + 常量</strong>：偏移量可以是寄存器值 + 常量 (例如 <code class="notranslate">mov ax, [bx+0x10]</code>) 。</li>
</ul>
</div>
<h4>堆栈段寄存器 (SS)</h4>
<ul>
<li><strong>SS (Stack Segment Register)</strong>：指向堆栈所在的内存段。SS寄存器存储堆栈段的起始地址。</li>
<li><strong>SP寄存器</strong>：指向当前栈顶的地址，它始终指向栈中最后一个被压入 (pushed) 的值的位置。</li>
<li><strong>BP寄存器</strong>：通常指向当前栈帧的基地址，主要用途是：
<ul>
<li>在函数调用过程中，BP作为访问函数局部变量、函数参数的基址。</li>
<li>方便函数内部访问栈上的数据。</li>
<li>可以在函数返回时恢复栈帧。</li>
</ul>
</li>
</ul>
<h4>附加段寄存器 (ES)</h4>
<ul>
<li><strong>ES (Extra Segment Register)</strong>：用于字符串操作的额外数据段，通常作为目标段使用，通过<strong>ES:DI</strong>配合工作。</li>
</ul>
<h3>MASM 程序结构</h3>
<h4>程序结构</h4>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d8b6eb745d1500e9886381766bed91af1d503b9fb6843297834ce3d38186e27f/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f75704d387450544a5a5637473659732e706e67"><img src="https://camo.githubusercontent.com/d8b6eb745d1500e9886381766bed91af1d503b9fb6843297834ce3d38186e27f/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f75704d387450544a5a5637473659732e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/13/upM8tPTJZV7G6Ys.png" style="max-width: 100%;"></a></p>
<h4>编译过程</h4>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8a00e362ffb4fb75776c28fe4e770bb709a903110534673b2e1e36ff4fd8a846/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f4b676e466f66317441326d474f56792e706e67"><img src="https://camo.githubusercontent.com/8a00e362ffb4fb75776c28fe4e770bb709a903110534673b2e1e36ff4fd8a846/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f4b676e466f66317441326d474f56792e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/13/KgnFof1tA2mGOVy.png" style="max-width: 100%;"></a></p>
<h4>运算符和操作数</h4>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/4f98c0bc5cf1be3018144d2aaad6a95401c6f001142bef3603bda0ecf9601dee/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f78696842534e7163524775707635562e706e67"><img src="https://camo.githubusercontent.com/4f98c0bc5cf1be3018144d2aaad6a95401c6f001142bef3603bda0ecf9601dee/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31332f78696842534e7163524775707635562e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/13/xihBSNqcRGupv5V.png" style="max-width: 100%;"></a></p>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>这里的<strong>Operand</strong>也可以称作<strong>立即数</strong>。</p>
</div>
<h3>Hello, world !</h3>
<h4>详细实现</h4>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">.MODEL medium</span>
<span class="pl-en">.STACK</span>
<span class="pl-en">.DATA</span>

<span class="pl-en">msg1 db </span><span class="pl-s">"Hello, world.$"</span>

<span class="pl-en">.CODE</span>
<span class="pl-en">.STARTUP</span>

<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en">@data</span><span class="pl-c">                    ; 将 ax 寄存器的值设置为 @data 段的值</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ds</span><span class="pl-s1">,</span><span class="pl-v">ax</span><span class="pl-c">                       ; 将 DS 寄存器的值设置为 @data 段的值</span>
<span class="pl-k">lea</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-s1">,</span><span class="pl-en">msg1</span><span class="pl-c">                     ; 获得msg1的偏移地址, 在这个情况下(DS&lt;&lt;4+BX)就是实际的存储msg1的地址</span>

<span class="pl-en">back:</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dl</span><span class="pl-s1">,[</span><span class="pl-v">bx</span><span class="pl-s1">]</span><span class="pl-c">                 ; 间接寻址, 获取bx寄存器对应的内存地址的第一个值到dx寄存器</span>
<span class="pl-en">    </span><span class="pl-k">cmp</span><span class="pl-en"> </span><span class="pl-v">dl</span><span class="pl-s1">,</span><span class="pl-s">'$'</span><span class="pl-c">                  ; 将 dl 寄存器中的字符与字符 $ 进行比较</span>
<span class="pl-en">    </span><span class="pl-k">jz</span><span class="pl-en"> done</span><span class="pl-c">                     ; 如果 dl 寄存器中的字符和$相等 (即 ZF 标志位为 1 ), 则跳转到done执行</span>

<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-c1">02h</span><span class="pl-c">                  ; 设置 DOS 中断 21h 的功能号为 02h, 表示调用显示字符的功能</span>
<span class="pl-en">    </span><span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">21h</span><span class="pl-c">                     ; 调用 DOS 中断 21h, 将 dl 寄存器中的字符显示在屏幕上</span>

<span class="pl-en">    </span><span class="pl-k">inc</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-c">                      ; 将 bx 寄存器的值加 1, 指向字符串 msg1 的下一个字符</span>
<span class="pl-en">    </span><span class="pl-k">jmp</span><span class="pl-en"> back</span><span class="pl-c">                    ; 无条件跳转到 back 标签处</span>

<span class="pl-en">done:</span>
<span class="pl-en">    </span><span class="pl-k">nop</span><span class="pl-c">                         ; 空操作指令</span>

<span class="pl-en">.EXIT</span>

<span class="pl-en">END</span></pre></div>
<h4>简洁实现</h4>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">.MODEL small</span>
<span class="pl-en">.STACK</span>
<span class="pl-en">.DATA</span>
<span class="pl-en">    msg DB </span><span class="pl-s">'Hello, World!$'</span><span class="pl-c">    ; 定义字符串，以$结尾</span>
<span class="pl-en">    </span>
<span class="pl-en">.CODE</span>
<span class="pl-en">.STARTUP</span>

<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> @data</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ds</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span>

<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">09h</span><span class="pl-c">               ; 打印字符串</span>
<span class="pl-en">    </span><span class="pl-k">lea</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> msg</span>
<span class="pl-en">    </span><span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">21h</span>

<span class="pl-en">.EXIT</span>

<span class="pl-en">END</span></pre></div>
<h4>常用 21h 功能号</h4>
<ul>
<li><strong>01h</strong>: 从键盘读取一个字符, 并将字符存入 AL 寄存器</li>
<li><strong>02h</strong>: 在屏幕上输出 DL 寄存器中的字符</li>
<li><strong>09h</strong>: 在屏幕上输出以 DS:DX 指向的、以 $ 结尾的字符串</li>
<li><strong>0Ah</strong>: 从键盘读取一个字符串</li>
<li><strong>3Ch</strong>: 创建一个文件</li>
<li><strong>3Dh</strong>: 打开一个文件</li>
<li><strong>3Eh</strong>: 关闭一个文件</li>
<li><strong>3Fh</strong>: 从文件中读取数据</li>
<li><strong>40h</strong>: 向文件中写入数据</li>
<li><strong>4Ch</strong>: 退出程序</li>
</ul>
<h4>重要ASCII码</h4>
<ul>
<li><strong>0x0A</strong>: Line Feed (LF), 换行，等价于 <code class="notranslate">\n</code></li>
<li><strong>0x0D</strong>: Carriage Return (CR), 回车，等价于 <code class="notranslate">\r</code></li>
</ul>
<hr>
<h2>Lecture 3: Assembly Language (Ⅱ)</h2>
<h3>寻址模式</h3>
<h4>立即寻址</h4>
<ul>
<li><strong>立即寻址</strong>是指运算数以<strong>字面量</strong>形式写在指令里面，如<code class="notranslate">mov ax, 10</code>。这里的运算数也称作<em>立即数</em>。</li>
<li>立即数直接嵌入指令中，无需额外的寻址操作，因此执行速度快。</li>
</ul>
<h4>寄存器寻址</h4>
<ul>
<li><strong>寄存器寻址</strong>指运算数保存在某个通用寄存器当中，如<code class="notranslate">mov ax, bx</code>。</li>
<li>寄存器的访问是在CPU内部的，速度非常快，因此这种寻址方式效率高。</li>
</ul>
<h4>直接寻址</h4>
<ul>
<li><strong>直接寻址</strong>如<code class="notranslate">mov ax, Count</code>，把data段当中的变量<code class="notranslate">Count</code>作为操作数。</li>
<li>实际上，变量<code class="notranslate">Count</code>在汇编器的眼里，只是对应数据所在的地址。因此，这相当于把<code class="notranslate">Count</code>所在地址的值赋给<code class="notranslate">ax</code>。</li>
<li>如果要指定其他的段，可以写作<code class="notranslate">mov ax, ES:Count</code>，即表示在额外段上的内容。</li>
</ul>
<h4>寄存器间接寻址</h4>
<ul>
<li><strong>寄存器间接寻址</strong>是把偏移地址存在寄存器 (通常是索引寄存器BX, BP, SI或DI) 当中。如果是BP，对应的段就是栈段，否则是数据段。</li>
<li>这种寻址方式与高级语言中的数组访问类似：
<ul>
<li><code class="notranslate">mov ax, [bx]</code>表示<code class="notranslate">ax = array[bx]</code></li>
<li><code class="notranslate">mov [bx], ax</code>表示<code class="notranslate">array[bx] = ax</code></li>
</ul>
</li>
</ul>
<h3>8086 指令格式</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/19b1008aecd248ec809156e0de05a7bb80788aa2247dc45e12c0c77f431d1ce5/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f5639734f70517a69776250676848642e706e67"><img src="https://camo.githubusercontent.com/19b1008aecd248ec809156e0de05a7bb80788aa2247dc45e12c0c77f431d1ce5/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f5639734f70517a69776250676848642e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/V9sOpQziwbPghHd.png" style="max-width: 100%;"></a></p>
<h4>Byte 1</h4>
<ul>
<li><strong>Opcode (操作码):</strong> 决定指令的具体动作 (如<code class="notranslate">MOV</code>) 。</li>
<li><strong>D (方向旗标):</strong> 指明数据传输的方向，是从源到目标，还是从目标到源。</li>
</ul>
<h4>Byte 2</h4>
<ul>
<li><strong>W (字/字节):</strong> 指定数据大小，16位字还是8位字节。</li>
<li><strong>Mod (寻址模式):</strong> 确定操作数地址的获取方式。</li>
<li><strong>Reg (寄存器):</strong> 指示一个寄存器。</li>
<li><strong>R/M (寄存器/内存):</strong> 指示另一个操作数是寄存器还是内存。</li>
</ul>
<h4>Low Byte/High Byte</h4>
<ul>
<li>可选字段，用于存放立即数或内存地址偏移量。</li>
</ul>
<h3>8086 寄存器编号</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7a7d30653c86fcb12ac109486226b1736d38c972d0683a108da38834419f7bd2/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30342f30362f6f7368674b4c3661553959494145572e706e67"><img src="https://camo.githubusercontent.com/7a7d30653c86fcb12ac109486226b1736d38c972d0683a108da38834419f7bd2/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30342f30362f6f7368674b4c3661553959494145572e706e67" alt="img" data-canonical-src="https://s2.loli.net/2023/04/06/oshgKL6aU9YIAEW.png" style="max-width: 100%;"></a></p>
<h3>8086 寻址模式</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/61fc46e4c6e4e377fb059b1e5f10583dbe81b5495dacbe0ff2dfdb4b30cb57f7/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f754c626368737779553842355450572e706e67"><img src="https://camo.githubusercontent.com/61fc46e4c6e4e377fb059b1e5f10583dbe81b5495dacbe0ff2dfdb4b30cb57f7/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f754c626368737779553842355450572e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/uLbchswyU8B5TPW.png" style="max-width: 100%;"></a></p>
<h4>寻址模式详解</h4>
<ul>
<li><strong>Mod=00:</strong> <strong>没有偏移量</strong>，或只是使用寄存器进行内存间接寻址。</li>
<li><strong>Mod=01:</strong> <strong>8位偏移量</strong> (d8) ，需要额外的1个字节来存储偏移量。</li>
<li><strong>Mod=10:</strong> <strong>16位偏移量</strong> (d16) ，需要额外的2个字节来存储偏移量。</li>
<li><strong>Mod=11:</strong> <strong>寄存器寻址</strong>，直接使用寄存器作为操作数，不涉及内存访问。</li>
</ul>
<h4>示例</h4>
<p><code class="notranslate">mov SP, BX</code>的二进制指令是：</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>opcode</th>
<th>D</th>
<th>W</th>
<th>Mod</th>
<th>Reg</th>
<th>R/M</th>
</tr>
</thead>
<tbody>
<tr>
<td>100010</td>
<td>1</td>
<td>1</td>
<td>11</td>
<td>100</td>
<td>011</td>
</tr>
<tr>
<td><code class="notranslate">mov</code></td>
<td>to register</td>
<td>word</td>
<td>寄存器寻址模式</td>
<td>to SP</td>
<td>to BX</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<hr>
<h2>Lecture 4: Assembly Language (Ⅲ)</h2>
<h3>算数运算命令</h3>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>代码</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ADD</strong></td>
<td><code class="notranslate">ADD AX, BX</code></td>
<td>加法运算, 将 AX 和 BX 相加, 结果存入 AX</td>
</tr>
<tr>
<td><strong>ADC</strong></td>
<td><code class="notranslate">ADC AX, BX</code></td>
<td>带进位的加法运算, 将 AX, BX, CF 相加, 结果存入 AX</td>
</tr>
<tr>
<td><strong>SUB</strong></td>
<td><code class="notranslate">SUB AX, BX</code></td>
<td>减法运算, 将 AX 减去 BX, 结果存入 AX</td>
</tr>
<tr>
<td><strong>MUL</strong></td>
<td><code class="notranslate">MUL BX</code></td>
<td>无符号乘法, 将 AX 和 BX 相乘, 结果存入 DX:AX</td>
</tr>
<tr>
<td><strong>IMUL</strong></td>
<td><code class="notranslate">IMUL BX</code></td>
<td>有符号乘法, 将 AX 和 BX 相乘, 结果存入 DX:AX</td>
</tr>
<tr>
<td><strong>DIV</strong></td>
<td><code class="notranslate">DIV BX</code></td>
<td>无符号除法, 将 DX:AX 除以 BX, 商存入 AX, 余数存入 DX</td>
</tr>
<tr>
<td><strong>IDIV</strong></td>
<td><code class="notranslate">IDIV BX</code></td>
<td>有符号除法, 将 DX:AX 除以 BX, 商存入 AX, 余数存入 DX</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><code class="notranslate">DIV</code> 与 <code class="notranslate">IDIV</code>在除数是word(16bit)的时候, 被除数是 32 位的 <code class="notranslate">DX:AX</code>,<code class="notranslate">DX</code>的值可能会产生意想不到的结果</p>
<p><code class="notranslate">MUL</code> 与 <code class="notranslate">IMUL</code>在乘数是word(16bit)的时候, 结果是32位的, 低 16 位保存在 <code class="notranslate">AX</code> 里面, 高 16 位保存到 <code class="notranslate">DX</code> 里面, 导致<code class="notranslate">DX</code>寄存器的值被覆盖</p>
</div>
<h3>十进制算数</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/1b829e633c8dcc80f2241956d96e0a629419945f53ff18cbcdbe81f379c464e1/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f34433257774b755a7361666474544e2e706e67"><img src="https://camo.githubusercontent.com/1b829e633c8dcc80f2241956d96e0a629419945f53ff18cbcdbe81f379c464e1/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f34433257774b755a7361666474544e2e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/4C2WwKuZsafdtTN.png" style="max-width: 100%;"></a></p>
<h4>ASCII调整指令</h4>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s">'9'</span><span class="pl-c">  ; AL = 39h ('9'的ASCII码)</span>
<span class="pl-k">add</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s">'8'</span><span class="pl-c">  ; AL = 39h + 38h = 71h</span>
<span class="pl-k">aaa</span><span class="pl-c">          ; 调整AL为09h, AH += 1 (AH = 01h)</span>
<span class="pl-c">; 结果: AL = 09h, AH = 01h (表示BCD格式的17)</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">0507h</span><span class="pl-c">  ; AH = 05h, AL = 07h (表示未压缩BCD的57)</span>
<span class="pl-k">aad</span><span class="pl-c">            ; AX = 0037h (37的二进制形式)</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">bl</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">6</span><span class="pl-c">      ; BL = 6</span>
<span class="pl-k">div</span><span class="pl-en"> </span><span class="pl-v">bl</span><span class="pl-c">         ; AX / BL, AL = 6 (商), AH = 1 (余数)</span>
<span class="pl-c">; 结果: AL = 06h, AH = 01h</span></pre></div>
<h4>BCD调整指令</h4>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">59h</span><span class="pl-c">  ; AL = 59h (59的压缩BCD格式)</span>
<span class="pl-k">add</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">27h</span><span class="pl-c">  ; AL = 59h + 27h = 80h</span>
<span class="pl-k">daa</span><span class="pl-c">          ; 调整AL为86h (86的压缩BCD格式)</span>
<span class="pl-c">; 结果: AL = 86h</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">47h</span><span class="pl-c">  ; AL = 47h (47的压缩BCD格式)</span>
<span class="pl-k">sub</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">59h</span><span class="pl-c">  ; AL = 47h - 59h = EEh (借位发生)</span>
<span class="pl-k">das</span><span class="pl-c">          ; 调整AL为88h (88的压缩BCD格式)</span>
<span class="pl-c">; 结果: AL = 88h</span></pre></div>
<h3>逻辑指令</h3>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>指令</th>
<th>示例</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="notranslate">AND</code></td>
<td><code class="notranslate">AND A, B</code></td>
<td>按位与</td>
</tr>
<tr>
<td><code class="notranslate">OR</code></td>
<td><code class="notranslate">OR A, B</code></td>
<td>按位或</td>
</tr>
<tr>
<td><code class="notranslate">XOR</code></td>
<td><code class="notranslate">XOR A, B</code></td>
<td>异或</td>
</tr>
<tr>
<td><code class="notranslate">BT</code></td>
<td><code class="notranslate">BT Base, Offset</code></td>
<td>指定地址的值赋给 CF</td>
</tr>
<tr>
<td><code class="notranslate">BTC</code></td>
<td><code class="notranslate">BTC Base, Offset</code></td>
<td>指定地址位的值赋给 CF, 该位取反</td>
</tr>
<tr>
<td><code class="notranslate">BTR</code></td>
<td><code class="notranslate">BTR Base, Offset</code></td>
<td>指定地址位的值赋给 CF, 该位设零</td>
</tr>
<tr>
<td><code class="notranslate">BTS</code></td>
<td><code class="notranslate">BTS Base, Offset</code></td>
<td>指定地址位的值赋给 CF, 该位设一</td>
</tr>
<tr>
<td><code class="notranslate">BSF</code></td>
<td><code class="notranslate">BSF A, B</code></td>
<td>B 最低的 1 是第几位, 赋给 A</td>
</tr>
<tr>
<td><code class="notranslate">BSR</code></td>
<td><code class="notranslate">BSR A, B</code></td>
<td>B 最高的 1 是第几位, 赋给 A</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<h3>逻辑偏移</h3>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>指令</th>
<th>示例</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHL</td>
<td><code class="notranslate">SHL AX, 1</code></td>
<td>将AX寄存器的内容逻辑左移1位, 空出的位用0填充</td>
</tr>
<tr>
<td>SHR</td>
<td><code class="notranslate">SHR BX, 2</code></td>
<td>将BX寄存器的内容逻辑右移2位, 空出的位用0填充</td>
</tr>
<tr>
<td>SAL</td>
<td><code class="notranslate">SAL CX, 1</code></td>
<td>将CX寄存器的内容算术左移1位, 空出的位用0填充 (与SHL相同 )</td>
</tr>
<tr>
<td>SAR</td>
<td><code class="notranslate">SAR DX, 3</code></td>
<td>将DX寄存器的内容算术右移3位, 空出的位用符号位填充</td>
</tr>
<tr>
<td>ROL</td>
<td><code class="notranslate">ROL AL, 1</code></td>
<td>将AL寄存器的内容循环左移1位, 移出的位重新填充到右侧</td>
</tr>
<tr>
<td>ROR</td>
<td><code class="notranslate">ROR BL, 2</code></td>
<td>将BL寄存器的内容循环右移2位, 移出的位重新填充到左侧</td>
</tr>
<tr>
<td>RCL</td>
<td><code class="notranslate">RCL AX, 1</code></td>
<td>将AX寄存器的内容带进位循环左移1位, 进位标志 (CF) 参与循环</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/df81794cad4610cf8704fe352c71701ed0856d7c9229938a88391ba7f06c20b9/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31312f523968794151667631534438616a452e706e67"><img src="https://camo.githubusercontent.com/df81794cad4610cf8704fe352c71701ed0856d7c9229938a88391ba7f06c20b9/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31312f523968794151667631534438616a452e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/11/R9hyAQfv1SD8ajE.png" style="max-width: 100%;"></a></p>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>逻辑右移 (SHR )用0填充空出的高位, 而算术右移 (SAR )用符号位填充空出的高位</strong></p>
</div>
<h3>标志位指令</h3>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="notranslate">CLC</code></td>
<td>进位标志置零</td>
</tr>
<tr>
<td><code class="notranslate">STC</code></td>
<td>进位标志设一</td>
</tr>
<tr>
<td><code class="notranslate">CMC</code></td>
<td>进位标志取反</td>
</tr>
<tr>
<td><code class="notranslate">CLD</code></td>
<td>方向标志置零</td>
</tr>
<tr>
<td><code class="notranslate">STD</code></td>
<td>方向标志设一</td>
</tr>
<tr>
<td><code class="notranslate">CLI</code></td>
<td>IF 置零, 关闭中断</td>
</tr>
<tr>
<td><code class="notranslate">STI</code></td>
<td>IF 设一, 打开中断</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<h3>比较指令</h3>
<p><code class="notranslate">CMP</code> 命令（Compare，比较）是 8086 汇编语言中的一个非常重要的指令。它用于 <strong>比较两个操作数的大小关系</strong>，但 <strong>不会修改任何操作数的值</strong>。 <code class="notranslate">CMP</code> 命令的 <strong>“结果”</strong> 不是直接返回一个数值，而是 <strong>设置 CPU 的标志寄存器 (Flags Register) 中的某些标志位</strong>。 这些标志位反映了比较的结果，然后可以被后续的条件跳转指令（如 <code class="notranslate">JE</code>, <code class="notranslate">JNE</code>, <code class="notranslate">JL</code>, <code class="notranslate">JG</code> 等）使用，以实现程序的分支控制。</p>
<p><strong><code class="notranslate">CMP</code> 指令的基本格式:</strong></p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">cmp</span><span class="pl-en"> destination</span><span class="pl-s1">,</span><span class="pl-en"> source</span></pre></div>
<p><strong><code class="notranslate">CMP</code> 指令的操作:</strong></p>
<p><code class="notranslate">CMP destination, source</code> 指令 <strong>在内部执行的操作是 <code class="notranslate">destination - source</code> (目的操作数减去源操作数)</strong>。  <strong>但是，减法的结果不会被存储到任何寄存器或内存位置，而是直接被丢弃。</strong>  <code class="notranslate">CMP</code> 指令的 <strong>唯一作用</strong> 就是根据这次减法运算的结果 <strong>设置标志寄存器中的标志位</strong>。</p>
<p><strong><code class="notranslate">CMP</code> 指令影响的标志位 (Flags):</strong></p>
<p><code class="notranslate">CMP</code> 指令主要影响以下几个标志位：</p>
<ol>
<li>
<p><strong>零标志位 (Zero Flag, ZF)</strong>:</p>
<ul>
<li><strong>ZF = 1</strong>:  如果 <code class="notranslate">destination - source = 0</code>，即 <strong><code class="notranslate">destination</code> 等于 <code class="notranslate">source</code></strong>，则 ZF 被设置为 1。</li>
<li><strong>ZF = 0</strong>:  如果 <code class="notranslate">destination - source ≠ 0</code>，即 <strong><code class="notranslate">destination</code> 不等于 <code class="notranslate">source</code></strong>，则 ZF 被设置为 0。</li>
</ul>
</li>
<li>
<p><strong>符号标志位 (Sign Flag, SF)</strong>:</p>
<ul>
<li><strong>SF = 1</strong>:  如果 <code class="notranslate">destination - source</code> 的结果为 <strong>负数</strong> (结果的最高位为 1，在有符号数表示中)，则 SF 被设置为 1。 这通常意味着在 <strong>有符号数比较</strong> 中，<code class="notranslate">destination</code> 小于 <code class="notranslate">source</code>。</li>
<li><strong>SF = 0</strong>:  如果 <code class="notranslate">destination - source</code> 的结果为 <strong>非负数</strong> (结果的最高位为 0)，则 SF 被设置为 0。 这通常意味着在 <strong>有符号数比较</strong> 中，<code class="notranslate">destination</code> 大于等于 <code class="notranslate">source</code>。</li>
</ul>
</li>
<li>
<p><strong>进位标志位 (Carry Flag, CF)</strong>:</p>
<ul>
<li><strong>CF = 1</strong>:  如果在 <strong>无符号数减法</strong> 中，发生了 <strong>借位</strong> (borrow)，则 CF 被设置为 1。 这通常意味着在 <strong>无符号数比较</strong> 中，<code class="notranslate">destination</code> 小于 <code class="notranslate">source</code>。</li>
<li><strong>CF = 0</strong>:  如果在 <strong>无符号数减法</strong> 中，没有发生借位，则 CF 被设置为 0。 这通常意味着在 <strong>无符号数比较</strong> 中，<code class="notranslate">destination</code> 大于等于 <code class="notranslate">source</code>。</li>
</ul>
</li>
<li>
<p><strong>溢出标志位 (Overflow Flag, OF)</strong>:</p>
<ul>
<li><strong>OF = 1</strong>:  如果在 <strong>有符号数减法</strong> 中，发生了 <strong>溢出</strong> (结果超出了有符号数的表示范围)，则 OF 被设置为 1。  溢出标志用于判断 <strong>有符号数运算结果是否溢出</strong>。  在比较有符号数大小时，OF 需要和 SF 一起考虑。</li>
<li><strong>OF = 0</strong>:  如果在 <strong>有符号数减法</strong> 中，没有发生溢出，则 OF 被设置为 0。</li>
</ul>
</li>
</ol>
<p><strong>常用的条件跳转指令和 <code class="notranslate">CMP</code> 结果的关系:</strong></p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>条件跳转指令</th>
<th>含义 (通常用于)</th>
<th>检查的标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="notranslate">JE</code> 或 <code class="notranslate">JZ</code></td>
<td>等于 (Equal) 或 结果为零 (Zero)</td>
<td>ZF = 1</td>
</tr>
<tr>
<td><code class="notranslate">JNE</code> 或 <code class="notranslate">JNZ</code></td>
<td>不等于 (Not Equal) 或 结果非零 (Not Zero)</td>
<td>ZF = 0</td>
</tr>
<tr>
<td><code class="notranslate">JG</code> 或 <code class="notranslate">JNLE</code></td>
<td>大于 (Greater) (有符号数) 或 不小于等于 (Not Less or Equal)</td>
<td>ZF = 0 且 SF = OF</td>
</tr>
<tr>
<td><code class="notranslate">JGE</code> 或 <code class="notranslate">JNL</code></td>
<td>大于等于 (Greater or Equal) (有符号数) 或 不小于 (Not Less)</td>
<td>SF = OF</td>
</tr>
<tr>
<td><code class="notranslate">JL</code> 或 <code class="notranslate">JNGE</code></td>
<td>小于 (Less) (有符号数) 或 不大于等于 (Not Greater or Equal)</td>
<td>SF ≠ OF</td>
</tr>
<tr>
<td><code class="notranslate">JLE</code> 或 <code class="notranslate">JNG</code></td>
<td>小于等于 (Less or Equal) (有符号数) 或 不大于 (Not Greater)</td>
<td>ZF = 1 或 SF ≠ OF</td>
</tr>
<tr>
<td><code class="notranslate">JA</code> 或 <code class="notranslate">JNBE</code></td>
<td>大于 (Above) (无符号数) 或 不小于等于 (Not Below or Equal)</td>
<td>CF = 0 且 ZF = 0</td>
</tr>
<tr>
<td><code class="notranslate">JAE</code> 或 <code class="notranslate">JNB</code> 或 <code class="notranslate">JNC</code></td>
<td>大于等于 (Above or Equal) (无符号数) 或 不小于 (Not Below) 或 无进位 (No Carry)</td>
<td>CF = 0</td>
</tr>
<tr>
<td><code class="notranslate">JB</code> 或 <code class="notranslate">JNAE</code> 或 <code class="notranslate">JC</code></td>
<td>小于 (Below) (无符号数) 或 不大于等于 (Not Above or Equal) 或 进位 (Carry)</td>
<td>CF = 1</td>
</tr>
<tr>
<td><code class="notranslate">JBE</code> 或 <code class="notranslate">JNA</code></td>
<td>小于等于 (Below or Equal) (无符号数) 或 不大于 (Not Above)</td>
<td>CF = 1 或 ZF = 1</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<h3>分支控制</h3>
<p>条件跳转是短跳转, 操作数是一个字节, 允许向后跳转 -128 或向前跳转 +127</p>
<p>无条件跳跃可以跳得更远, 可以直接地址跳转, 允许 +/-32K 的跳转, 甚至允许跳转到AX寄存器！</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>flag</th>
<th>反指令</th>
<th>反含义</th>
<th>反 flag</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="notranslate">JA</code></td>
<td>Above</td>
<td><code class="notranslate">ZF=0 and CF=0</code></td>
<td><code class="notranslate">JNA</code></td>
<td>Not Above</td>
<td><code class="notranslate">ZF=1 or CF=1</code></td>
</tr>
<tr>
<td><code class="notranslate">JAE</code></td>
<td>Above or Equal</td>
<td><code class="notranslate">CF=0</code></td>
<td><code class="notranslate">JNAE</code></td>
<td>Not Above or Equal</td>
<td><code class="notranslate">CF=1</code></td>
</tr>
<tr>
<td><code class="notranslate">JB</code></td>
<td>Below</td>
<td><code class="notranslate">CF=1</code></td>
<td><code class="notranslate">JNB</code></td>
<td>Not Below</td>
<td><code class="notranslate">CF=0</code></td>
</tr>
<tr>
<td><code class="notranslate">JBE</code></td>
<td>Below or Equal</td>
<td><code class="notranslate">ZF=1 or CF=1</code></td>
<td><code class="notranslate">JNBE</code></td>
<td>Not Below or Equal</td>
<td><code class="notranslate">ZF=0 and CF=0</code></td>
</tr>
<tr>
<td><code class="notranslate">JC</code></td>
<td>Carry</td>
<td><code class="notranslate">CF=1</code></td>
<td><code class="notranslate">JNC</code></td>
<td>Not Carry</td>
<td><code class="notranslate">CF=0</code></td>
</tr>
<tr>
<td><code class="notranslate">JCXZ</code></td>
<td>CX is Zero</td>
<td><code class="notranslate">CX=0</code></td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><code class="notranslate">JE</code></td>
<td>Equal</td>
<td><code class="notranslate">ZF=1</code></td>
<td><code class="notranslate">JNE</code></td>
<td>Not Equal</td>
<td><code class="notranslate">ZF=0</code></td>
</tr>
<tr>
<td><code class="notranslate">JG</code></td>
<td>Greater</td>
<td><code class="notranslate">ZF=0 and SF=OF</code></td>
<td><code class="notranslate">JNG</code></td>
<td>Not Greater</td>
<td><code class="notranslate">ZF=1 or SF!=OF</code></td>
</tr>
<tr>
<td><code class="notranslate">JGE</code></td>
<td>Greater or Equal</td>
<td><code class="notranslate">SF = OF</code></td>
<td><code class="notranslate">JNGE</code></td>
<td>Not Greater or Equal</td>
<td><code class="notranslate">SF != OF</code></td>
</tr>
<tr>
<td><code class="notranslate">JL</code></td>
<td>Less</td>
<td><code class="notranslate">SF != OF</code></td>
<td><code class="notranslate">JNL</code></td>
<td>Not Less</td>
<td><code class="notranslate">SF = OF</code></td>
</tr>
<tr>
<td><code class="notranslate">JLE</code></td>
<td>Less or Equal</td>
<td><code class="notranslate">ZF=1 or SF!=OF</code></td>
<td><code class="notranslate">JNLE</code></td>
<td>Not Less or Equal</td>
<td><code class="notranslate">ZF=0 and SF=OF</code></td>
</tr>
<tr>
<td><code class="notranslate">JO</code></td>
<td>Overflow</td>
<td><code class="notranslate">OF=1</code></td>
<td><code class="notranslate">JNO</code></td>
<td>No Overflow</td>
<td><code class="notranslate">OF=0</code></td>
</tr>
<tr>
<td><code class="notranslate">JP</code></td>
<td>Parity</td>
<td><code class="notranslate">PF=1</code></td>
<td><code class="notranslate">JNP</code></td>
<td>Not Parity</td>
<td><code class="notranslate">PF=0</code></td>
</tr>
<tr>
<td><code class="notranslate">JPE</code></td>
<td>Parity is Even</td>
<td><code class="notranslate">PF=1</code></td>
<td><code class="notranslate">JPO</code></td>
<td>Parity is Odd</td>
<td><code class="notranslate">PF=0</code></td>
</tr>
<tr>
<td><code class="notranslate">JS</code></td>
<td>Signed</td>
<td><code class="notranslate">SF=1</code></td>
<td><code class="notranslate">JNS</code></td>
<td>Not Signed</td>
<td><code class="notranslate">SF=0</code></td>
</tr>
<tr>
<td><code class="notranslate">JZ</code></td>
<td>Zero</td>
<td><code class="notranslate">ZF=1</code></td>
<td><code class="notranslate">JNZ</code></td>
<td>Not Zero</td>
<td><code class="notranslate">ZF=0</code></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<h3>循环</h3>
<p>主要有三种:</p>
<ul>
<li>
<p><code class="notranslate">LOOP</code>, 相当于</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">do</span> {
    <span class="pl-c">// 循环体代码</span>
    <span class="pl-c1">CX</span><span class="pl-c1">--</span>;
} <span class="pl-k">while</span> (<span class="pl-c1">CX</span> <span class="pl-c1">!=</span> <span class="pl-c1">0</span>);</pre></div>
</li>
<li>
<p><code class="notranslate">LOOPZ</code>, 相当于</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">do</span> {
    <span class="pl-c">// 循环体代码</span>
    <span class="pl-c1">CX</span><span class="pl-c1">--</span>;
} <span class="pl-k">while</span> (<span class="pl-c1">CX</span> <span class="pl-c1">!=</span> <span class="pl-c1">0</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-c1">ZF</span> <span class="pl-c1">==</span> <span class="pl-c1">1</span>);</pre></div>
</li>
<li>
<p><code class="notranslate">LOOPNZ</code>, 相当于</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">do</span> {
    <span class="pl-c">// 循环体代码</span>
    <span class="pl-c1">CX</span><span class="pl-c1">--</span>;
} <span class="pl-k">while</span> (<span class="pl-c1">CX</span> <span class="pl-c1">!=</span> <span class="pl-c1">0</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-c1">ZF</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>);</pre></div>
</li>
</ul>
<h3>延迟</h3>
<p>通过调整运行的语句来延迟特定的时间，和CPU的频率有关</p>
<h4>短延迟</h4>
<p>对于如下程序</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">  </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cx</span><span class="pl-s1">,</span><span class="pl-en"> N</span><span class="pl-c">  ; 消耗 4 时钟周期, 这里 N 是字面量, 但是取值还未确定</span>
<span class="pl-en">tag:</span>
<span class="pl-en">  </span><span class="pl-k">nop</span><span class="pl-c">        ; 消耗 3 时钟周期</span>
<span class="pl-en">  </span><span class="pl-k">nop</span><span class="pl-c">        ; 消耗 3 时钟周期</span>
<span class="pl-en">  </span><span class="pl-k">loop</span><span class="pl-en"> tag</span><span class="pl-c">   ; 消耗 17 个时钟周期, 退出循环时仅 5 个时钟周期</span></pre></div>
<p>总延迟时间的计算公式为: $C = 4 + N \times 23 - 12$</p>
<p>假设需要延迟 1000 个时钟周期, 可以通过以下步骤计算循环次数 ( N ):</p>
<p>$1000 = 4 + N \times 23 - 12$</p>
<p>解方程得到:</p>
<p>$N = \frac{1000 - 4 + 12}{23} \approx 43.65$</p>
<p>因此, 设置 ( N = 44 ) 即可实现大约 1000 个时钟周期的延迟</p>
<h4>长延迟</h4>
<p>考虑如下程序</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">.STARTUP</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-c1">02</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dl</span><span class="pl-s1">,</span><span class="pl-s">'S'</span>
<span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">021h</span>

<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">30000</span><span class="pl-c"> ;4</span>

<span class="pl-en">back2: </span>
<span class="pl-en">  </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">30000</span><span class="pl-c"> ;4</span>
<span class="pl-en">back1: </span>
<span class="pl-en">  </span><span class="pl-k">nop</span><span class="pl-c"> ;3</span>
<span class="pl-en">  </span><span class="pl-k">loop</span><span class="pl-en"> back1</span>

<span class="pl-en">  </span><span class="pl-k">dec</span><span class="pl-en"> </span><span class="pl-v">bx</span>
<span class="pl-en">  </span><span class="pl-k">jnz</span><span class="pl-en"> back2</span>

<span class="pl-en">  </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-c1">02</span>
<span class="pl-en">  </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dl</span><span class="pl-s1">,</span><span class="pl-s">'F'</span>
<span class="pl-en">  </span><span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">021h</span>
<span class="pl-en">EXIT</span></pre></div>
<p>延迟计算公式为:</p>
<p>$C_{T}=C_{0}+N(C_{BK}){-12}$</p>
<p>先计算内循环:</p>
<p>$\begin{flalign*}<br>
&amp;C_T = C_0 + N(C_{_{BK}}) - 12 \<br>
&amp;C_T = 4 + 3000(20) - 12 \<br>
&amp;C_T = 599992<br>
\end{flalign*}$</p>
<p>然后计算外循环:</p>
<p>$\begin{flalign*}<br>
&amp;C_T = C_0 + N(C_{BK}) - 12 \<br>
&amp;C_T = 4 + 30000(59992 + 2 + 16) - 12 \<br>
&amp;C_T = 1.8 \times 10^{10} \text{ Clock cycles}<br>
\end{flalign*}$</p>
<p>实际上程序只花了15s来运行, 计算出来的时钟频率是1200MHz, 是目标机器的时钟频率(300MHz)的4倍,原因是现代处理器使用 <strong>指令并行</strong> 技术</p>
<h3>打印数字</h3>
<p>基于栈的实现:</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">.MODEL medium</span>
<span class="pl-en">.STACK</span>
<span class="pl-en">.DATA</span>
<span class="pl-en">ten db </span><span class="pl-c1">10</span>
<span class="pl-en">.CODE</span>
<span class="pl-en">.STARTUP</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">12345</span>
<span class="pl-k">call</span><span class="pl-en"> Print</span>
<span class="pl-en">.EXIT</span>

<span class="pl-en">Print:</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-c">        ; 函数调用, 储存原来寄存器的值, 固定操作</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">cx</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">dx</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">5</span><span class="pl-c">      ; 初始化循环计数器为 5</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">10000</span>

<span class="pl-en">again:</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">0h</span><span class="pl-c">     ; 除法前清空 dx</span>
<span class="pl-en">    </span><span class="pl-k">div</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-c">         ; dx:ax /= bx</span>
<span class="pl-en">    </span><span class="pl-k">or</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">030h</span><span class="pl-c">    ; 数字转 ASCII</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-c">        ; 保存余数</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dl</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-c">     ; 传参给 21h 中断</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">02h</span><span class="pl-c">    ; 输出字符模式</span>
<span class="pl-en">    </span><span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">021h</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">0h</span><span class="pl-c">     ; 除法前清空 dx</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-c">     ; bx /= 10</span>
<span class="pl-en">    </span><span class="pl-k">div</span><span class="pl-en"> ten</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">ax</span>
<span class="pl-en">    </span><span class="pl-k">loop</span><span class="pl-en"> again</span><span class="pl-c">     ; cx 自动减 1, 不为 0 则跳转</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-c">         ; 函数调用结束, 恢复原来寄存器的值, 固定操作</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">cx</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">bx</span>
<span class="pl-en">    </span><span class="pl-k">ret</span>

<span class="pl-en">END</span></pre></div>
<hr>
<h2>Lecture 5: 汇编语言 (Ⅳ)</h2>
<h3>打印负数</h3>
<h4>负数打印的原理</h4>
<ul>
<li><strong>符号判断</strong>：程序首先检查数值符号位，判断是否为负数。</li>
<li><strong>负号输出</strong>：若为负数，则先输出负号 <code class="notranslate">-</code>。</li>
<li><strong>取绝对值</strong>：对负数取反加一，转换为正数进行打印处理。</li>
</ul>
<h4>打印负数的汇编代码实现</h4>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">.MODEL medium</span>
<span class="pl-en">.STACK</span>
<span class="pl-en">.DATA</span>
<span class="pl-en">ten word </span><span class="pl-c1">10</span>
<span class="pl-en">    .CODE</span>
<span class="pl-en">    .STARTUP</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">32768</span><span class="pl-c">  ; 将要打印的数值 (示例为 -32768 的补码表示) 放入 AX 寄存器</span>
<span class="pl-en">    </span><span class="pl-k">call</span><span class="pl-en"> Print</span><span class="pl-c">     ; 调用 Print 子程序进行打印</span>
<span class="pl-en">    .EXIT</span>

<span class="pl-c">; Print 子程序：负责将 AX 寄存器中的数值以十进制形式打印到屏幕</span>
<span class="pl-en">Print:</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-c">       ; 保护寄存器 BX, CX, DX 的值</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">cx</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">dx</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">5</span><span class="pl-c">       ; 设置循环次数为 5，用于打印五位十进制数</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">10000</span><span class="pl-c">   ; BX 寄存器设置为 10000，用于取出万位数字</span>
<span class="pl-en">    </span><span class="pl-k">test</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">8000h</span><span class="pl-c">  ; 检测 AX 寄存器的最高位 (符号位)</span>
<span class="pl-en">    </span><span class="pl-k">jz</span><span class="pl-en"> Positive</span><span class="pl-c">     ; 如果符号位为 0 (正数)，跳转到 Positive 标签</span>
<span class="pl-c">    ; 如果是负数，执行以下代码：</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-c">       ; 暂时保存 AX 的值</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">02h</span><span class="pl-c">   ; 设置 DOS 功能号为 02h (显示字符)</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dl</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s">'-'</span><span class="pl-c">   ; 将 '-' 字符的 ASCII 码放入 DL 寄存器</span>
<span class="pl-en">    </span><span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">021h</span><span class="pl-c">      ; 调用 DOS 中断 21h，显示 '-' 字符</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-c">        ; 恢复 AX 寄存器的值 (负数)</span>
<span class="pl-en">    </span><span class="pl-k">not</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-c">        ; AX 取反 (按位非)</span>
<span class="pl-en">    </span><span class="pl-k">add</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">1</span><span class="pl-c">     ; AX 加 1，得到负数的绝对值 (补码转原码)</span>
<span class="pl-en">    </span><span class="pl-k">jmp</span><span class="pl-en"> Positive</span><span class="pl-c">    ; 跳转到 Positive 标签，打印绝对值</span>

<span class="pl-c">; Positive 标签：处理正数和负数的绝对值打印</span>
<span class="pl-en">Positive:</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">0h</span><span class="pl-c">    ; DX 寄存器清零，为除法运算做准备</span>
<span class="pl-en">    </span><span class="pl-k">div</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-c">        ; AX 除以 BX (10000)，商在 AX，余数在 DX。这里用于取出万位数字，但第一次循环BX是10000，实际是取最高位</span>
<span class="pl-en">    </span><span class="pl-k">or</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">030h</span><span class="pl-c">   ; 将 AL 寄存器的值与 30h (字符 '0' 的 ASCII 码) 进行按位或运算，将数字转换为 ASCII 字符</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-c">       ; 余数 DX 入栈，暂存个位/十位/百位/千位数字，后续会依次出栈打印</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dl</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-c">    ; 将个位数字的 ASCII 码放入 DL 寄存器</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">02h</span><span class="pl-c">   ; 设置 DOS 功能号为 02h (显示字符)</span>
<span class="pl-en">    </span><span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">021h</span><span class="pl-c">      ; 调用 DOS 中断 21h，显示当前数字字符</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">0h</span><span class="pl-c">    ; DX 寄存器清零，为下一次除法运算做准备</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-c">    ; 将 BX 的值 (当前的除数，初始为 10000) 复制到 AX</span>
<span class="pl-en">    </span><span class="pl-k">div</span><span class="pl-en"> ten</span><span class="pl-c">       ; AX 除以 ten (10)，结果商在 AX，余数在 DX。用于将除数降一位 (10000 -&gt; 1000 -&gt; 100 -&gt; 10 -&gt; 1)</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-c">    ; 将新的除数 (缩小 10 倍) 更新到 BX 寄存器</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-c">        ; 从栈中弹出之前暂存的余数到 AX，为下一次循环做准备 (实际上这里pop出来的是上一次div的余数，但是后面又被mov dx, 0h覆盖了，应该pop到dx才对，这里代码有误)</span>
<span class="pl-en">    </span><span class="pl-k">loop</span><span class="pl-en"> Positive</span><span class="pl-c">   ; 循环 CX 次，打印剩余的数字</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-c">        ; 恢复寄存器 DX, CX, BX 的值</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">cx</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">bx</span>
<span class="pl-en">    </span><span class="pl-k">ret</span><span class="pl-c">           ; 子程序返回</span>
<span class="pl-en">END</span></pre></div>
<h3>字符串</h3>
<h4>字符串的定义</h4>
<p><strong>字符串</strong> (String) 是一组用于描述文本的 <strong>ASCII(美国信息交换标准代码)</strong> 字符序列。在汇编语言中，字符串通常以不同的方式进行定义和存储，常见的表示方法包括：</p>
<ul>
<li><strong>NULL 结尾字符串</strong>：以 <strong>NULL 字节</strong> (数值为 0 的字节) 作为字符串的结束符。例如 <code class="notranslate">"Charles Markham /0"</code>。这种方式简单直观，但需要遍历字符串才能确定其长度。</li>
<li><strong>长度前缀字符串</strong>：字符串的第一个字节用于存储字符串的长度，后续字节存储字符串的内容。例如 <code class="notranslate">"/15 Charles Markham"</code>，其中 <code class="notranslate">/15</code> 表示字符串长度为 15。这种方式可以快速获取字符串长度，但限制了字符串的最大长度 (因为长度信息通常只用一个字节存储) 。</li>
</ul>
<h4>字符串的存储方式</h4>
<ul>
<li><strong>连续内存空间</strong>：字符串的字符在内存中是连续存储的，以便于程序进行访问和操作。</li>
<li><strong>ASCII 编码</strong>：每个字符都使用 ASCII 编码表示，占用一个字节的存储空间。</li>
</ul>
<h3>字符串操作</h3>
<h4><code class="notranslate">LEA</code> 命令：加载有效地址</h4>
<p><code class="notranslate">LEA</code> (<strong>Load Effective Address</strong>) 命令用于将<strong>有效地址</strong>加载到指定的寄存器中，常用于获取变量或内存地址。</p>
<ul>
<li>
<p><strong>功能</strong>：将源操作数 (通常是内存地址) 的有效地址传送给目的操作数 (寄存器) 。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">msg1 db </span><span class="pl-s">"Hello, world.$"</span><span class="pl-c"> ; 定义字符串 msg1</span>
<span class="pl-k">lea</span><span class="pl-en"> </span><span class="pl-v">SI</span><span class="pl-s1">,</span><span class="pl-en"> msg1</span><span class="pl-c">          ; 将 msg1 的有效地址加载到 SI 寄存器</span></pre></div>
<p><strong>说明</strong>：上述代码中，<code class="notranslate">lea SI, msg1</code> 将 <code class="notranslate">msg1</code> 字符串在内存中的起始地址加载到 <strong>SI(源变址寄存器)</strong> 寄存器中。此时，SI 寄存器就指向了字符串 <code class="notranslate">msg1</code> 的首地址。</p>
</li>
</ul>
<h4><code class="notranslate">MOVSB</code> 命令：移动字符串字节</h4>
<p><code class="notranslate">MOVSB</code> (<strong>Move String Byte</strong>) 命令用于将数据从源地址复制到目标地址，以字节为单位进行操作。</p>
<ul>
<li>
<p><strong>功能</strong>：将 <strong>DS:SI</strong> 寄存器指向的内存地址中的一个字节数据复制到 <strong>ES:DI</strong> 寄存器指向的内存地址。</p>
</li>
<li>
<p><strong>寄存器影响</strong>：执行 <code class="notranslate">MOVSB</code> 指令后，<strong>SI(源变址寄存器)</strong> 和 <strong>DI(目的变址寄存器)</strong> 寄存器的值会自动递增或递减，递增或递减的方向由 <strong>DF(方向标志位)</strong> 决定。</p>
<ul>
<li>当 DF = 0 时，SI 和 DI 递增 (正向复制) 。</li>
<li>当 DF = 1 时，SI 和 DI 递减 (反向复制) 。</li>
</ul>
</li>
<li>
<p><strong>应用场景</strong>：常用于字符串复制、内存块移动等操作。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">msg1 db </span><span class="pl-s">"Hello$"</span><span class="pl-c">  ; 源字符串 msg1</span>
<span class="pl-en">msg2 db </span><span class="pl-s">"     $"</span><span class="pl-c">  ; 目标字符串 msg2，预留空间</span>

<span class="pl-k">lea</span><span class="pl-en"> </span><span class="pl-v">SI</span><span class="pl-s1">,</span><span class="pl-en"> msg1</span><span class="pl-c">      ; SI 指向源字符串 msg1 的首地址</span>
<span class="pl-k">lea</span><span class="pl-en"> </span><span class="pl-v">DI</span><span class="pl-s1">,</span><span class="pl-en"> msg2</span><span class="pl-c">      ; DI 指向目标字符串 msg2 的首地址</span>

<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">5</span><span class="pl-c">         ; 设置循环次数为 5，表示要复制的字节个数</span>
<span class="pl-k">cld</span><span class="pl-c">               ; 清除方向标志位 DF，设置正向复制 (SI, DI 递增)</span>
<span class="pl-k">rep</span><span class="pl-en"> </span><span class="pl-k">movsb</span><span class="pl-c">         ; 重复执行 MOVSB 指令 CX 次，完成字符串复制</span></pre></div>
<p><strong>说明</strong>：这段代码使用 <code class="notranslate">MOVSB</code> 命令将 <code class="notranslate">msg1</code> 的前 5 个字节复制到 <code class="notranslate">msg2</code> 中。<code class="notranslate">rep</code> (<strong>repeat</strong>)  前缀使得 <code class="notranslate">MOVSB</code> 指令重复执行 <code class="notranslate">CX</code> 次，<code class="notranslate">cld</code> (<strong>clear direction flag</strong>) 指令清除方向标志位 DF，确保复制过程地址递增。</p>
</li>
</ul>
<h4><code class="notranslate">CMPSB</code> 命令：比较字符串字节</h4>
<p><code class="notranslate">CMPSB</code> (<strong>Compare String Byte</strong>) 命令用于比较两个字符串中的字节。</p>
<ul>
<li>
<p><strong>功能</strong>：比较 <strong>DS:SI</strong> 寄存器指向的字节和 <strong>ES:DI</strong> 寄存器指向的字节。</p>
</li>
<li>
<p><strong>标志位影响</strong>：根据比较结果设置 <strong>标志寄存器</strong> 中的标志位，例如 <strong>ZF(零标志位)</strong>、<strong>SF(符号标志位)</strong> 等。</p>
<ul>
<li>若两个字节相等，则 ZF = 1。</li>
<li>若不相等，则 ZF = 0。</li>
</ul>
</li>
<li>
<p><strong>寄存器影响</strong>：执行 <code class="notranslate">CMPSB</code> 指令后，SI 和 DI 寄存器的值也会根据 DF 的值自动递增或递减。</p>
</li>
<li>
<p><strong>应用场景</strong>：常用于字符串比较、查找等操作。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">msg1 db </span><span class="pl-s">"Hello$"</span><span class="pl-c"> ; 第一个字符串 msg1</span>
<span class="pl-en">msg2 db </span><span class="pl-s">"Hello$"</span><span class="pl-c"> ; 第二个字符串 msg2</span>

<span class="pl-k">lea</span><span class="pl-en"> </span><span class="pl-v">SI</span><span class="pl-s1">,</span><span class="pl-en"> msg1</span><span class="pl-c">     ; SI 指向字符串 msg1 的首地址</span>
<span class="pl-k">lea</span><span class="pl-en"> </span><span class="pl-v">DI</span><span class="pl-s1">,</span><span class="pl-en"> msg2</span><span class="pl-c">     ; DI 指向字符串 msg2 的首地址</span>

<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">5</span><span class="pl-c">        ; 设置循环次数为 5，表示要比较的字节个数</span>
<span class="pl-k">cld</span><span class="pl-c">              ; 清除方向标志位 DF，设置正向比较 (SI, DI 递增)</span>
<span class="pl-k">rep</span><span class="pl-en"> cmpsb</span><span class="pl-c">        ; 重复执行 CMPSB 指令 CX 次，比较字符串</span>
<span class="pl-k">jz</span><span class="pl-en"> equal</span><span class="pl-c">         ; 如果 ZF = 1 (比较结果相等)，跳转到 equal 标签</span>
<span class="pl-k">jmp</span><span class="pl-en"> not_equal</span><span class="pl-c">    ; 如果 ZF = 0 (比较结果不相等)，跳转到 not_equal 标签</span>

<span class="pl-en">equal:</span>
<span class="pl-c">  ; 字符串相等时执行的代码</span>
<span class="pl-en">not_equal:</span>
<span class="pl-c">  ; 字符串不相等时执行的代码</span></pre></div>
<p><strong>说明</strong>：这段代码使用 <code class="notranslate">CMPSB</code> 命令比较 <code class="notranslate">msg1</code> 和 <code class="notranslate">msg2</code> 的前 5 个字节。<code class="notranslate">rep cmpsb</code> 会重复比较 <code class="notranslate">CX</code> 次，并根据比较结果设置标志位。<code class="notranslate">jz</code> (<strong>jump if zero</strong>) 指令检查 ZF 标志位，判断比较结果是否相等。</p>
</li>
</ul>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>REP(Repeat)</strong> 修饰符可以放在多种字符串指令 (如 <code class="notranslate">MOVSB</code>, <code class="notranslate">CMPSB</code>, <code class="notranslate">STOSB</code>, <code class="notranslate">LODSB</code> 等) 的前面，用于重复执行该指令 <code class="notranslate">CX</code> 次.<code class="notranslate">REP</code> 代表 <strong>重复字符串前缀</strong>，它可以简化循环控制，提高字符串操作的效率。</p>
</div>
<p><a id="user-content-cisc vs risc"></a></p>
<h4>CISC 与 RISC 指令集对比</h4>
<p><code class="notranslate">MOVSB</code> 和 <code class="notranslate">CMPSB</code> 等字符串操作指令是 <strong>CISC(复杂指令集计算机)</strong> 架构的特点之一。为了更好理解 CISC 的特点，以下进行 CISC 和 <strong>RISC(精简指令集计算机)</strong> 的对比：</p>
<ul>
<li>
<p><strong>CISC (复杂指令集计算机)</strong>：</p>
<ul>
<li>
<p><strong>定义</strong>：<strong>复杂指令集计算机</strong> (Complex Instruction Set Computer) 是一种微处理器指令集架构，其特点是指令数量众多且功能复杂，每条指令可以执行多个低级操作，例如从存储器读取、存储、计算等，都集成在一条指令中。</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li>指令数目多而复杂。</li>
<li>每条指令的长度不固定。</li>
<li>计算机需要进行指令解码和判读，增加了硬件设计的复杂性和性能开销。</li>
</ul>
</li>
<li>
<p><strong>代表架构</strong>：x86、AMD Opteron 等。维基百科对 CISC 的描述如下：</p>
<blockquote>
<p><strong>复杂指令集计算机</strong> (英语: Complex Instruction Set Computer；缩写: <strong>CISC</strong>) 是一种微处理器指令集架构, 每个指令可执行若干低端操作, 诸如从存储器读取、存储、和计算操作, 全部集于单一指令之中与之相对的是<strong>精简指令集</strong></p>
<p>复杂指令集的特点是指令数目多而复杂, 每条指令字长并不相等, 电脑必须加以判读, 并为此付出了性能的代价</p>
<p>属于复杂指令集的处理器有 CDC 6600、System/360、VAX、PDP-11、Motorola 68000家族、x86、AMD Opteron 等</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>RISC (精简指令集计算机)</strong>：</p>
<ul>
<li><strong>定义</strong>：<strong>精简指令集计算机</strong> (Reduced Instruction Set Computer) 架构，其特点是指令集精简，指令数量较少，每条指令只完成单一、基本的操作。复杂的操作通常由多条简单指令组合完成。</li>
<li><strong>特点</strong>：
<ul>
<li>指令数量少且简单。</li>
<li>指令长度固定。</li>
<li>硬件设计相对简单，指令执行效率高。</li>
</ul>
</li>
<li><strong>代表架构</strong>：ARM、MIPS 等。</li>
</ul>
</li>
</ul>
<h3>浮点数</h3>
<h4>浮点数的概念</h4>
<p><strong>浮点数</strong> (Floating-point Number) 是一种用<strong>科学计数法</strong>表示实数的方式，用于在计算机中存储和处理小数或非常大/小的数值。浮点数表示方法通常包含三个关键组成部分：</p>
<ul>
<li><strong>符号位 (Sign)</strong>：用于表示数值的正负，通常 0 表示正数，1 表示负数。</li>
<li><strong>指数位 (Exponent)</strong>：用于表示数值的<strong>数量级</strong>或<strong>小数点的位置</strong>。指数位决定了数值的大小范围。</li>
<li><strong>尾数位 (Mantissa 或 Fraction)</strong>：用于表示数值的<strong>精度</strong>，即小数点后的有效数字。尾数位决定了数值的精确程度。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/2d839443ebf1bb2d25f6f631c7168193d763b5d21e2c8e1edf79f802cb5a9560/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31372f716f39785335794a4458736c4f47702e706e67"><img src="https://camo.githubusercontent.com/2d839443ebf1bb2d25f6f631c7168193d763b5d21e2c8e1edf79f802cb5a9560/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31372f716f39785335794a4458736c4f47702e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/17/qo9xS5yJDXslOGp.png" style="max-width: 100%;"></a></p>
<h4>浮点数的通用表示形式</h4>
<p>浮点数的通用数学表示形式为：</p>
<p>$\text{Value} = (-1)^{\text{Sign}} \times \text{Mantissa} \times 2^{\text{Exponent}}$</p>
<h4>规格化浮点数</h4>
<p><strong>规格化浮点数</strong> (Normalized Floating-point Number) 是 <strong>IEEE 754 标准</strong> 中最常用的一种浮点数表示形式。</p>
<ul>
<li><strong>特点</strong>：<strong>尾数位 (Mantissa)</strong> 的最高位<strong>隐含为 1</strong>，即尾数的整数部分总是 1。由于最高位固定为 1，因此在存储时可以省略这一位，从而节省一个比特的存储空间，提高精度。</li>
</ul>
<h4>规格化浮点数的表示方法</h4>
<ul>
<li><strong>尾数 (Mantissa)</strong>：只存储<strong>小数部分</strong>，整数部分的 <code class="notranslate">1</code> 是隐含的。</li>
<li><strong>指数 (Exponent)</strong>：存储经过<strong>偏移量 (Bias)</strong> 调整后的指数值。对于单精度浮点数，偏移量 Bias 通常为 127；对于双精度浮点数，偏移量 Bias 通常为 1023。指数位不能全为 0 或全为 1 (这两种情况有特殊用途，见下文) 。
<ul>
<li><strong>单精度浮点数指数范围</strong>：1 到 254 (实际指数范围为 -126 到 127)</li>
<li><strong>双精度浮点数指数范围</strong>：1 到 2046 (实际指数范围为 -1022 到 1023)</li>
</ul>
</li>
</ul>
<h4>规格化浮点数的计算公式</h4>
<p>$\text{Value} = (-1)^{\text{Sign}} \times 1.\text{Mantissa} \times 2^{\text{Exponent} - \text{Bias}}$</p>
<h4>规格化浮点数示例</h4>
<p><strong>单精度浮点数示例</strong>：</p>
<p>假设有一个单精度浮点数，其二进制表示为：</p>
<ul>
<li><strong>符号位 (Sign)</strong>: <code class="notranslate">0</code> (表示正数)</li>
<li><strong>指数位 (Exponent)</strong>: <code class="notranslate">10000001</code> (二进制) = 129 (十进制)。偏移量 Bias = 127，实际指数 = 129 - 127 = 2。</li>
<li><strong>尾数位 (Mantissa)</strong>: <code class="notranslate">10100000000000000000000</code> (二进制)。隐含前导 <code class="notranslate">1</code>，实际尾数为 <code class="notranslate">1.101</code> (二进制)。</li>
</ul>
<p><strong>计算数值</strong>：</p>
<p>$\text{Value} = 1.101_2 \times 2^{2} = 110.1_2 = 6.5_{10}$</p>
<h4>非规格化浮点数</h4>
<p><strong>非规格化浮点数</strong> (Denormalized Floating-point Number) 用于表示<strong>非常接近于零</strong>的数值，其特点是尾数部分的最高位<strong>不隐含为 1</strong>，而是显式表示。</p>
<ul>
<li><strong>应用场景</strong>：用于解决规格化浮点数无法表示零值以及接近零的小数值的问题，扩展了浮点数可以表示的数值范围，使其更接近零。</li>
</ul>
<h4>非规格化浮点数的表示方法</h4>
<ul>
<li><strong>尾数 (Mantissa)</strong>：<strong>没有隐含的前导 1</strong>，实际存储的就是完整的小数部分。</li>
<li><strong>指数 (Exponent)</strong>：<strong>指数位全为 0</strong>。
<ul>
<li><strong>单精度浮点数指数位</strong>：<code class="notranslate">00000000</code> (二进制) = 0 (十进制)</li>
<li><strong>双精度浮点数指数位</strong>：<code class="notranslate">00000000000</code> (二进制) = 0 (十进制)</li>
</ul>
</li>
</ul>
<h4>非规格化浮点数的计算公式</h4>
<p>$\text{Value} = (-1)^{\text{Sign}} \times 0.\text{Mantissa} \times 2^{1 - \text{Bias}}$</p>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>非规格化浮点数的指数部分固定为 <code class="notranslate">1 - Bias</code>，而不是 <code class="notranslate">0 - Bias</code>，这是 IEEE 754 标准的规定，目的是为了平滑地过渡到规格化浮点数。</p>
</div>
<h4>非规格化浮点数示例</h4>
<p><strong>单精度浮点数示例</strong>：</p>
<p>假设有一个单精度非规格化浮点数，其二进制表示为：</p>
<ul>
<li><strong>符号位 (Sign)</strong>: <code class="notranslate">0</code> (表示正数)</li>
<li><strong>指数位 (Exponent)</strong>: <code class="notranslate">00000000</code> (二进制) = 0 (十进制)。偏移量 Bias = 127，实际指数固定为 <code class="notranslate">1 - 127 = -126</code>。</li>
<li><strong>尾数位 (Mantissa)</strong>: <code class="notranslate">00000000000000000000001</code> (二进制)。没有隐含前导 <code class="notranslate">1</code>，实际尾数为 <code class="notranslate">0.00000000000000000000001</code> (二进制)。</li>
</ul>
<p><strong>计算数值</strong>：</p>
<p>$\text{Value} = 0.00000000000000000000001_2 \times 2^{-126} \approx 1.4 \times 10^{-45}$</p>
<p><a href="https://www.bilibili.com/video/BV1VK4y1f7o6/" rel="nofollow">【CSAPP-深入理解计算机系统】2-4.浮点数(上)</a></p>
<p><a href="https://www.bilibili.com/video/BV1zK4y1j7Cn" rel="nofollow">【CSAPP-深入理解计算机系统】2-4.浮点数(下)</a></p>
<h3>浮点数的计算</h3>
<h4>浮点数加减运算的原则</h4>
<p><strong>浮点数加减运算</strong> 遵循 <strong>先对齐，再计算</strong> 的原则。</p>
<ul>
<li><strong>对齐</strong>：指的是<strong>对齐指数位</strong>。当两个浮点数进行加减运算时，如果它们的<strong>指数位 (Exponent)</strong> 不相同，需要先进行<strong>对阶</strong>操作，将它们的指数位对齐到相同的数量级。
<ul>
<li><strong>对阶原则</strong>：通常将<strong>较小的指数</strong>对齐到<strong>较大的指数</strong>。</li>
<li><strong>对阶方法</strong>：将较小指数的浮点数的尾数位<strong>右移</strong>，每右移一位，指数位加 1，直到两个浮点数的指数位相同。尾数右移会降低精度，因此对阶操作可能会导致精度损失。</li>
</ul>
</li>
</ul>
<h4>浮点数加法运算示例</h4>
<p>例如，计算 0.5 与 0.125 的和。</p>
<ol>
<li>
<p><strong>浮点数表示</strong>：</p>
<ul>
<li>0.5 的浮点数表示：$(-1)^0 \times 1.0 \times 2^{-1}$</li>
<li>0.125 的浮点数表示：$(-1)^0 \times 1.0 \times 2^{-3}$</li>
</ul>
</li>
<li>
<p><strong>对阶</strong>：</p>
<ul>
<li>比较指数位：0.5 的指数为 -1，0.125 的指数为 -3。0.5 的指数较大。</li>
<li>对齐指数位：将 0.125 的指数对齐到 -1，需要将指数增加 2 (从 -3 增加到 -1)，尾数位右移 2 位。</li>
<li>对阶后的 0.125 表示：$(-1)^0 \times 0.01 \times 2^{-1}$ (尾数 1.0 右移两位变为 0.01)</li>
</ul>
</li>
<li>
<p><strong>尾数相加</strong>：</p>
<ul>
<li>将对阶后的两个浮点数的尾数部分相加：$1.0 + 0.01 = 1.01$</li>
</ul>
</li>
<li>
<p><strong>结果规格化</strong> (本例中已规格化)：</p>
<ul>
<li>最终结果的浮点数表示：$(-1)^0 \times 1.01 \times 2^{-1}$</li>
</ul>
</li>
<li>
<p><strong>结果转换为十进制</strong>：</p>
<ul>
<li>
$(-1)^0 \times 1.01_2 \times 2^{-1} = 1.01_2 \times 2^{-1} = 0.101_2 = 0.625_{10}$  (此处计算有误，应为0.5 + 0.125 = 0.625，但示例中0.5+0.125=0.625的二进制表示应为0.101，而示例结果1.01 * 2^-1 = 1.01/2 = 0.505，计算过程需要修正)</li>
</ul>
</li>
</ol>
<p><strong>修正后的计算结果</strong>：</p>
<ul>
<li>$1.01_2 \times 2^{-1} = 1.01_2 / 2 = 0.101_2 = 0.5_{10} + 0.125_{10} = 0.625_{10}$</li>
<li>二进制 <code class="notranslate">0.101</code> 转换为十进制为 <code class="notranslate">1*2^-1 + 0*2^-2 + 1*2^-3 = 0.5 + 0 + 0.125 = 0.625</code>。</li>
</ul>
<p>因此，0.5 + 0.125 = 0.625 的浮点数表示为 $(-1)^0 \times 1.01 \times 2^{-1}$。</p>
<h3>8087 数学协处理器</h3>
<blockquote>
<p>处理器都有 CP 了 (╯‵□′)╯︵┻━┻</p>
</blockquote>
<h4>8087 协处理器的概述</h4>
<p><strong>8087 协处理器</strong> (8087 Coprocessor) 是一种<strong>数学协处理器</strong>，也常被称为 <strong>浮点处理器</strong> (Floating-Point Processor) 或 <strong>数字数据处理器 (Numeric Data Processor, NDP)</strong>。</p>
<ul>
<li><strong>作用</strong>：8087 不是一个独立的 <strong>CPU(中央处理器)</strong>，而是作为 <strong>CPU 的辅助单元</strong>，专门用于<strong>加速浮点数运算</strong>。它与 Intel 8086、8088 等 CPU 协同工作，扩展了 CPU 的数值计算能力，尤其是在浮点数运算方面。</li>
<li><strong>历史背景</strong>：在早期计算机系统中，CPU 的浮点运算能力相对较弱，为了提高浮点运算性能，出现了数学协处理器。8087 是 Intel 公司为 8086/8088 处理器设计的协处理器，显著提升了当时计算机的科学计算能力。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ed181f48faa2b8ac3ae0ed9666e79b6a01c5208c2586eba7526c30a6443e8a95/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f6f757172486d3632593339434449342e706e67"><img src="https://camo.githubusercontent.com/ed181f48faa2b8ac3ae0ed9666e79b6a01c5208c2586eba7526c30a6443e8a95/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f6f757172486d3632593339434449342e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/ouqrHm62Y39CDI4.png" style="max-width: 100%;"></a></p>
<h4>8087 的状态字组</h4>
<p><strong>状态字组 (Status Word)</strong> 是 8087 协处理器中的一个寄存器，用于记录浮点运算的状态和异常信息。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/cd28d3e4568d9720ef572b5638811e1c32371b2b41ae25ef499ba60d782f0b67/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f4b566c7641734c785a4439646357522e706e67"><img src="https://camo.githubusercontent.com/cd28d3e4568d9720ef572b5638811e1c32371b2b41ae25ef499ba60d782f0b67/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f4b566c7641734c785a4439646357522e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/KVlvAsLxZD9dcWR.png" style="max-width: 100%;"></a></p>
<ul>
<li><strong>作用</strong>：状态字组中的各个标志位反映了最近一次浮点运算的结果状态，例如是否发生溢出、下溢、除零错误、精度丢失等异常情况，以及运算结果的符号、舍入模式等信息。</li>
<li><strong>程序应用</strong>：程序员可以通过读取状态字组，检查浮点运算是否发生异常，并根据状态信息进行相应的错误处理或流程控制。</li>
</ul>
<h4>8087 的控制字组</h4>
<p><strong>控制字组 (Control Word)</strong> 是 8087 协处理器中的另一个寄存器，用于控制浮点运算的精度、舍入模式、异常处理方式等。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7993327e4a237b0c477bdb312e5bef0fc6053d176c1cc36d0615356ad6ff4c0d/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f556f726374546447737538376569612e706e67"><img src="https://camo.githubusercontent.com/7993327e4a237b0c477bdb312e5bef0fc6053d176c1cc36d0615356ad6ff4c0d/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f556f726374546447737538376569612e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/UorctTdGsu87eia.png" style="max-width: 100%;"></a></p>
<ul>
<li><strong>作用</strong>：通过设置控制字组中的各个控制位，可以配置 8087 的运算行为，例如：
<ul>
<li><strong>精度控制</strong>：设置浮点运算的精度 (单精度、双精度、扩展精度)。</li>
<li><strong>舍入控制</strong>：设置浮点数舍入模式 (例如，舍入到最近偶数、向上舍入、向下舍入、截断舍入)。</li>
<li><strong>异常屏蔽</strong>：屏蔽或使能各种浮点异常 (例如，溢出异常、除零异常、无效操作异常)。</li>
</ul>
</li>
<li><strong>程序应用</strong>：程序员可以根据具体的应用需求，配置控制字组，以满足不同的精度、性能和可靠性要求。</li>
</ul>
<h4>8087 的栈结构</h4>
<p><strong>栈 (Stack)</strong> 是 8087 协处理器内部用于存储浮点数据的存储区域。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7c7e886df980b747ccdf5f2c573a92c4fcd66f639ad105182cc4f55fad24a73f/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f736735684e3861786562564b6f58742e706e67"><img src="https://camo.githubusercontent.com/7c7e886df980b747ccdf5f2c573a92c4fcd66f639ad105182cc4f55fad24a73f/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f736735684e3861786562564b6f58742e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/sg5hN8axebVKoXt.png" style="max-width: 100%;"></a></p>
<ul>
<li><strong>特点</strong>：
<ul>
<li><strong>8 层栈结构</strong>：8087 栈共有 8 个 <strong>寄存器</strong> 位置，每个寄存器可以存储一个 <strong>10 字节</strong> 的扩展精度浮点数。</li>
<li><strong>栈顶指针</strong>：使用 <strong>栈顶指针</strong> (隐式) 来管理栈的push和pop操作。</li>
<li><strong>循环栈</strong>：当新的数据压入栈时，栈顶指针会移动，栈底的数据会被<strong>覆盖</strong>，类似于循环移位操作。</li>
<li><strong>寄存器命名</strong>：在 <strong>MASM 汇编</strong> 代码中，使用 <code class="notranslate">ST(0)</code> 表示<strong>栈顶寄存器</strong>，<code class="notranslate">ST(1)</code> ~ <code class="notranslate">ST(7)</code> 表示栈中其他寄存器，<code class="notranslate">ST(1)</code> 是栈顶的下一个寄存器，以此类推。</li>
</ul>
</li>
</ul>
<h4>8087 常用指令</h4>
<p>8087 提供了丰富的指令集，用于执行各种浮点运算和数据操作。以下列举一些常用的 8087 指令：</p>
<ul>
<li><strong><code class="notranslate">FADD S1/D, S2</code> (浮点加法)</strong>：将两个浮点数 <code class="notranslate">S1</code> 和 <code class="notranslate">S2</code> 相加，结果存储到 <code class="notranslate">D</code> 中 (<code class="notranslate">S1 = D</code>)。
<ul>
<li>如果没有指定 <code class="notranslate">S1</code> 和 <code class="notranslate">S2</code>，则默认操作为 <code class="notranslate">ST(0) += ST(1)</code>，即将栈顶元素 <code class="notranslate">ST(0)</code> 和次栈顶元素 <code class="notranslate">ST(1)</code> 相加，结果覆盖 <code class="notranslate">ST(0)</code>，并将栈顶指针减 1。</li>
</ul>
</li>
<li><strong><code class="notranslate">FSUB S1/D, S2</code> (浮点减法)</strong>：将 <code class="notranslate">S1</code> 减去 <code class="notranslate">S2</code>，结果存储到 <code class="notranslate">D</code> 中 (<code class="notranslate">S1 -= S2</code>)。</li>
<li><strong><code class="notranslate">FSUBR S1/D, S2</code> (反向浮点减法)</strong>：将 <code class="notranslate">S2</code> 减去 <code class="notranslate">S1</code>，结果存储到 <code class="notranslate">D</code> 中 (<code class="notranslate">S1 = S2 - S1</code>)。</li>
<li><strong><code class="notranslate">FMUL S1/D, S2</code> (浮点乘法)</strong>：将 <code class="notranslate">S1</code> 和 <code class="notranslate">S2</code> 相乘。</li>
<li><strong><code class="notranslate">FDIV S1/D, S2</code> (浮点除法)</strong>：将 <code class="notranslate">S1</code> 除以 <code class="notranslate">S2</code>。</li>
<li><strong><code class="notranslate">FMULP</code> (浮点乘法并Pop)</strong>：将栈顶元素 <code class="notranslate">ST(0)</code> 和次栈顶元素 <code class="notranslate">ST(1)</code> 相乘，结果存储到 <code class="notranslate">ST(1)</code>，并将栈顶元素弹出 (栈顶指针减 1)。</li>
<li><strong><code class="notranslate">FIMUL</code> (整数浮点乘法)</strong>：将栈顶元素 <code class="notranslate">ST(0)</code> 与一个整数相乘。</li>
<li><strong><code class="notranslate">FDIVR</code> (反向浮点除法)</strong>：将 <code class="notranslate">S2</code> 除以 <code class="notranslate">S1</code>。</li>
<li><strong><code class="notranslate">FDIVP</code> (浮点除法并Pop)</strong>：将次栈顶元素 <code class="notranslate">ST(1)</code> 除以栈顶元素 <code class="notranslate">ST(0)</code>，结果存储到 <code class="notranslate">ST(1)</code>，并将栈顶元素弹出。</li>
<li><strong><code class="notranslate">FIDIV</code> (整数浮点除法)</strong>：将栈顶元素 <code class="notranslate">ST(0)</code> 除以一个整数。</li>
</ul>
<hr>
<h2>Lecture 6: Assembly Language (V)</h2>
<h3>浮点数计算 —— 毕达哥拉斯问题</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c893599dba3ce1d596b47d6695eded954071f655b34d52c522bf95b76ac2abc1/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31382f794f336b6c4a7670314d54687359442e706e67"><img src="https://camo.githubusercontent.com/c893599dba3ce1d596b47d6695eded954071f655b34d52c522bf95b76ac2abc1/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31382f794f336b6c4a7670314d54687359442e706e67" alt="image-20250118下午94629825" data-canonical-src="https://s2.loli.net/2025/01/18/yO3klJvp1MThsYD.png" style="max-width: 100%;"></a></p>
<p>使用 FP 处理器  (8087 ) 执行上述计算</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">.</span><span class="pl-c1">8087</span><span class="pl-c">                                ; 告诉 MASM 协处理器存在</span>
<span class="pl-en">.MODEL medium</span>
<span class="pl-en">.STACK</span>
<span class="pl-en">.DATA</span>

<span class="pl-en">SX dd </span><span class="pl-c1">5</span><span class="pl-en">.</span><span class="pl-c1">0</span><span class="pl-c">                            ; 定义短实数 (4 字节 ), 初始值为 5.0</span>
<span class="pl-en">SY dd </span><span class="pl-c1">12</span><span class="pl-en">.</span><span class="pl-c1">0</span><span class="pl-c">                           ; 定义短实数 (4 字节 ), 初始值为 12.0</span>
<span class="pl-en">HY dd </span><span class="pl-c1">0</span><span class="pl-en">.</span><span class="pl-c1">0</span><span class="pl-c">                            ; 定义短实数 (4 字节 ), 用于存储结果</span>
<span class="pl-en">cntrl dw </span><span class="pl-c1">03FFh</span><span class="pl-c">                       ; 定义控制字, 用于设置 8087 协处理器的状态</span>
<span class="pl-en">st</span><span class="pl-c1">at</span> <span class="pl-en">dw </span><span class="pl-c1">0</span><span class="pl-c">                            ; 定义状态字, 用于存储 FPU 的状态</span>

<span class="pl-en">.CODE</span>
<span class="pl-en">.STARTUP</span>

<span class="pl-k">FINIT</span><span class="pl-c">                                ; 初始化 FPU, 将其设置为默认状态</span>
<span class="pl-k">FLDCW</span><span class="pl-en"> cntrl</span><span class="pl-c">                          ; 加载控制字, 设置舍入模式为偶数, 并屏蔽中断</span>

<span class="pl-k">FLD</span><span class="pl-en"> SX</span><span class="pl-c">                               ; 将 SX 压入 FPU 栈</span>
<span class="pl-k">FMUL</span><span class="pl-en"> ST</span><span class="pl-s1">,</span><span class="pl-en"> ST(</span><span class="pl-c1">0</span><span class="pl-en">)</span><span class="pl-c">                       ; 将栈顶元素与自身相乘, 结果存储在栈顶</span>
<span class="pl-k">FLD</span><span class="pl-en"> SY</span><span class="pl-c">                               ; 将 SY 压入 FPU 栈</span>
<span class="pl-k">FMUL</span><span class="pl-en"> ST</span><span class="pl-s1">,</span><span class="pl-en"> ST(</span><span class="pl-c1">0</span><span class="pl-en">)</span><span class="pl-c">                       ; 将栈顶元素与自身相乘, 结果存储在栈顶</span>
<span class="pl-k">FADD</span><span class="pl-c">                                 ; 将栈顶的两个数相加</span>
<span class="pl-k">FSQRT</span><span class="pl-c">                                ; 计算栈顶元素的平方根</span>
<span class="pl-k">FSTSW</span><span class="pl-en"> st</span><span class="pl-c1">at</span> <span class="pl-c">                          ; 将 FPU 的状态字加载到 [stat]</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> st</span><span class="pl-c1">at</span> <span class="pl-c">                        ; 将 [stat] 复制到 AX</span>
<span class="pl-k">and</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">0BFh</span><span class="pl-c">                         ; 检查所有 6 个状态位</span>
<span class="pl-k">jnz</span><span class="pl-en"> pass</span><span class="pl-c">                             ; 如果有任何位被设置, 则跳转到 pass</span>
<span class="pl-k">FSTP</span><span class="pl-en"> HY</span><span class="pl-c">                              ; 将栈顶的结果存储到 HY</span>
<span class="pl-k">jmp</span><span class="pl-en"> print</span><span class="pl-c">                            ; 跳转到打印函数</span>

<span class="pl-en">print:</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-s1">,</span><span class="pl-en"> OFFSET HY</span><span class="pl-c">                ; 将 HY 的地址加载到 BX 寄存器</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s1">[</span><span class="pl-v">bx</span><span class="pl-s1">+</span><span class="pl-c1">2</span><span class="pl-s1">]</span><span class="pl-c">                   ; 将 HY+2 的值加载到 AX 寄存器</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">16</span><span class="pl-c">                       ; 设置循环次数为 16</span>
<span class="pl-en">    </span><span class="pl-k">call</span><span class="pl-en"> print_num                  </span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s1">[</span><span class="pl-v">bx</span><span class="pl-s1">]</span><span class="pl-c">                     ; 将 HY 的值加载到 AX 寄存器</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">16</span>
<span class="pl-en">    </span><span class="pl-k">call</span><span class="pl-en"> print_num</span>
<span class="pl-en">    </span><span class="pl-k">jmp</span><span class="pl-en"> pass</span>

<span class="pl-en">print_num:</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-c">                          ; 存储 BX 寄存器</span>
<span class="pl-en">    </span><span class="pl-k">rol</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">1</span><span class="pl-c">                        ; 将 AX 寄存器左移一位</span>
<span class="pl-en">    </span><span class="pl-k">jc</span><span class="pl-en"> set</span><span class="pl-c">                           ; 如果 ZF=1 , 则 DL='1'</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dl</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s">'0'</span><span class="pl-c">                      ; DL='0'</span>
<span class="pl-en">    </span><span class="pl-k">jmp</span><span class="pl-en"> over</span>

<span class="pl-en">set:</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dl</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s">'1'</span>

<span class="pl-en">over:</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-c">                          ; 存储 AX 寄存器</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">02h</span>
<span class="pl-en">    </span><span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">21h</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-c">                           ; 恢复 AX 寄存器</span>
<span class="pl-en">    </span><span class="pl-k">loop</span><span class="pl-en"> print_num</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-c">                           ; 恢复 BX 寄存器</span>
<span class="pl-en">    </span><span class="pl-k">ret</span>

<span class="pl-en">pass: </span>
<span class="pl-en">    </span><span class="pl-k">nop</span>

<span class="pl-c">; 程序结束</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">4Ch</span><span class="pl-c">        ; 设置 AH 为 4Ch (DOS 功能调用: 程序退出 )</span>
<span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">21h</span>

<span class="pl-en">END</span></pre></div>
<p><code class="notranslate">HY</code>在内存中的排列:</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/4501f7e6b9d9bc73e989b47e2205dc2d24006bffa29a8cdc0a040dee7bc8674a/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31382f55486d4c68614f36533542716573622e706e67"><img src="https://camo.githubusercontent.com/4501f7e6b9d9bc73e989b47e2205dc2d24006bffa29a8cdc0a040dee7bc8674a/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31382f55486d4c68614f36533542716573622e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/18/UHmLhaO6S5Bqesb.png" style="max-width: 100%;"></a></p>
<blockquote>
<p>汇编的内容终于结束了 <del>(≧▽≦)/</del></p>
</blockquote>
<hr>
<p>好的，这是根据您的规范重构后的关于半导体的笔记内容：</p>
<h2>Lecture 7: 半导体</h2>
<h3>能级</h3>
<h4>原子能级与固体能带的区别</h4>
<p>原子和固体的能级结构存在显著差异，理解这些差异有助于认识半导体的特性。</p>
<ul>
<li>
<p><strong>原子能级</strong>：</p>
<ul>
<li><strong>离散能级</strong>：在<strong>原子</strong> (Atom) 中，电子的能量是量子化的，只能占据特定的、<strong>离散的能级</strong>。这些能级对应于电子围绕原子核的不同轨道。</li>
<li><strong>能级结构决定性质</strong>：原子的<strong>能级结构</strong> (Energy Level Structure) 直接决定了原子的化学性质和物理性质，例如原子的光谱特性和化学反应活性。</li>
<li><strong>能带的基础</strong>：原子能级结构是理解固体能带结构的基础，原子能级的变化和相互作用最终形成了固体中的能带。</li>
</ul>
</li>
<li>
<p><strong>固体能带</strong>：</p>
<ul>
<li><strong>连续能带</strong>：在<strong>固体</strong> (Solid) 中，由于原子之间的相互作用，原子能级会扩展成<strong>连续的能量带</strong>，称为<strong>能带</strong> (Energy Band)。电子可以在能带内连续地占据不同的能量状态。</li>
<li><strong>电子自由移动</strong>：在固体中，电子不再局限于单个原子，而是在整个固体中相对自由地移动，因此其能量不再是离散的，而是形成能量区间。</li>
<li><strong>能带性质取决于多因素</strong>：<strong>能带的性质</strong> (Band Structure) 取决于多种因素，包括原子间的相互作用强度、晶体结构、化学成分等。</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/2ed61c421f943d699287155414555ad36b5e28e5aef7c0bc2c47b2e77b79dcfb/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f66543248655558476e5759434d31712e706e67"><img src="https://camo.githubusercontent.com/2ed61c421f943d699287155414555ad36b5e28e5aef7c0bc2c47b2e77b79dcfb/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f66543248655558476e5759434d31712e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/fT2HeUXGnWYCM1q.png" style="max-width: 100%;"></a></p>
<h4>能带宽度与材料导电性</h4>
<p>能带理论解释了不同材料的导电性差异，主要通过<strong>禁带宽度</strong>来区分<strong>绝缘体</strong>、<strong>导体</strong>和<strong>半导体</strong>。</p>
<ul>
<li>
<p><strong>绝缘体 (Insulator)</strong>：</p>
<ul>
<li><strong>大禁带宽度</strong>：<strong>绝缘体</strong> (Insulator) 具有非常<strong>宽的禁带</strong>，通常<strong>远大于 1eV</strong>。</li>
<li><strong>难导电</strong>：需要<strong>非常大的能量</strong>才能将电子从<strong>价带</strong> (Valence Band) 激发到<strong>导带</strong> (Conduction Band)，因此在通常条件下，绝缘体几乎不导电。</li>
</ul>
</li>
<li>
<p><strong>导体 (Conductor)</strong>：</p>
<ul>
<li><strong>无禁带或禁带重叠</strong>：<strong>导体</strong> (Conductor) 的<strong>导带</strong>和<strong>价带</strong>之间<strong>没有禁带</strong>，或者能带发生<strong>重叠</strong>。</li>
<li><strong>易导电</strong>：电子可以自由地在能带间移动，<strong>极小的能量</strong>即可使电子进入导带，因此导体很容易导电。</li>
</ul>
</li>
<li>
<p><strong>半导体 (Semiconductor)</strong>：</p>
<ul>
<li><strong>适中禁带宽度</strong>：<strong>半导体</strong> (Semiconductor) 的<strong>禁带宽度适中</strong>，通常在 <strong>1eV 左右</strong>。</li>
<li><strong>导电性可控</strong>：在常温下，半导体的导电性介于导体和绝缘体之间。通过<strong>掺杂</strong>、<strong>光照</strong>、<strong>温度</strong>等外部条件的变化，可以<strong>显著改变半导体的导电性</strong>，这是半导体材料最重要的特性。</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/9328491c5185531ec5be0dc3e67a062bcea08ee414f9da89fb57cbfce3989203/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f3469556575614b7a516e786d4273482e706e67"><img src="https://camo.githubusercontent.com/9328491c5185531ec5be0dc3e67a062bcea08ee414f9da89fb57cbfce3989203/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f3469556575614b7a516e786d4273482e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/4iUeuaKzQnxmBsH.png" style="max-width: 100%;"></a></p>
<h3>P型硅与N型硅</h3>
<p>为了实现半导体的可控导电性，通常需要进行<strong>掺杂</strong>，形成 <strong>P 型半导体</strong> 和 <strong>N 型半导体</strong>。</p>
<h4>P型硅 (P-type Silicon)</h4>
<p><strong>P 型硅</strong> (P-type Silicon) 是通过<strong>掺杂</strong> <strong>三价元素</strong> (如<strong>硼</strong> (Boron)) 到<strong>本征半导体</strong> (Intrinsic Semiconductor) 硅中形成的。</p>
<ul>
<li><strong>掺杂硼</strong>：硼原子最外层有 3 个电子，取代硅晶格中的硅原子后，会<strong>缺少一个电子</strong>，形成一个<strong>空穴</strong> (Hole)。</li>
<li><strong>空穴导电</strong>：<strong>空穴</strong>可以被看作是带正电的载流子，在外电场作用下，空穴可以移动，形成<strong>电流</strong>。因此，P 型硅主要依靠<strong>空穴导电</strong>，空穴是 <strong>多数载流子</strong>，电子是 <strong>少数载流子</strong>。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/85e0475f8bef0bdb1bb5e225a5617765868feffdc3bb843bea820034e98a6cb4/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f7034786b6a38674e36624d6d4850562e706e67"><img src="https://camo.githubusercontent.com/85e0475f8bef0bdb1bb5e225a5617765868feffdc3bb843bea820034e98a6cb4/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f7034786b6a38674e36624d6d4850562e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/p4xkj8gN6bMmHPV.png" style="max-width: 100%;"></a></p>
<h4>N型硅 (N-type Silicon)</h4>
<p><strong>N 型硅</strong> (N-type Silicon) 是通过<strong>掺杂</strong> <strong>五价元素</strong> (如<strong>磷</strong> (Phosphorus)) 到本征半导体硅中形成的。</p>
<ul>
<li><strong>掺杂磷</strong>：磷原子最外层有 5 个电子，取代硅晶格中的硅原子后，会<strong>多出一个电子</strong>。这个多余的电子很容易挣脱原子核的束缚，成为<strong>自由电子</strong> (Free Electron)。</li>
<li><strong>电子导电</strong>：N 型硅中<strong>自由电子浓度</strong>大大增加，在外电场作用下，自由电子定向移动形成电流。因此，N 型硅主要依靠<strong>电子导电</strong>，电子是 <strong>多数载流子</strong>，空穴是 <strong>少数载流子</strong>。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/0935f1424ecfed74a955d617ed0a2a169affeef44fca69efccdc5c110e148f29/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f4a675a34594d4b54483647526d6b752e706e67"><img src="https://camo.githubusercontent.com/0935f1424ecfed74a955d617ed0a2a169affeef44fca69efccdc5c110e148f29/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f4a675a34594d4b54483647526d6b752e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/JgZ4YMKTH6GRmku.png" style="max-width: 100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/2f77079f8f42f5f8b79b3a09a80bde3fc7dedf80d2b0ab5af2ac10e2de56fa4c/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f326d48424b68634f754c52774a38552e706e67"><img src="https://camo.githubusercontent.com/2f77079f8f42f5f8b79b3a09a80bde3fc7dedf80d2b0ab5af2ac10e2de56fa4c/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f326d48424b68634f754c52774a38552e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/2mHBKhcOuLRwJ8U.png" style="max-width: 100%;"></a></p>
<h3>二极管</h3>
<p><strong>二极管</strong> (Diode) 是利用 <strong>PN 结</strong> 的单向导电性制成的半导体器件，是电子电路中最基本和重要的元件之一。</p>
<h4>PN 结的形成</h4>
<p><strong>PN 结</strong> (PN Junction) 形成于 <strong>P 型半导体</strong> 和 <strong>N 型半导体</strong> 的交界面。</p>
<ul>
<li><strong>载流子扩散与复合</strong>：在 P-N 结形成初期，P 区的<strong>空穴</strong>和 N 区的<strong>电子</strong>会自发地向对方<strong>扩散</strong>。在扩散过程中，电子和空穴相遇会发生<strong>复合</strong> (Recombination)，导致<strong>耗尽区</strong> (Depletion Region) 的形成。</li>
<li><strong>耗尽区</strong>：<strong>耗尽区</strong>是指在 P-N 结界面附近，由于载流子复合而<strong>几乎没有自由载流子</strong>的区域。耗尽区内存在由 N 区指向 P 区的<strong>内建电场</strong>，阻碍载流子的进一步扩散。</li>
<li><strong>势垒</strong>：内建电场形成了<strong>势垒</strong>，阻止电子从 N 区流向 P 区，空穴从 P 区流向 N 区。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/03d3196d1a6ab4bb1d59e8ec45c02be4d903e9f1f5346b6177af48ccffc71b46/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f706d5754424955797568636e6651452e706e67"><img src="https://camo.githubusercontent.com/03d3196d1a6ab4bb1d59e8ec45c02be4d903e9f1f5346b6177af48ccffc71b46/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f706d5754424955797568636e6651452e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/pmWTBIUyuhcnfQE.png" style="max-width: 100%;"></a></p>
<h4>PN 结的正向偏置</h4>
<p><strong>正向偏置</strong> (Forward Bias) 是指将<strong>外部电源的正极</strong>连接到 <strong>P 区</strong>，<strong>负极</strong>连接到 <strong>N 区</strong>。</p>
<ul>
<li><strong>耗尽区变窄</strong>：正向电压产生的电场方向与内建电场方向相反，<strong>削弱了势垒</strong>，使得<strong>耗尽区变窄</strong>。</li>
<li><strong>电流导通</strong>：当正向电压超过一定阈值 (<strong>开启电压</strong>或<strong>死区电压</strong>) 后，势垒被克服，大量的电子从 N 区注入 P 区，空穴从 P 区注入 N 区，形成<strong>较大的正向电流</strong>，PN 结<strong>导通</strong>。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/df4b0f5e853700f772484056dc2cd7c1b8c46a74cb41d3b7196bc10eae1f8eb7/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f7a4e625164536c41447238663546572e706e67"><img src="https://camo.githubusercontent.com/df4b0f5e853700f772484056dc2cd7c1b8c46a74cb41d3b7196bc10eae1f8eb7/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f7a4e625164536c41447238663546572e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/zNbQdSlADr8f5FW.png" style="max-width: 100%;"></a></p>
<h4>PN 结的反向偏置</h4>
<p><strong>反向偏置</strong> (Reverse Bias) 是指将<strong>外部电源的正极</strong>连接到 <strong>N 区</strong>，<strong>负极</strong>连接到 <strong>P 区</strong>。</p>
<ul>
<li><strong>耗尽区变宽</strong>：反向电压产生的电场方向与内建电场方向相同，<strong>增强了势垒</strong>，使得<strong>耗尽区变宽</strong>。</li>
<li><strong>电流截止</strong>：势垒进一步增大，阻止了多数载流子的流动。只有少量的<strong>少数载流子</strong> (P 区的电子和 N 区的空穴) 在反向电场作用下漂移，形成<strong>很小的反向饱和电流</strong>，PN 结<strong>截止</strong>。理想情况下，反向电流可以忽略不计。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/55e91a451c0c58ad34ed481d8e614f1ad2e836e448cf8455b0ca5f6b0546c0f0/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f4b6e4c5336515478777256413445442e706e67"><img src="https://camo.githubusercontent.com/55e91a451c0c58ad34ed481d8e614f1ad2e836e448cf8455b0ca5f6b0546c0f0/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f4b6e4c5336515478777256413445442e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/KnLS6QTxwrVA4ED.png" style="max-width: 100%;"></a></p>
<h4>PN 结电流方向与导电方向</h4>
<ul>
<li><strong>电子流动方向</strong>：在正向偏置时，电子从 <strong>N 型硅 -&gt; P 型硅</strong> 流动。</li>
<li><strong>传统电流方向</strong>：<strong>导电方向</strong> (Conventional Current Direction) 与电子流动方向相反，为 <strong>P -&gt; N</strong>。</li>
</ul>
<h4>二极管的伏安特性曲线</h4>
<p><strong>伏安特性曲线</strong> (Current-Voltage Characteristic Curve) 描述了二极管电流随电压变化的规律，体现了二极管的<strong>单向导电性</strong>。</p>
<ul>
<li><strong>正向导通区</strong>：当正向电压超过开启电压后，电流随电压呈<strong>指数增长</strong>。</li>
<li><strong>反向截止区</strong>：当施加反向电压时，只有很小的反向饱和电流，电流<strong>接近于零</strong>。</li>
<li><strong>击穿区</strong>：当反向电压超过<strong>反向击穿电压</strong>时，反向电流会<strong>急剧增大</strong>，二极管可能损坏。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8caa7a05527e116759bee4eb2dcd54328ec331cf5ca23e4b743180b0b2b7d57c/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f41314b674e6d44496b634f353257472e706e67"><img src="https://camo.githubusercontent.com/8caa7a05527e116759bee4eb2dcd54328ec331cf5ca23e4b743180b0b2b7d57c/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f41314b674e6d44496b634f353257472e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/A1KgNmDIkcO52WG.png" style="max-width: 100%;"></a></p>
<h4>二极管的典型应用</h4>
<p><strong>二极管</strong>因其单向导电性，在电路中有着广泛的应用。</p>
<ul>
<li><strong>整流 (Rectification)</strong>：利用二极管的单向导电性，将<strong>交流电 (AC)</strong> 转换为 <strong>直流电 (DC)</strong>。这是二极管最常见的应用之一，例如在电源电路中，将交流电源转换为电子设备所需的直流电源。</li>
<li><strong>电路保护 (Circuit Protection)</strong>：在电路中<strong>反向并联</strong>二极管，可以<strong>限制电压</strong>，<strong>防止过电压</strong>或<strong>极性错误</strong>对敏感元件的损坏。例如，在继电器线圈两端反向并联二极管，可以吸收断电时产生的反向感应电动势，保护开关器件。</li>
<li><strong>逻辑电路 (Logic Circuits)</strong>：可以利用二极管的开关特性，搭建各种<strong>逻辑门电路</strong>，例如<strong>与门</strong>、<strong>或门</strong>等。早期的计算机中曾使用二极管逻辑门，但由于体积大、功耗高等缺点，已被晶体管逻辑门取代。</li>
</ul>
<hr>
<h2>Lecture 8: 晶体管与场效应管</h2>
<h3>结型晶体管 (BJT)</h3>
<h4>结型晶体管的结构与原理</h4>
<p><strong>结型晶体管 (Bipolar Junction Transistor, BJT)</strong>，俗称<strong>三极管</strong>，是一种<strong>电流控制电流</strong>型的半导体器件，常用于放大和开关电路中。NPN 型晶体管是最常见的 BJT 类型之一，它由三个区域构成：</p>
<ul>
<li><strong>发射极 (Emitter, E)</strong>：晶体管的<strong>电流注入区</strong>，多数载流子由此注入。</li>
<li><strong>基极 (Base, B)</strong>：晶体管的<strong>控制区</strong>，通过<strong>基极电流</strong>控制<strong>集电极电流</strong>。</li>
<li><strong>集电极 (Collector, C)</strong>：晶体管的<strong>电流收集区</strong>，收集由发射极注入并受基极控制的载流子。</li>
</ul>
<p>BJT 的工作原理可以类比为一个<strong>小阀门</strong>：</p>
<ul>
<li><strong>输入控制</strong>：<strong>基极电流 (I<sub>B</sub>)</strong> 作为输入信号，是一个较小的电流。</li>
<li><strong>输出放大</strong>：<strong>集电极电流 (I<sub>C</sub>)</strong> 作为输出信号，是一个被放大的较大电流。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/2bc5fec10eceb9320971a7048064550a7615b4b20fbd12ab8982c387ce4a6073/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f7846414570623977386c4969326a552e706e67"><img src="https://camo.githubusercontent.com/2bc5fec10eceb9320971a7048064550a7615b4b20fbd12ab8982c387ce4a6073/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f7846414570623977386c4969326a552e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/xFAEpb9w8lIi2jU.png" style="max-width: 100%;"></a></p>
<h4>结型晶体管的电流增益</h4>
<p><strong>电流增益 (Current Gain)</strong> 是衡量 BJT 放大能力的重要参数，通常用符号 <strong>β</strong> (贝塔) 或 <strong>h<sub>FE</sub></strong> 表示。它定义为<strong>集电极电流 (I<sub>C</sub>)</strong> 与 <strong>基极电流 (I<sub>B</sub>)</strong> 之比：</p>
<p>$\beta = \frac{I_C}{I_B}$</p>
<p>公式中：</p>
<ul>
<li><strong>I<sub>C</sub> (集电极电流)</strong>：<strong>输出电流</strong>，流经集电极的电流。</li>
<li><strong>I<sub>B</sub> (基极电流)</strong>：<strong>输入电流</strong>，流经基极的电流。</li>
<li><strong>β (电流增益)</strong>：<strong>电流放大倍数</strong>，无量纲参数，典型 BJT 的 β 值范围为 <strong>20 到 200</strong>，甚至更高。</li>
</ul>
<p><strong>电流增益的计算示例</strong>：</p>
<p>假设：</p>
<ul>
<li>基极电流 I<sub>B</sub> = 1 mA (毫安)</li>
<li>电流增益 β = 100</li>
</ul>
<p>则集电极电流 I<sub>C</sub> 为：</p>
<p>$I_C = \beta \times I_B = 100 \times 1 \text{ mA} = 100 \text{ mA}$</p>
<p><strong>结论</strong>：<strong>1 mA 的输入基极电流</strong> 可以控制 <strong>100 mA 的输出集电极电流</strong>，实现了电流的放大，体现了电流增益的作用。</p>
<h4>基于BJT的或非门 (NOR Gate) 实现</h4>
<p><strong>或非门 (NOR Gate)</strong> 是一种基本的<strong>逻辑门</strong>，其输出为<strong>低电平</strong>，当且仅当<strong>所有输入均为低电平</strong>时；否则输出为<strong>高电平</strong>。使用 NPN 型晶体管可以构建 NOR 门电路。</p>
<p><strong>电路原理</strong>：</p>
<ul>
<li><strong>输入端 (A, B)</strong>：分别连接两个输入信号 I<sub>A</sub> 和 I<sub>B</sub>。</li>
<li><strong>输出端 (Output)</strong>：电路的输出信号。</li>
<li><strong>晶体管 (T)</strong>：NPN 型晶体管作为核心开关元件。</li>
<li><strong>电阻 (R)</strong>：限制电流和提供合适的偏置。</li>
</ul>
<p><strong>工作原理</strong>：</p>
<ul>
<li><strong>输入均为低电平 (I<sub>A</sub> = I<sub>B</sub> = 0)</strong>：
<ul>
<li>此时，基极电流为零，晶体管 <strong>T 处于截止状态</strong>，相当于一个<strong>大电阻</strong>。</li>
<li>电流无法通过晶体管流向 <strong>发射极 (I<sub>E</sub>)</strong>，只能流向 <strong>输出端 (Output)</strong>，因此 <strong>输出为高电平</strong>。</li>
</ul>
</li>
<li><strong>输入至少有一个高电平 (I<sub>A</sub> + I<sub>B</sub> ≠ 0)</strong>：
<ul>
<li>此时，至少有一个基极电流不为零，晶体管 <strong>T 处于导通状态</strong>，相当于一个<strong>小电阻</strong>。</li>
<li>电流主要流经晶体管 <strong>T 到发射极 (I<sub>E</sub>)</strong>，<strong>输出端 (Output) 被短路到地</strong>，因此 <strong>输出为低电平</strong>。</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8ccaab3cbf385798152b9d8a8acf5851bcf77ae27da5df1bdbe9f6f22869acb1/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f5a6a584438777a3273666c6b316d512e706e67"><img src="https://camo.githubusercontent.com/8ccaab3cbf385798152b9d8a8acf5851bcf77ae27da5df1bdbe9f6f22869acb1/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f5a6a584438777a3273666c6b316d512e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/ZjXD8wz2sflk1mQ.png" style="max-width: 100%;"></a></p>
<h3>金属氧化物半导体场效应晶体管 (MOSFET)</h3>
<p><strong>金属氧化物半导体场效应晶体管 (Metal-Oxide-Semiconductor Field-Effect Transistor, MOSFET)</strong> 是一种<strong>电压控制电流</strong>型的半导体器件，相比 BJT，MOSFET 具有<strong>输入阻抗高</strong>、<strong>功耗低</strong>等优点，被广泛应用于<strong>集成电路</strong>中。</p>
<h4>MOSFET 的基本结构</h4>
<p>MOSFET 主要由以下几个部分构成：</p>
<ul>
<li><strong>栅极 (Gate, G)</strong>：通常为<strong>金属层</strong>或<strong>多晶硅层</strong>，通过一层<strong>绝缘层</strong> (通常是<strong>二氧化硅 (SiO<sub>2</sub>)</strong>) 与半导体衬底隔离。栅极电压用于控制沟道的导电性。</li>
<li><strong>源极 (Source, S)</strong>：<strong>电流的注入端</strong>，载流子由此进入沟道。</li>
<li><strong>漏极 (Drain, D)</strong>：<strong>电流的输出端</strong>，载流子由此离开沟道。</li>
<li><strong>衬底 (Body/Substrate, B)</strong>：<strong>半导体基体</strong>，通常是<strong>硅材料</strong>。衬底的电位通常与<strong>源极</strong>或<strong>漏极</strong>相连，在某些 MOSFET 中，衬底也可以作为独立的控制端。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e0ad9ce4ffd67b596a87d80851be1a0b39babc03fafcba8e6eb918295e55fdf3/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f437648627068656b534467354a52792e706e67"><img src="https://camo.githubusercontent.com/e0ad9ce4ffd67b596a87d80851be1a0b39babc03fafcba8e6eb918295e55fdf3/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f437648627068656b534467354a52792e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/CvHbphekSDg5JRy.png" style="max-width: 100%;"></a></p>
<h4>NMOS 场效应晶体管的工作原理</h4>
<p>以 <strong>N 沟道 MOSFET (NMOS)</strong> 为例，说明 MOSFET 的工作原理。</p>
<p><strong>工作原理</strong>：</p>
<ol>
<li>
<p><strong>未施加栅极电压 (V<sub>G</sub> = 0)</strong>：</p>
<ul>
<li>在栅极下方的 <strong>P 型衬底</strong> 中，存在少量<strong>自由电子</strong> (少数载流子) 和大量<strong>空穴</strong> (多数载流子)。</li>
<li>由于没有栅极电压的吸引，自由电子分布稀少，<strong>源极 (S)</strong> 和 <strong>漏极 (D)</strong> 之间<strong>无法形成导电沟道</strong>，器件<strong>截止</strong>。</li>
</ul>
</li>
<li>
<p><strong>施加正向栅极电压 (V<sub>G</sub> &gt; 0)</strong>：</p>
<ul>
<li><strong>电子积累</strong>：正向栅极电压会在栅极下方的 P 型衬底表面<strong>吸引大量的自由电子</strong>。</li>
<li><strong>空穴耗尽</strong>：同时，正向栅极电压会<strong>排斥空穴</strong>，导致栅极下方的空穴浓度降低，形成<strong>耗尽层</strong>。</li>
<li><strong>N 沟道形成</strong>：当栅极电压达到一定阈值后，栅极下方的自由电子<strong>积累到足够多</strong>，在源极和漏极之间形成一条<strong>N 型导电沟道</strong>，称为 <strong>N 沟道 (N-channel)</strong>。</li>
<li><strong>电流导通</strong>：一旦 N 沟道形成，在 <strong>漏极电压 (V<sub>D</sub>)</strong> 的作用下，电子可以从<strong>源极 (S)</strong> 经 <strong>N 沟道</strong> 流向 <strong>漏极 (D)</strong>，形成<strong>漏极电流 (I<sub>D</sub>)</strong>，器件<strong>导通</strong>。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5c2ccf3bbd49b1d0e28e098db489d0d776043b2708c10429a3c8832bc3852cc8/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f48346a31354c4d49775636556557542e706e67"><img src="https://camo.githubusercontent.com/5c2ccf3bbd49b1d0e28e098db489d0d776043b2708c10429a3c8832bc3852cc8/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f48346a31354c4d49775636556557542e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/H4j15LMIwV6UeWT.png" style="max-width: 100%;"></a></p>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>这里MOSFET讲的很抽象，参考<a href="https://www.bilibili.com/video/BV1nL411x7jH/" rel="nofollow">【硬核科普】带你认识CPU第00期——什么是MOSFET</a></p>
</div>
<h3>区分</h3>
<ul>
<li><strong>N 型 (N-channel) MOSFET:</strong>  载流子是<strong>电子 (Electrons)</strong> - 记住 <strong>N 代表 Negative (负)</strong>，电子带负电，需要 <strong>正栅极电压 (Positive Gate Voltage)</strong> 才能导通。</li>
<li><strong>N 型 (N-channel) MOSFET:</strong>  载流子是<strong>空穴 (Holes)</strong> - 记住 <strong>P 代表 Positive (正)</strong>，空穴可以被认为是带正电的，需要 <strong>负栅极电压 (Negative Gate Voltage)</strong> 才能导通。</li>
</ul>
<h3>互补金属氧化物半导体 (CMOS)</h3>
<p><strong>互补金属氧化物半导体 (Complementary Metal-Oxide-Semiconductor, CMOS)</strong> 电路是现代数字电路中最主流的电路形式。CMOS 电路利用 <strong>PMOS (P 沟道 MOSFET)</strong> 和 <strong>NMOS (N 沟道 MOSFET)</strong> 的互补特性，实现低功耗、高性能的逻辑功能。</p>
<h4>CMOS 反相器的工作原理</h4>
<p><strong>CMOS 反相器 (Inverter)</strong> 是 CMOS 电路中最基本的逻辑门，它由一个 <strong>PMOS 管</strong> 和一个 <strong>NMOS 管</strong> 串联组成。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>
<p><strong>输入高电平</strong>：</p>
<ul>
<li>当 <strong>输入端 (A)</strong> 为<strong>高电平</strong>时，<strong>NMOS 管导通</strong>，<strong>PMOS 管截止</strong>。</li>
<li>电路相当于 <strong>输出端 (B) 通过导通的 NMOS 管接地</strong>，因此 <strong>输出为低电平</strong>。</li>
</ul>
</li>
<li>
<p><strong>输入低电平</strong>：</p>
<ul>
<li>当 <strong>输入端 (A)</strong> 为<strong>低电平</strong>时，<strong>PMOS 管导通</strong>，<strong>NMOS 管截止</strong>。</li>
<li>电路相当于 <strong>输出端 (B) 通过导通的 PMOS 管连接到电源 (V<sub>DD</sub>)</strong>，因此 <strong>输出为高电平</strong>。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>：CMOS 反相器实现了<strong>输入与输出电平的反转</strong>，是构成更复杂 CMOS 逻辑门的基础。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e90473ac428f38f22e0f6c862e67c6315c9c793b164cec0f6733416867196d94/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f7842456362515847345244736557502e706e67"><img src="https://camo.githubusercontent.com/e90473ac428f38f22e0f6c862e67c6315c9c793b164cec0f6733416867196d94/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f7842456362515847345244736557502e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/xBEcbQXG4RDseWP.png" style="max-width: 100%;"></a></p>
<hr>
<h2>Lecture 9: I/O</h2>
<h3>I/O</h3>
<h4>I/O 操作与地址空间</h4>
<p><strong>I/O (Input/Output)</strong> 操作是计算机系统中 <strong>CPU (中央处理器)</strong> 与外部设备进行数据交换的关键方式。8086 微处理器架构中，I/O 操作的设计特点包括：</p>
<ul>
<li><strong>独立的 I/O 地址空间</strong>：
<ul>
<li>8086 使用 <strong>20 位地址总线</strong> 用于内存读写，但为 <strong>I/O</strong> 操作划分了 <strong>16 位的 I/O 地址空间</strong>。</li>
<li>这种分离设计允许系统区分<strong>内存访问</strong>和 <strong>I/O 访问</strong>，通过额外的<strong>控制线</strong>进行选择。</li>
</ul>
</li>
<li><strong>端口 (Port)</strong> 的概念：
<ul>
<li><strong>I/O 空间</strong>中的每个位置都被称为 <strong>端口 (Port)</strong>。端口是 CPU 与外部设备通信的接口。</li>
<li>8086 的 16 位 I/O 地址空间，可以映射为 <strong>64K 的 8 位端口 (字节)</strong> 或 <strong>32K 的 16 位端口 (字)</strong>。</li>
</ul>
</li>
<li><strong>指令集差异</strong>：
<ul>
<li>相较于内存控制，用于控制 <strong>I/O 端口</strong> 的汇编指令数量相对较少，体现了 I/O 操作的简洁性。</li>
</ul>
</li>
<li><strong>内存映射 I/O</strong>：
<ul>
<li>值得注意的是，某些硬件设备，例如<strong>屏幕显示</strong>，可能被<strong>映射到内存空间</strong>，而不是传统的 I/O 空间。这种技术称为 <strong>内存映射 I/O (Memory-mapped I/O)</strong>。</li>
</ul>
</li>
</ul>
<h4>常见 I/O 地址示例</h4>
<p>下表列出了一些 <strong>常见 I/O 地址</strong> 及其用途，这些地址在早期的 <strong>IBM PC 兼容机</strong> 中被广泛使用，用于控制各种外围设备：</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="left">地址</th>
<th align="left">名称</th>
<th align="left">方向</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><strong>0x378</strong></td>
<td align="left">Parallel Printer Latch</td>
<td align="left">输出</td>
<td align="left"><strong>并行打印机数据端口</strong>，常用于 <strong>LPT1 (Line Printer 1)</strong>，向打印机发送打印数据.</td>
</tr>
<tr>
<td align="left"><strong>0x37A</strong></td>
<td align="left">Printer Control Latch</td>
<td align="left">输出</td>
<td align="left"><strong>并行打印机控制端口</strong>，常用于 <strong>LPT1</strong>，控制打印机的各种操作，例如初始化、选择打印机等.</td>
</tr>
<tr>
<td align="left"><strong>0x379</strong></td>
<td align="left">Printer Status</td>
<td align="left">输入</td>
<td align="left"><strong>并行打印机状态端口</strong>，常用于 <strong>LPT1</strong>，读取打印机的状态信息，例如是否忙碌、是否有纸等.</td>
</tr>
<tr>
<td align="left"><strong>0x3D9</strong></td>
<td align="left">VDU Colour Register</td>
<td align="left">输出</td>
<td align="left"><strong>视频显示单元 (VDU) 颜色寄存器</strong>，用于设置 <strong>DOS 文本模式</strong> 下的边框颜色.</td>
</tr>
<tr>
<td align="left"><strong>0x278</strong></td>
<td align="left">Parallel Printer Latch</td>
<td align="left">输出</td>
<td align="left"><strong>并行打印机数据端口</strong>，常用于 <strong>LPT2 (Line Printer 2)</strong>，向打印机发送打印数据.</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<h4>总线共享与内存访问周期</h4>
<ul>
<li><strong>总线复用</strong>：由于 8086 处理器硬件引脚数量的限制，<strong>内存地址总线</strong> 和 <strong>数据总线</strong> 实际上是<strong>共享相同的物理引脚</strong>。</li>
<li><strong>控制线区分</strong>：因此，需要额外的<strong>控制线</strong>来区分当前的总线操作是<strong>内存访问</strong>还是 <strong>I/O 数据传输</strong>。</li>
<li><strong>内存访问时序</strong>：8086 完成一次<strong>内存访问周期</strong> 通常需要 <strong>4 个时钟周期</strong>， 步骤如下：
<ol>
<li><strong>周期 1</strong>：CPU 发送<strong>内存地址</strong>到地址总线上。</li>
<li><strong>周期 2-3</strong>：CPU <strong>等待内存响应</strong>，并进行<strong>数据传输</strong> (读取或写入) 。</li>
<li><strong>周期 4</strong>：<strong>结束周期</strong>，完成本次内存访问。</li>
</ol>
</li>
</ul>
<h3>Z80A CPU 架构对比</h3>
<h4>分离总线设计</h4>
<p>与 8086 的总线复用设计不同，<strong>Z80A CPU</strong> 的 <strong>数据总线</strong> 和 <strong>地址总线</strong> 采用了<strong>分离的设计</strong>，拥有独立的引脚，简化了总线控制逻辑，并可能提升总线操作的效率。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8c793589cb9786fe440129e0feb21fb296ee70ae1629a3ed53430f2547e178af/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f5058727476353478386433554144322e706e67"><img src="https://camo.githubusercontent.com/8c793589cb9786fe440129e0feb21fb296ee70ae1629a3ed53430f2547e178af/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f5058727476353478386433554144322e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/PXrtv54x8d3UAD2.png" style="max-width: 100%;"></a></p>
<h4>基于 AND 门的地址解码器</h4>
<p>为了实现<strong>地址解码</strong>，Z80A 系统中使用了几个巨大的 <strong>AND 门</strong> 作为<strong>地址解码器 (Address Decoder)</strong>。</p>
<ul>
<li><strong>地址匹配</strong>：当 <strong>16 个输入信号</strong> 与预设的<strong>设备地址</strong> 完全匹配时，AND 门输出<strong>逻辑真 (高电平)</strong>，否则输出<strong>逻辑假 (低电平)</strong>。</li>
<li><strong>控制线</strong>：系统使用<strong>两根控制线</strong> (图中绿色和紫色线条) 来指示当前操作是<strong>读取</strong>还是<strong>写入</strong>，以及针对哪个设备。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a0c832724122eea66291cc3b9c1b5ffa8e82f4b475d3639a25cbe13e05d83905/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f6f4b43327279456273636b664147312e6a7067"><img src="https://camo.githubusercontent.com/a0c832724122eea66291cc3b9c1b5ffa8e82f4b475d3639a25cbe13e05d83905/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f6f4b43327279456273636b664147312e6a7067" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/oKC2ryEbsckfAG1.jpg" style="max-width: 100%;"></a></p>
<h4>三态缓冲器与数据传输控制</h4>
<p><strong>三态缓冲器 (Tri-state Buffer)</strong> 在 I/O 接口中扮演着重要的角色，用于控制数据流的方向和连接状态。</p>
<ul>
<li><strong>控制信号</strong>：<strong>AND 门</strong> 的输出 (地址匹配结果) 和<strong>两根控制线</strong> 的信号，通过另一个 <strong>AND 门</strong> 组合成<strong>最终的控制信号</strong>。</li>
<li><strong>三态输出</strong>：<strong>三态缓冲器</strong> 具有三种输出状态：<strong>高电平 (1)</strong>, <strong>低电平 (0)</strong>, 和 <strong>高阻态 (High-Z)</strong>。
<ul>
<li>根据 <strong>控制信号</strong> 的状态，三态缓冲器决定是否将 <strong>输入信号</strong> 直接<strong>传输到输出</strong>，或者<strong>切换到高阻态</strong>，相当于断开连接。</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8c2715beb884c4b0ebaeeb549cd3abdfd786a2245b7b10af42eefb0f8924185a/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30352f32332f5143346d39797656446c31584e59722e706e67"><img src="https://camo.githubusercontent.com/8c2715beb884c4b0ebaeeb549cd3abdfd786a2245b7b10af42eefb0f8924185a/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30352f32332f5143346d39797656446c31584e59722e706e67" alt="img" data-canonical-src="https://s2.loli.net/2023/05/23/QC4m9yvVDl1XNYr.png" style="max-width: 100%;"></a></p>
<p>对于<strong>输出操作</strong>，三态缓冲器会被 <strong>D 触发器 (D Flip-Flop)</strong> 替代，用于锁存输出数据。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/4fe7163d5a784022581d95841fd450568bfb3b89ffa4145f44f715a7631c0ba4/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f355157314f706a64377744795436552e6a7067"><img src="https://camo.githubusercontent.com/4fe7163d5a784022581d95841fd450568bfb3b89ffa4145f44f715a7631c0ba4/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f31392f355157314f706a64377744795436552e6a7067" alt="img" data-canonical-src="https://s2.loli.net/2025/01/19/5QW1Opjd7wDyT6U.jpg" style="max-width: 100%;"></a></p>
<h3>汇编语言 I/O 指令</h3>
<h4>OUT 指令：端口输出</h4>
<p><strong>OUT 指令</strong> 用于将数据从 <strong>CPU 寄存器</strong>  (通常是累加器 <code class="notranslate">AL</code>, <code class="notranslate">AX</code>, <code class="notranslate">EAX</code>)  <strong>写入</strong> 到指定的 <strong>I/O 端口</strong>。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">OUT</span><span class="pl-en"> port</span><span class="pl-s1">,</span><span class="pl-en"> acc</span></pre></div>
<ul>
<li><strong>port</strong>:  <strong>I/O 端口地址</strong>，可以是立即数或存储在 DX 寄存器中。</li>
<li><strong>acc</strong>: <strong>累加器</strong> (<code class="notranslate">AL</code>, <code class="notranslate">AX</code>, 或 <code class="notranslate">EAX</code>)，存储着要<strong>输出的数据</strong>。</li>
</ul>
<p><strong>OUT 指令的两种寻址模式</strong>：</p>
<ol>
<li>
<p><strong>立即数模式 (Immediate Mode)</strong>：</p>
<ul>
<li><strong>端口地址</strong> 直接在指令中指定为 <strong>立即数 (0-255)</strong>。</li>
<li><strong>寻址范围限制</strong>： 这种模式<strong>只能访问 256 个端口</strong> (地址范围 00h-FFh)。</li>
</ul>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">OUT</span><span class="pl-en"> </span><span class="pl-c1">30h</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">AL</span><span class="pl-c">  ; 将 AL 寄存器中的 8 位数据写入端口地址 30h</span></pre></div>
</li>
<li>
<p><strong>DX 寄存器模式 (Register Mode)</strong>：</p>
<ul>
<li><strong>端口地址</strong> 存储在 <strong>DX 寄存器</strong> 中。</li>
<li><strong>寻址范围扩展</strong>： 这种模式可以访问 <strong>64K 个端口 (0-65535)</strong>，提供了更大的 I/O 空间访问能力。</li>
</ul>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">0x378</span><span class="pl-c"> ; 将端口地址 0x378 放入 DX 寄存器</span>
<span class="pl-k">OUT</span><span class="pl-en"> </span><span class="pl-v">DX</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">AX</span><span class="pl-c">    ; 将 AX 寄存器中的 16 位数据写入 DX 寄存器指定的端口</span></pre></div>
</li>
</ol>
<h4>IN 指令：端口输入</h4>
<p><strong>IN 指令</strong> 用于从指定的 <strong>I/O 端口</strong> <strong>读取数据</strong> 到 <strong>CPU 寄存器</strong>  (通常是累加器 <code class="notranslate">AL</code>, <code class="notranslate">AX</code>, <code class="notranslate">EAX</code>) 。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">IN</span><span class="pl-en"> acc</span><span class="pl-s1">,</span><span class="pl-en"> port</span></pre></div>
<ul>
<li><strong>acc</strong>: <strong>累加器</strong> (<code class="notranslate">AL</code>, <code class="notranslate">AX</code>, 或 <code class="notranslate">EAX</code>)，用于<strong>存储从端口读取的数据</strong>。</li>
<li><strong>port</strong>: <strong>I/O 端口地址</strong>，可以是立即数或存储在 DX 寄存器中。</li>
</ul>
<p><strong>IN 指令的两种寻址模式</strong>：</p>
<ol>
<li>
<p><strong>立即数模式 (Immediate Mode)</strong>：</p>
<ul>
<li><strong>端口地址</strong> 直接在指令中指定为 <strong>立即数 (0-255)</strong>。</li>
<li><strong>寻址范围限制</strong>： 这种模式<strong>只能访问 256 个端口</strong> (地址范围 00h-FFh)。</li>
</ul>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">IN</span><span class="pl-en"> </span><span class="pl-v">AL</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">30h</span><span class="pl-c">  ; 从端口地址 30h 读取 8 位数据，存储到 AL 寄存器</span></pre></div>
</li>
<li>
<p><strong>DX 寄存器模式 (Register Mode)</strong>：</p>
<ul>
<li><strong>端口地址</strong> 存储在 <strong>DX 寄存器</strong> 中。</li>
<li><strong>寻址范围扩展</strong>： 这种模式可以访问 <strong>64K 个端口 (0-65535)</strong>，提供了更大的 I/O 空间访问能力。</li>
</ul>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">0x379</span><span class="pl-c"> ; 将端口地址 0x379 放入 DX 寄存器</span>
<span class="pl-k">IN</span><span class="pl-en"> </span><span class="pl-v">AX</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">DX</span><span class="pl-c">    ; 从 DX 寄存器指定的端口读取 16 位数据，存储到 AX 寄存器</span></pre></div>
</li>
</ol>
<blockquote>
<p>[!NOTE] I/O 特权级 (IOPL)</p>
<p><strong>IOPL (I/O Privilege Level, I/O 特权级)</strong> 是 <strong>x86 架构</strong> 中用于控制 <strong>I/O 端口访问权限</strong> 的保护机制。它存储在 <strong>EFLAGS 寄存器</strong> 的 <strong>第 12 和 13 位</strong>，定义了程序执行 <strong>I/O 指令</strong>  (如 <code class="notranslate">IN</code>, <code class="notranslate">OUT</code>) 所需的<strong>最低特权级别 (CPL, Current Privilege Level)</strong>。</p>
<p><strong>IOPL</strong> 是一个 <strong>2 位</strong> 的值，取值范围为 <strong>0 到 3</strong>，数值越小特权级别越高：</p>
<ul>
<li><strong>特权级检查</strong>：在执行 I/O 指令时，CPU 会<strong>比较当前程序</strong>的 <strong>CPL</strong> 和 <strong>IOPL</strong>。
<ul>
<li><strong>当 CPL ≤ IOPL 时</strong>：程序<strong>被允许</strong>直接执行 I/O 指令  (如 <code class="notranslate">IN</code>, <code class="notranslate">OUT</code>) ，可以访问 I/O 端口。</li>
<li><strong>当 CPL &gt; IOPL 时</strong>：程序<strong>没有权限</strong>直接执行 I/O 指令。如果尝试执行，会触发 <strong>一般保护异常 (General Protection Fault, #GP)</strong>，导致程序终止或系统崩溃。</li>
</ul>
</li>
</ul>
<p><strong>作用</strong>：IOPL 机制增强了系统的<strong>安全性</strong>和<strong>稳定性</strong>，防止低特权级别的程序非法访问硬件设备，保护系统资源。</p>
</blockquote>
<h3>中断机制</h3>
<h4>中断的引入与优势</h4>
<p><strong>中断 (Interrupt)</strong> 是一种重要的<strong>异步事件处理机制</strong>，允许外部设备或软件事件<strong>打断 CPU 的正常执行流程</strong>，转而处理更紧急或重要的任务。</p>
<p><strong>应用场景</strong>：考虑 CPU 从 <strong>HDD (硬盘驱动器)</strong> 读取数据的场景。</p>
<ul>
<li><strong>传统轮询方式的低效</strong>：若 CPU 采用<strong>轮询 (Polling)</strong> 方式，需要<strong>周期性地查询 HDD</strong> 的状态，等待数据就绪.<strong>HDD 响应速度</strong>通常较慢 (例如<strong>毫秒级</strong>，涉及磁头移动和盘片旋转) ，CPU 在等待期间会<strong>空耗大量的计算资源</strong>。</li>
<li><strong>中断机制的优势</strong>：<strong>中断机制</strong> 提供了更高效的方案。
<ul>
<li><strong>设备主动通知</strong>：当 HDD <strong>数据就绪</strong>时，<strong>主动向 CPU 发送中断信号</strong>。</li>
<li><strong>CPU 响应</strong>：CPU 接收到中断信号后，<strong>暂停当前任务</strong>，<strong>转而处理数据读取操作</strong>。</li>
<li><strong>资源高效利用</strong>：CPU 在 HDD 准备数据的期间，可以<strong>执行其他任务</strong>，<strong>避免了无谓的等待</strong>，提高了系统资源的利用率。</li>
<li><strong>低功耗</strong>：CPU 可以进入<strong>低功耗模式</strong>等待中断，进一步降低能耗。</li>
</ul>
</li>
</ul>
<h4>中断处理流程</h4>
<p><strong>中断发生时的典型处理流程</strong>：</p>
<ol>
<li><strong>暂停当前程序</strong>：CPU <strong>暂停</strong> 当前正在执行的<strong>主程序</strong>。</li>
<li><strong>调用中断处理程序</strong>：CPU <strong>跳转</strong> 到一个专门<strong>服务中断的程序</strong>，称为 <strong>中断处理程序 (Interrupt Handler)</strong> 或 <strong>中断服务例程 (ISR, Interrupt Service Routine)</strong>。</li>
<li><strong>返回主程序</strong>：<strong>中断处理程序执行完毕</strong>后，<strong>将控制权返回</strong> 到之前被中断的<strong>主程序</strong>，从断点处继续执行。</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/156e4ad5bd5394c8afe5af44259370ca9de9c780053f9bea28cb74f3c09f3d38/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30382f597039505236694463747768794b612e706e67"><img src="https://camo.githubusercontent.com/156e4ad5bd5394c8afe5af44259370ca9de9c780053f9bea28cb74f3c09f3d38/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30382f597039505236694463747768794b612e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/08/Yp9PR6iDctwhyKa.png" style="max-width: 100%;"></a></p>
<h4>8086 的中断类型</h4>
<p>8086 架构支持多种类型的中断，可以根据<strong>触发来源</strong>进行分类：</p>
<ul>
<li><strong>硬件中断 (Hardware Interrupt)</strong>：
<ul>
<li>由外部硬件设备通过<strong>处理器的引脚</strong>发出中断请求信号。
<ul>
<li><strong>INTR (Interrupt Request)</strong> 引脚：<strong>可屏蔽中断</strong>，可以通过设置<strong>中断标志位 (IF)</strong> 来<strong>屏蔽</strong>或<strong>使能</strong>。</li>
<li><strong>NMI (Non-Maskable Interrupt)</strong> 引脚：<strong>非可屏蔽中断</strong>，<strong>优先级高于 INTR</strong>，通常用于处理<strong>更紧急的硬件错误</strong>，如电源故障或内存奇偶校验错误。</li>
</ul>
</li>
</ul>
</li>
<li><strong>异常中断 (Exception Interrupt)</strong>：
<ul>
<li>由 <strong>CPU 内部错误</strong> 或<strong>异常条件</strong>触发。</li>
<li>常见的异常包括：<strong>除以零错误</strong>、<strong>非法操作码</strong>、<strong>页错误</strong> 等。</li>
<li><strong>用途</strong>：通常用于<strong>打印错误信息</strong>、<strong>终止程序</strong> 或进行<strong>错误恢复</strong>。</li>
</ul>
</li>
<li><strong>软件中断 (Software Interrupt)</strong>：
<ul>
<li>由程序<strong>主动执行汇编指令 <code class="notranslate">INT</code></strong> 引起。</li>
<li><strong>指令格式</strong>：<code class="notranslate">INT n</code>，其中 <code class="notranslate">n</code> 为<strong>中断号</strong> (0-255)。</li>
<li><strong>用途</strong>：一种<strong>软件请求操作系统服务</strong>的机制，例如 <strong>DOS 系统调用</strong> 就是通过<strong>软件中断</strong> 实现的。可以理解为 <strong>调用 BIOS (基本输入/输出系统) 中的函数</strong>。</li>
</ul>
</li>
</ul>
<h4>时间片轮询调度 vs 抢占式调度</h4>
<p><strong>中断机制</strong> 在操作系统中被广泛用于实现<strong>任务调度</strong>，两种典型的调度方式是 <strong>时间片轮询调度</strong> 和 <strong>抢占式调度</strong>。</p>
<ul>
<li>
<p><strong>时间片轮询调度 (Time Slice Scheduling)</strong>：</p>
<ul>
<li><strong>轮流执行</strong>：操作系统将 <strong>CPU 时间</strong> 划分为<strong>固定长度的时间片</strong> (例如 20ms) 。</li>
<li><strong>任务切换</strong>：操作系统<strong>轮流</strong> 为每个<strong>就绪任务</strong>分配一个时间片，<strong>顺序执行</strong>。当时间片用完，即使任务未完成，也<strong>强制切换</strong>到下一个任务。</li>
<li><strong>硬件轮询</strong>：CPU 通常需要<strong>主动轮询硬件设备</strong> 的状态，以确定是否有 I/O 请求需要处理。</li>
<li><strong>适用场景</strong>：适用于 <strong>简单的多任务系统</strong>。</li>
<li><strong>缺点</strong>：可能存在<strong>资源浪费</strong>，实时性较差。</li>
</ul>
</li>
<li>
<p><strong>抢占式调度 (Pre-emptive Scheduling)</strong>：</p>
<ul>
<li><strong>优先级抢占</strong>：操作系统为每个任务分配<strong>优先级</strong>。<strong>高优先级任务</strong> 可以<strong>中断</strong> 正在执行的<strong>低优先级任务</strong>，<strong>优先获得 CPU 执行权</strong>。</li>
<li><strong>中断驱动</strong>：<strong>硬件设备</strong> 通过<strong>中断</strong> 通知 CPU <strong>I/O 事件</strong> 的发生。</li>
<li><strong>快速响应</strong>：CPU <strong>响应中断</strong> 速度快，能够及时处理外部事件。</li>
<li><strong>适用场景</strong>：适用于 <strong>实时性要求高</strong> 的系统，例如 <strong>实时操作系统 (RTOS)</strong>。</li>
<li><strong>优点</strong>：<strong>实时性好</strong>，<strong>响应速度快</strong>，<strong>资源利用率高</strong>。</li>
</ul>
</li>
</ul>
<h4>中断优先级</h4>
<p><strong>中断优先级 (Interrupt Priority)</strong> 用于<strong>区分不同中断请求的重要性</strong>。在多中断源的系统中，当<strong>多个中断同时发生</strong>时，<strong>优先级较高的中断</strong> 会被<strong>优先处理</strong>。</p>
<ul>
<li><strong>中断嵌套</strong>：<strong>中断服务例程 (ISR)</strong> 可以<strong>嵌套执行</strong>，即在执行一个 ISR 的过程中，可以被<strong>更高优先级的中断</strong> 再次<strong>中断</strong>。</li>
<li><strong>优先级编码</strong>：通常使用<strong>中断号</strong> 或 <strong>优先级编码</strong> 来表示中断的优先级。
<ul>
<li><strong>编号越小的 ISR，优先级越高</strong>。例如，在某些系统中，<strong>硬件中断</strong> 的优先级通常<strong>高于软件中断</strong>，<strong>NMI</strong> 的优先级<strong>高于 INTR</strong>。</li>
</ul>
</li>
<li><strong>优先级管理</strong>：<strong>中断控制器</strong>  (如 8259A) 负责<strong>管理中断优先级</strong>，<strong>仲裁</strong> 中断请求，并<strong>决定</strong> 哪个中断应该被<strong>优先响应</strong>。</li>
</ul>
<h3>中断向量表 (IVT)</h3>
<p><strong>中断向量表 (Interrupt Vector Table, IVT)</strong> 是计算机系统中<strong>管理和处理中断</strong> 的核心数据结构。</p>
<ul>
<li>
<p><strong>作用</strong>：<strong>存储中断服务例程 (ISR) 的入口地址</strong>。当<strong>中断发生</strong>时，CPU会根据<strong>中断号</strong> 在 <strong>中断向量表</strong> 中查找相应的入口地址，然后<strong>跳转到该地址执行中断处理程序</strong>。</p>
</li>
<li>
<p><strong>存储位置</strong>：<strong>中断向量表</strong> 通常位于RAM (随机访问存储器的起始地址区域，即 <strong>前 1024 字节</strong>  (地址范围：<strong>0000:0000 到 0000:03FF</strong>) 。</p>
</li>
<li>
<p><strong>条目结构</strong>：<strong>每个中断向量</strong> 在中断向量表中占用 <strong>4 个字节</strong>。</p>
<ul>
<li><strong>前 2 个字节</strong>：存储 <strong>指令指针 (IP, Instruction Pointer)</strong>，即 <strong>ISR 代码段内的偏移地址</strong>。</li>
<li><strong>后 2 个字节</strong>：存储 <strong>代码段选择器 (CS, Code Segment)</strong>，即 <strong>ISR 代码所在的段地址</strong>。</li>
</ul>
</li>
<li>
<p><strong>地址计算</strong>：对于给定的中断号 <code class="notranslate">n</code>，其在中断向量表中的起始地址可以通过以下公式计算：</p>
<p><code class="notranslate">中断向量地址 = 中断号 * 4</code></p>
<p>例如，假设 <strong>中断号为 <code class="notranslate">0x3</code></strong>：</p>
<ul>
<li><strong>中断向量表位置</strong>：<code class="notranslate">0x0C:0x0F</code></li>
<li><strong>入口地址解析</strong>：例如 <code class="notranslate">0x0C:0x0F</code> 处存储的值为 <code class="notranslate">0x0070:0x06F4</code>，则表示 <strong>中断处理程序的入口地址</strong> 为 代码段 <code class="notranslate">0x0070</code>，偏移地址 <code class="notranslate">0x06F4</code>。CPU 将跳转到 <strong>物理地址 <code class="notranslate">0x0070 &lt;&lt; 4 + 0x06F4</code></strong> 处开始执行 ISR 代码。</li>
</ul>
</li>
</ul>
<p><strong>中断向量表结构示意图</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a44aefbe7657393adf7f2d1266c595be72b66c41dca9d040d91610244952ad92/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f32302f5458594b3946356347554a493261312e6a7067"><img src="https://camo.githubusercontent.com/a44aefbe7657393adf7f2d1266c595be72b66c41dca9d040d91610244952ad92/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f32302f5458594b3946356347554a493261312e6a7067" alt="img" data-canonical-src="https://s2.loli.net/2025/01/20/TXYK9F5cGUJI2a1.jpg" style="max-width: 100%;"></a></p>
<p><strong>重写中断向量表的例子</strong></p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-c">    ; 保存原INT 8h中断向量</span>
<span class="pl-en">    </span><span class="pl-k">cli</span><span class="pl-c">                 ; 禁用中断</span>
<span class="pl-en">    </span><span class="pl-k">xor</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-c">          ; ES=0000h（中断向量表段）</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">8</span><span class="pl-s1">*</span><span class="pl-c1">4</span><span class="pl-c">         ; INT 8h向量地址（8h*4=20h）</span>

<span class="pl-c">    ; 保存原处理程序地址</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-en">:</span><span class="pl-s1">[</span><span class="pl-v">bx</span><span class="pl-s1">]</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> old_ip</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-en">:</span><span class="pl-s1">[</span><span class="pl-v">bx</span><span class="pl-s1">+</span><span class="pl-c1">2</span><span class="pl-s1">]</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> old_cs</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span>

<span class="pl-c">    ; 设置新中断向量</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> OFFSET isr</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-en">:</span><span class="pl-s1">[</span><span class="pl-v">bx</span><span class="pl-s1">],</span><span class="pl-en"> </span><span class="pl-v">ax</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">cs</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-en">:</span><span class="pl-s1">[</span><span class="pl-v">bx</span><span class="pl-s1">+</span><span class="pl-c1">2</span><span class="pl-s1">],</span><span class="pl-en"> </span><span class="pl-v">ax</span>
<span class="pl-en">    </span><span class="pl-k">sti</span><span class="pl-c">                 ; 重新启用中断</span></pre></div>
<h3>中断控制器 8259A</h3>
<h4>8259A 的功能与连接</h4>
<p><strong>8259A 可编程中断控制器 (Programmable Interrupt Controller, PIC)</strong> 是一种常用的<strong>硬件中断管理芯片</strong>，用于<strong>扩展 CPU 的中断处理能力</strong>，<strong>管理多个中断源</strong>，并实现<strong>中断优先级控制</strong>。</p>
<ul>
<li><strong>中断请求处理</strong>：当<strong>外部设备</strong> 的 <strong>IRQ (Interrupt Request)</strong> 线被<strong>触发</strong> (发出中断请求信号) 时，<strong>8259A</strong> 会<strong>接收</strong> 这些中断请求，进行<strong>优先级仲裁</strong>，并将<strong>最高优先级的中断请求</strong> <strong>转发给 CPU</strong>。</li>
<li><strong>中断号传输</strong>：<strong>中断编号</strong> 会通过 <strong>PC 总线</strong> 传输给 CPU，作为<strong>中断向量索引</strong>。</li>
<li><strong>中断向量表查找</strong>：<strong>CPU</strong> 接收到中断号后，会在 <strong>中断向量表 (IVT)</strong> 中<strong>查找</strong> 对应的 <strong>中断服务例程 (ISR) 入口地址</strong>。</li>
<li><strong>跳转执行 ISR</strong>：CPU <strong>跳转到 ISR 入口地址</strong>，开始执行 <strong>中断处理程序</strong>。</li>
</ul>
<h4>8259A 级联结构</h4>
<p>在 <strong>IBM PC</strong> 架构中，通常使用 <strong>两个 8259A 芯片</strong> <strong>级联</strong> 构成<strong>中断系统</strong>，以<strong>支持更多的中断源</strong>。</p>
<ul>
<li><strong>主芯片 (8259A #1)</strong>：
<ul>
<li>负责处理 <strong>IRQ0 ~ IRQ7</strong> <strong>共 8 个</strong> 中断请求。</li>
<li><strong>基地址</strong> 通常设置为 <strong>20H</strong>。</li>
</ul>
</li>
<li><strong>从芯片 (8259A #2)</strong>：
<ul>
<li>负责处理 <strong>IRQ8 ~ IRQ15</strong> <strong>共 8 个</strong> 中断请求。</li>
<li><strong>基地址</strong> 通常设置为 <strong>A0H</strong>。</li>
<li><strong>级联连接</strong>：<strong>从芯片</strong> 通过 <strong>IRQ2 引脚</strong> 连接到 <strong>主芯片 (8259A #1)</strong> 的 <strong>IRQ2 输入</strong>，实现级联。</li>
</ul>
</li>
</ul>
<p><strong>8259A 中断系统连接示意图</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/948eaa63f6768b357b200f30dd49652f9a6f9d3e9b3e4e24a9af8a7bc9e3de84/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f32302f36456e5a744262704a6d53464f41372e706e67"><img src="https://camo.githubusercontent.com/948eaa63f6768b357b200f30dd49652f9a6f9d3e9b3e4e24a9af8a7bc9e3de84/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f32302f36456e5a744262704a6d53464f41372e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/20/6EnZtBbpJmSFOA7.png" style="max-width: 100%;"></a></p>
<h4>IRQ 与中断向量的映射关系</h4>
<p><strong>8259A</strong> 将 <strong>硬件中断请求 (IRQ)</strong> 信号 <strong>映射</strong> 到 <strong>中断向量 (INT)</strong> 号，从而与 <strong>中断向量表 (IVT)</strong> 关联起来。</p>
<ul>
<li><strong>8259A #1 (主芯片) 的映射</strong>：
<ul>
<li><strong>IRQ0</strong> 映射到 <strong>INT 08H</strong> (中断向量号 0x08)</li>
<li><strong>IRQ1</strong> 映射到 <strong>INT 09H</strong> (中断向量号 0x09)</li>
<li>...</li>
<li><strong>IRQ7</strong> 映射到 <strong>INT 0FH</strong> (中断向量号 0x0F)</li>
</ul>
</li>
<li><strong>8259A #2 (从芯片) 的映射</strong>：
<ul>
<li><strong>IRQ8</strong> 映射到 <strong>INT 70H</strong> (中断向量号 0x70)</li>
<li><strong>IRQ9</strong> 映射到 <strong>INT 71H</strong> (中断向量号 0x71)</li>
<li>...</li>
<li><strong>IRQ15</strong> 映射到 <strong>INT 77H</strong> (中断向量号 0x77)</li>
</ul>
</li>
</ul>
<p><strong>IRQ 与中断向量映射表</strong></p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>IRQ</th>
<th>中断向量 (十六进制)</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x08</td>
<td><strong>定时器节拍 (Timer Tick)</strong></td>
</tr>
<tr>
<td>1</td>
<td>0x09</td>
<td><strong>键盘 (Keyboard)</strong></td>
</tr>
<tr>
<td>2</td>
<td>0x0A</td>
<td><strong>辅助 8259A (Second 8259A)</strong></td>
</tr>
<tr>
<td>3</td>
<td>0x0B</td>
<td><strong>COM2 (串行端口 2)</strong></td>
</tr>
<tr>
<td>4</td>
<td>0x0C</td>
<td><strong>COM1 (串行端口 1)</strong></td>
</tr>
<tr>
<td>5</td>
<td>0x0D</td>
<td><strong>声卡 / LPT2</strong></td>
</tr>
<tr>
<td>6</td>
<td>0x0E</td>
<td><strong>软盘驱动器控制器</strong></td>
</tr>
<tr>
<td>7</td>
<td>0x0F</td>
<td><strong>LPT1 (并行端口)</strong></td>
</tr>
<tr>
<td>8</td>
<td>0x70</td>
<td><strong>实时时钟 (RTC)</strong></td>
</tr>
<tr>
<td>9</td>
<td>0x71</td>
<td><strong>可用 (传统: IRQ2)</strong></td>
</tr>
<tr>
<td>10</td>
<td>0x72</td>
<td><strong>可用</strong></td>
</tr>
<tr>
<td>11</td>
<td>0x73</td>
<td><strong>可用</strong></td>
</tr>
<tr>
<td>12</td>
<td>0x74</td>
<td><strong>PS/2 鼠标</strong></td>
</tr>
<tr>
<td>13</td>
<td>0x75</td>
<td><strong>数学协处理器</strong></td>
</tr>
<tr>
<td>14</td>
<td>0x76</td>
<td><strong>主 IDE 控制器</strong></td>
</tr>
<tr>
<td>15</td>
<td>0x77</td>
<td><strong>辅助 IDE 控制器</strong></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>中断向量 INT 0-7</strong>  <strong>不由 8259A 控制</strong>，而是<strong>直接</strong> 由 <strong>CPU 硬件</strong> 或 <strong>BIOS</strong> 预留和使用，通常用于处理 <strong>CPU 异常</strong> 和 <strong>早期的硬件中断</strong>，例如：</p>
<ul>
<li><strong>INT 0</strong>: 除法错误异常</li>
<li><strong>INT 1</strong>: 单步中断 (调试)</li>
<li><strong>INT 2</strong>: NMI (非可屏蔽中断)</li>
<li><strong>INT 3</strong>: 断点中断</li>
<li><strong>INT 4</strong>: 溢出中断</li>
</ul>
</div>
<h3>CPU 中断处理流程详解</h3>
<p><strong>CPU 处理硬件中断请求的详细步骤</strong>：</p>
<ol>
<li>
<p><strong>中断触发 (Interrupt Trigger)</strong>：</p>
<ul>
<li><strong>外部设备</strong> 或 <strong>内部异常</strong> 产生<strong>中断请求 (IRQ)</strong>。</li>
<li><strong>中断信号</strong> 通过 <strong>中断线</strong> 发送到 <strong>CPU</strong> 或 <strong>中断控制器 (如 8259A)</strong>。</li>
</ul>
</li>
<li>
<p><strong>中断响应 (Interrupt Acknowledge)</strong>：</p>
<ul>
<li><strong>CPU</strong> 在<strong>完成当前指令的执行后</strong>，<strong>检测</strong> 到 <strong>中断请求</strong>。</li>
<li>如果<strong>中断允许</strong> (<strong>中断标志位 IF=1</strong>，且<strong>非屏蔽中断</strong>) ，CPU 发出 <strong>中断响应信号 (INTA, Interrupt Acknowledge)</strong>。</li>
</ul>
</li>
<li>
<p><strong>保存现场 (Save Context)</strong>：</p>
<ul>
<li><strong>CPU</strong> 自动将 <strong>当前程序的状态</strong> <strong>压入堆栈 (Stack)</strong> 保存，以便在中断处理完成后<strong>恢复执行</strong>。</li>
<li><strong>保存内容</strong> 通常包括：
<ul>
<li><strong>程序计数器 (PC, Program Counter) / 指令指针 (IP, Instruction Pointer)</strong>：指向<strong>下一条要执行的指令地址</strong>，用于记录中断发生时的程序执行位置。</li>
<li><strong>标志寄存器 (FLAGS)</strong>：保存 <strong>状态标志位</strong> 和 <strong>控制标志位</strong> 的值，如 <strong>进位标志 CF</strong>、<strong>零标志 ZF</strong>、<strong>中断使能标志 IF</strong> 等。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>获取中断向量 (Get Interrupt Vector)</strong>：</p>
<ul>
<li><strong>CPU</strong> 从 <strong>中断控制器 (如 8259A)</strong> <strong>读取</strong> 或 <strong>直接接收</strong> <strong>中断号</strong> (或称为 <strong>中断向量号</strong>)。</li>
<li><strong>根据中断号</strong> 在 <strong>中断向量表 (IVT)</strong> 中<strong>查找</strong> 对应的 <strong>中断服务例程 (ISR) 入口地址</strong> (代码段地址 CS 和偏移地址 IP) 。</li>
</ul>
</li>
<li>
<p><strong>跳转到 ISR (Jump to ISR)</strong>：</p>
<ul>
<li><strong>CPU</strong> <strong>加载</strong> 从中断向量表读取的 <strong>ISR 入口地址 (CS:IP)</strong> 到 <strong>代码段寄存器 CS</strong> 和 <strong>指令指针寄存器 IP</strong>。</li>
<li><strong>程序控制权</strong> <strong>转移</strong> 到 <strong>中断服务例程 (ISR) 的起始地址</strong>，开始执行 ISR 代码。</li>
</ul>
</li>
<li>
<p><strong>执行中断处理 (Execute ISR)</strong>：</p>
<ul>
<li><strong>CPU</strong> <strong>执行</strong> <strong>中断服务例程 (ISR)</strong> 代码，完成<strong>特定设备</strong> 或 <strong>异常</strong> 的具体<strong>处理逻辑</strong>。</li>
<li><strong>ISR 代码</strong> 负责：
<ul>
<li><strong>识别中断源</strong> (如果需要)。</li>
<li><strong>读取</strong> 或 <strong>写入</strong> <strong>I/O 端口</strong>，与设备进行数据交换。</li>
<li><strong>清除中断状态</strong>，<strong>复位设备</strong> (如果需要)。</li>
<li><strong>发送中断结束命令 (EOI)</strong> 给中断控制器 (对于 8259A 等可编程中断控制器)。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>恢复现场 (Restore Context)</strong>：</p>
<ul>
<li><strong>中断处理完成</strong> 后，<strong>ISR 代码</strong> 通常会执行 <strong><code class="notranslate">IRET</code> (中断返回)</strong> 指令。</li>
<li><strong><code class="notranslate">IRET</code> 指令</strong> 会从 <strong>堆栈 (Stack)</strong> 中 <strong>弹出</strong> 之前 <strong>保存的程序状态</strong> (包括 <strong>FLAGS</strong> 和 <strong>CS:IP</strong>)。</li>
<li><strong>CPU 寄存器</strong> 和 <strong>程序状态</strong> <strong>恢复</strong> 到 <strong>中断发生前的状态</strong>。</li>
</ul>
</li>
<li>
<p><strong>返回原程序 (Return to Original Program)</strong>：</p>
<ul>
<li><strong>CPU</strong> <strong>恢复执行</strong> 被中断的 <strong>原程序</strong>，从 <strong>断点处</strong>  (即 <strong>中断发生时 PC 指向的地址</strong>)  <strong>继续运行</strong>。</li>
</ul>
</li>
</ol>
<h3>8259A 操作命令：中断屏蔽</h3>
<p><strong>中断屏蔽寄存器 (IMR, Interrupt Mask Register)</strong> 是 <strong>8259A 可编程中断控制器 (PIC)</strong> 的一个重要寄存器，用于<strong>控制</strong> 哪些 <strong>中断请求 (IRQ)</strong>  <strong>被允许</strong> 或 <strong>禁止</strong> (屏蔽)。</p>
<ul>
<li><strong>端口地址</strong>：<strong>中断屏蔽寄存器 (IMR)</strong> 的端口地址通常为 <strong>21H</strong> (对于主 8259A 芯片)。</li>
<li><strong>位屏蔽</strong>：<strong>IMR</strong> 是一个 <strong>8 位寄存器</strong>，<strong>每一位</strong> 对应一个 <strong>IRQ 输入线</strong> (IRQ0 - IRQ7)。
<ul>
<li><strong>位值为 1</strong>：<strong>屏蔽</strong> 对应的 <strong>IRQ 中断请求</strong>，即 <strong>禁止</strong> 该中断被 8259A 传递给 CPU。</li>
<li><strong>位值为 0</strong>：<strong>允许</strong> 对应的 <strong>IRQ 中断请求</strong>，即 <strong>使能</strong> 该中断可以被 8259A 传递给 CPU。</li>
</ul>
</li>
</ul>
<p><strong>设置中断屏蔽的汇编代码示例</strong>：</p>
<p>以下代码示例演示了如何通过设置 <strong>IMR</strong> 来<strong>屏蔽 IRQ 7, IRQ 3 和 IRQ 1 中断</strong>。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">137</span><span class="pl-c">     ; 十进制 137, 十六进制 89H</span>
<span class="pl-c">                ; 二进制 10001001B</span>
<span class="pl-c">                ; 位 7, 3, 0 设置为 1，对应屏蔽 IRQ7, IRQ3, IRQ1</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">21h</span><span class="pl-c">     ; 中断屏蔽寄存器 (IMR) 的端口地址 (主 8259A)</span>
<span class="pl-k">out</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">AL</span><span class="pl-c">      ; 将屏蔽值写入 IMR 寄存器</span></pre></div>
<p><strong>屏蔽值 137 (89H) 的二进制表示 10001001B 的含义</strong>：</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/05cff24e65b3440dcdde52f20118aa5df6cc72bd866486c410005fac5883304a/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f32302f69455070774e78524f6834474863362e706e67"><img src="https://camo.githubusercontent.com/05cff24e65b3440dcdde52f20118aa5df6cc72bd866486c410005fac5883304a/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f32302f69455070774e78524f6834474863362e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/20/iEPpwNxROh4GHc6.png" style="max-width: 100%;"></a></p>
<ul>
<li><strong>位 7 (最高位)</strong>：设置为 <strong>1</strong>，<strong>屏蔽 IRQ7</strong>。</li>
<li><strong>位 6 - 位 4</strong>：设置为 <strong>0</strong>，<strong>允许 IRQ6, IRQ5, IRQ4</strong>。</li>
<li><strong>位 3</strong>：设置为 <strong>1</strong>，<strong>屏蔽 IRQ3</strong>。</li>
<li><strong>位 2</strong>：设置为 <strong>0</strong>，<strong>允许 IRQ2</strong>。</li>
<li><strong>位 1</strong>：设置为 <strong>1</strong>，<strong>屏蔽 IRQ1</strong>。</li>
<li><strong>位 0 (最低位)</strong>：设置为 <strong>0</strong>，<strong>允许 IRQ0</strong>。</li>
</ul>
<h3>中断结束命令 (EOI)</h3>
<p><strong>中断结束 (End of Interrupt, EOI)</strong> 命令是 <strong>8259A 可编程中断控制器 (PIC)</strong> 中用于<strong>通知控制器</strong>  <strong>中断处理程序 (ISR) 已经完成</strong>，可以<strong>重新接受新的中断请求</strong> 的命令。</p>
<ul>
<li><strong>非特定 EOI (Non-Specific EOI)</strong>：
<ul>
<li><strong>命令字</strong>：通常为 <strong>20H</strong>。</li>
<li><strong>端口地址</strong>：<strong>命令端口</strong> 地址通常为 <strong>20H</strong> (对于主 8259A 芯片)。</li>
<li><strong>用途</strong>：<strong>最常用的 EOI 命令</strong>。通知 8259A <strong>当前正在处理的中断已经结束</strong>，可以<strong>清除</strong> 8259A 内部的<strong>中断请求状态</strong>，并<strong>允许处理新的中断请求</strong>。</li>
<li><strong>优先级管理</strong>：<strong>非特定 EOI</strong> 会让 8259A <strong>自动</strong> 将<strong>优先级最低的正在服务的中断</strong> 标记为结束。</li>
</ul>
</li>
</ul>
<p><strong>发送非特定 EOI 命令的汇编代码示例</strong>：</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">EOI_command:</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">20h</span><span class="pl-c">     ; EOI 命令字 (非特定 EOI)</span>
<span class="pl-en">    </span><span class="pl-k">out</span><span class="pl-en"> </span><span class="pl-c1">20h</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-c">     ; 发送到 8259A 的主控制器命令端口 (20H)</span></pre></div>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>何时发送 EOI 命令</strong>：</p>
<ul>
<li><strong>在中断服务例程 (ISR) 的末尾</strong>，<strong><code class="notranslate">IRET</code> (中断返回) 指令之前</strong>，<strong>必须发送 EOI 命令</strong> 给中断控制器。</li>
<li><strong>目的</strong>：
<ul>
<li><strong>通知 8259A</strong> 中断处理已完成。</li>
<li><strong>重置</strong> 8259A 的内部状态，<strong>准备</strong> 接收和处理<strong>新的中断请求</strong>。</li>
<li>如果<strong>忘记发送 EOI 命令</strong>，<strong>8259A</strong> 可能<strong>无法正确响应后续的中断请求</strong>，导致系统功能异常。</li>
</ul>
</li>
</ul>
</div>
<h3>自定义中断服务例程 (ISR)</h3>
<p><strong>自定义中断服务例程 (ISR)</strong> 是指<strong>程序员</strong> <strong>自己编写</strong> 的 <strong>中断处理程序</strong>，用于<strong>替换</strong> 系统默认的 <strong>ISR</strong>，以实现特定的中断处理逻辑。</p>
<ul>
<li><strong>硬件驱动程序</strong>：为特定的硬件设备编写 ISR，处理设备发出的中断请求，实现设备的数据传输、控制等功能。</li>
<li><strong>实时系统</strong>：在实时系统中，需要编写定制化的 ISR，以满足系统对中断响应时间、处理逻辑的特定需求。</li>
<li><strong>系统功能扩展</strong>：通过自定义 ISR，可以扩展系统的功能，例如实现<strong>自定义的定时器</strong>、<strong>热键检测</strong> 等。</li>
</ul>
<p><strong>自定义定时器 ISR 的示例</strong>：</p>
<p><strong>INT 08H (定时器中断)</strong> 是 <strong>IBM PC 架构</strong> 中由 <strong>系统定时器</strong> 周期性触发的 <strong>硬件中断</strong>，<strong>默认情况下</strong>，<strong>INT 08H</strong> 的 <strong>ISR</strong>  通常用于<strong>更新系统时间</strong> 等操作。</p>
<ul>
<li><strong>自定义 ISR 替换</strong>：程序员可以<strong>编写自己的 ISR 代码</strong>，<strong>替换</strong> 原有的 <strong>INT 08H</strong> 中断处理程序，从而实现<strong>自定义的定时器功能</strong>。</li>
<li><strong>周期性执行</strong>：由于 <strong>INT 08H</strong>  大约每 <strong>50ms</strong> 左右 <strong>自动执行一次</strong>，因此可以利用它来实现<strong>周期性的任务</strong>，例如 <strong>计时器</strong>、<strong>实时数据采集</strong>、<strong>周期性系统监控</strong> 等。</li>
</ul>
<h3>直接访问屏幕内存 (VRAM)</h3>
<p><strong>直接访问屏幕内存</strong> 是一种<strong>高效的屏幕显示技术</strong>，允许程序<strong>直接</strong> <strong>读写</strong> <strong>视频 RAM (Video RAM, VRAM)</strong>，从而<strong>快速</strong> <strong>控制屏幕显示内容</strong>。</p>
<ul>
<li><strong>DOS 文本模式</strong>：在 <strong>DOS 文本模式</strong> 下，<strong>屏幕内存</strong> 的起始地址通常为 <strong>B800:0000</strong> (段地址 B800H，偏移地址 0000H)。</li>
<li><strong>字符和属性存储</strong>：<strong>每个屏幕显示位置</strong> 在内存中占用 <strong>2 个字节</strong>。
<ul>
<li><strong>第一个字节</strong>：存储 <strong>字符的 ASCII 码</strong>。</li>
<li><strong>第二个字节</strong>：存储 <strong>属性字节 (Attribute Byte)</strong>，用于控制字符的 <strong>颜色</strong>、<strong>闪烁</strong> 等显示属性。</li>
</ul>
</li>
<li><strong>屏幕尺寸</strong>：<strong>DOS 屏幕</strong> 通常设置为 <strong>80 列 x 25 行</strong>，总共可以显示 <strong>2000 个字符</strong> (80 * 25 = 2000)。</li>
<li><strong>内存占用</strong>：整个屏幕的显存空间占用 <strong>4000 字节</strong> (2000 字符 * 2 字节/字符 = 4000 字节)。</li>
</ul>
<p><strong>DOS 屏幕内存组织结构</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/fed8907c2f6a0528f140150ca9785d4ebb55049f30afd16e6c84f95ef11d9c42/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f32302f36614b65487a476e797477677833512e706e67"><img src="https://camo.githubusercontent.com/fed8907c2f6a0528f140150ca9785d4ebb55049f30afd16e6c84f95ef11d9c42/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f32302f36614b65487a476e797477677833512e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/01/20/6aKeHzGnytwgx3Q.png" style="max-width: 100%;"></a></p>
<h4>属性字节 (Attribute Byte) 结构</h4>
<p><strong>属性字节 (Attribute Byte)</strong> 用于控制 <strong>DOS 文本模式</strong> 下 <strong>字符的显示属性</strong>，例如 <strong>前景色</strong>、<strong>背景色</strong>、<strong>闪烁</strong>、<strong>亮度</strong> 等。</p>
<p><strong>属性字节的位结构</strong>：</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/58d7606c8411c561aed230c3512311890412e98643b5b94e59d4738534d42ccd/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f32302f347970544538725961466e553532332e6a7067"><img src="https://camo.githubusercontent.com/58d7606c8411c561aed230c3512311890412e98643b5b94e59d4738534d42ccd/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30312f32302f347970544538725961466e553532332e6a7067" alt="img" data-canonical-src="https://s2.loli.net/2025/01/20/4ypTE8rYaFnU523.jpg" style="max-width: 100%;"></a></p>
<ul>
<li>
<p><strong>背景色 (Background Color)</strong>：</p>
<ul>
<li><strong>位 7 (F, Flash)</strong>：<strong>闪烁控制位</strong>。
<ul>
<li><strong>1</strong>: 字符 <strong>闪烁</strong>。</li>
<li><strong>0</strong>: 字符 <strong>不闪烁</strong>。</li>
</ul>
</li>
<li><strong>位 6-4 (R, G, B)</strong>：<strong>背景颜色控制位</strong>。
<ul>
<li><strong>RGB 三位二进制编码</strong>，控制 <strong>背景颜色</strong>，可以表示 8 种颜色 (黑、蓝、绿、青、红、紫、黄、白)。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>前景色 (Foreground Color)</strong>：</p>
<ul>
<li><strong>位 3 (I, Intensity)</strong>：<strong>亮度控制位</strong>。
<ul>
<li><strong>1</strong>: <strong>高亮度</strong> (亮色)。</li>
<li><strong>0</strong>: <strong>普通亮度</strong> (暗色)。</li>
</ul>
</li>
<li><strong>位 2-0 (R, G, B)</strong>：<strong>前景色控制位</strong>。
<ul>
<li><strong>RGB 三位二进制编码</strong>，控制 <strong>前景色</strong>，可以表示 8 种颜色 (黑、蓝、绿、青、红、紫、黄、白)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>汇编代码示例：屏幕打印 "Hello, world!"</h4>
<p>以下汇编代码示例演示了如何在 <strong>DOS 文本模式</strong> 下，<strong>直接访问屏幕内存</strong>，在屏幕上打印字符串 <code class="notranslate">"Hello, world!"</code>。</p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">.MODEL small</span>
<span class="pl-en">.STACK</span>
<span class="pl-en">.DATA</span>
<span class="pl-en">    msg db </span><span class="pl-s">'Hello, world!'</span>
<span class="pl-en">.CODE</span>
<span class="pl-en">start:</span>
<span class="pl-c">    ; 设置数据段寄存器 DS 指向数据段</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> @data</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ds</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span>

<span class="pl-c">    ; 设置附加段寄存器 ES 指向显存段 (B800h)</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">0B800h</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span>

<span class="pl-c">    ; 清空屏幕</span>
<span class="pl-en">    </span><span class="pl-k">xor</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-c">            ; DX 寄存器清零，用于存储空格字符和属性</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">2000</span><span class="pl-c">          ; 屏幕字符总数 (80列 * 25行)</span>
<span class="pl-en">    </span><span class="pl-k">xor</span><span class="pl-en"> </span><span class="pl-v">di</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">di</span><span class="pl-c">            ; DI 寄存器清零，作为显存地址偏移量</span>
<span class="pl-en">clear_screen:</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-en">:</span><span class="pl-s1">[</span><span class="pl-v">di</span><span class="pl-s1">],</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-c">       ; 将空格字符和属性写入显存，清空屏幕</span>
<span class="pl-en">    </span><span class="pl-k">add</span><span class="pl-en"> </span><span class="pl-v">di</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">2</span><span class="pl-c">             ; 显存地址偏移量增加 2 (每个字符占 2 字节)</span>
<span class="pl-en">    </span><span class="pl-k">loop</span><span class="pl-en"> clear_screen</span><span class="pl-c">     ; 循环清空整个屏幕</span>

<span class="pl-c">    ; 循环写入字符和属性，打印字符串 "Hello, world!"</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">13</span><span class="pl-c">            ; 字符串长度 (13个字符)</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">di</span><span class="pl-s1">,</span><span class="pl-en"> (</span><span class="pl-c1">12</span><span class="pl-en"> </span><span class="pl-s1">*</span><span class="pl-en"> </span><span class="pl-c1">80</span><span class="pl-en"> </span><span class="pl-s1">+</span><span class="pl-en"> </span><span class="pl-c1">33</span><span class="pl-en">) </span><span class="pl-s1">*</span><span class="pl-en"> </span><span class="pl-c1">2</span><span class="pl-en"> </span>
<span class="pl-en">    </span><span class="pl-k">lea</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-s1">,</span><span class="pl-en"> msg</span><span class="pl-c">           ; BX 寄存器指向字符串 msg 的首地址</span>
<span class="pl-en">print_loop:</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s1">[</span><span class="pl-v">bx</span><span class="pl-s1">]</span><span class="pl-c">          ; 从字符串中取出一个字符，放入 AL 寄存器</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">07h</span><span class="pl-c">           ; 设置属性字节为 07h (黑底白字)</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-en">:</span><span class="pl-s1">[</span><span class="pl-v">di</span><span class="pl-s1">],</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-c">       ; 将字符和属性字节写入显存</span>
<span class="pl-en">    </span><span class="pl-k">inc</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-c">              ; 字符串指针 BX 加 1，指向下一个字符</span>
<span class="pl-en">    </span><span class="pl-k">add</span><span class="pl-en"> </span><span class="pl-v">di</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">2</span><span class="pl-c">             ; 显存地址偏移量增加 2</span>
<span class="pl-en">    </span><span class="pl-k">loop</span><span class="pl-en"> print_loop</span><span class="pl-c">       ; 循环打印整个字符串</span>

<span class="pl-c">    ; 等待按键按下后退出程序</span>
<span class="pl-en">wait_for_key:</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">1</span>
<span class="pl-en">    </span><span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">16h</span><span class="pl-c">             ; BIOS 键盘输入中断，检测是否有按键按下 (不回显)</span>
<span class="pl-en">    </span><span class="pl-k">jz</span><span class="pl-en"> wait_for_key</span><span class="pl-c">     ; 如果没有按键按下，继续等待</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">0</span>
<span class="pl-en">    </span><span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">16h</span><span class="pl-c">             ; BIOS 键盘输入中断，读取按键的 ASCII 码 (回显)</span>

<span class="pl-c">    ; 退出程序，返回 DOS</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">4C00h</span>
<span class="pl-en">    </span><span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">21h</span><span class="pl-c">             ; DOS 程序结束中断</span>
<span class="pl-en">END</span></pre></div>
<h3>驻留程序 (TSR)</h3>
<p><strong>驻留程序 (Terminate and Stay Resident, TSR)</strong> 是一种在 <strong>DOS 系统</strong> 中使用的特殊程序类型。</p>
<ul>
<li><strong>驻留内存</strong>：<strong>TSR 程序</strong> 在 <strong>主程序结束后</strong>，<strong>仍然可以继续驻留在内存中</strong>，<strong>不释放内存资源</strong>。</li>
<li><strong>后台运行</strong>：<strong>TSR 程序</strong> 通常在 <strong>后台运行</strong>，<strong>监听系统事件</strong> 或 <strong>用户操作</strong>，并在特定条件触发时<strong>被激活</strong>，执行预定的功能。</li>
<li><strong>快速调用</strong>：由于 TSR 程序常驻内存，因此可以被<strong>快速调用</strong>，无需重新加载，<strong>提高了响应速度</strong>。</li>
</ul>
<p><strong>TSR 程序的典型应用</strong>：</p>
<ul>
<li><strong>弹出式工具</strong>：例如 <strong>弹出式计算器</strong>、<strong>剪贴板工具</strong>。用户可以通过<strong>热键</strong> 快速激活 TSR 程序，执行计算、复制粘贴等操作，完成后程序仍然驻留在后台。</li>
<li><strong>系统监控程序</strong>：例如 <strong>系统资源监视器</strong>、<strong>病毒扫描程序</strong>。TSR 程序可以在后台<strong>监控系统状态</strong>，并在发现异常情况时<strong>及时发出警告</strong> 或 <strong>采取措施</strong>。</li>
<li><strong>定时任务</strong>：利用 <strong>定时器中断</strong>，TSR 程序可以<strong>周期性地执行</strong> 某些<strong>后台任务</strong>，例如 <strong>自动备份</strong>、<strong>数据同步</strong> 等。</li>
</ul>
<h4>热键检测</h4>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-c">; 伪代码：检测热键 Ctrl+Alt+X</span>
<span class="pl-en">check_hotkey:</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">02h</span><span class="pl-c">       ; BIOS 功能号 02h：读取键盘状态</span>
<span class="pl-en">    </span><span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">16h</span><span class="pl-c">           ; 调用 BIOS 键盘中断 16h，读取键盘状态字节到 AL 寄存器</span>
<span class="pl-en">    </span><span class="pl-k">and</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">00001111b</span><span class="pl-c"> ; 屏蔽 AL 寄存器高 4 位，仅保留低 4 位 (Shift, Ctrl, Alt, Scroll Lock 状态位)</span>
<span class="pl-en">    </span><span class="pl-k">cmp</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">00001100b</span><span class="pl-c"> ; 与 00001100b (Ctrl+Alt 键按下) 进行比较</span>
<span class="pl-en">    </span><span class="pl-k">jne</span><span class="pl-en"> no_hotkey</span><span class="pl-c">     ; 如果比较结果不相等 (Ctrl+Alt 未同时按下)，跳转到 no_hotkey 标签</span>

<span class="pl-c">    ; 如果 Ctrl+Alt 键同时按下，继续检测 X 键是否按下</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ah</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">00h</span><span class="pl-c">       ; BIOS 功能号 00h：读取键盘输入</span>
<span class="pl-en">    </span><span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">16h</span><span class="pl-c">           ; 调用 BIOS 键盘输入中断 16h，读取键盘扫描码和 ASCII 码</span>
<span class="pl-en">    </span><span class="pl-k">cmp</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s">'x'</span><span class="pl-c">       ; 比较 AL 寄存器中的 ASCII 码是否为字符 'x' (小写 x)</span>
<span class="pl-en">    </span><span class="pl-k">je</span><span class="pl-en"> hotkey_pressed</span><span class="pl-c"> ; 如果比较结果相等 (X 键按下)，跳转到 hotkey_pressed 标签</span>

<span class="pl-en">no_hotkey:</span>
<span class="pl-en">    </span><span class="pl-k">ret</span><span class="pl-c">               ; 如果热键未按下，子程序返回</span>

<span class="pl-en">hotkey_pressed:</span>
<span class="pl-c">    ; 在这里编写 TSR 程序的功能代码</span>
<span class="pl-c">    ; 例如：弹出计算器窗口、显示系统信息等</span>
<span class="pl-en">    </span><span class="pl-k">ret</span><span class="pl-c">               ; 热键处理程序返回</span></pre></div>
<hr>
<h2>Lecture10: MASM Code for Interrupts</h2>
<h3>一个显示在屏幕右上角的后台计时器</h3>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">.MODEL small</span>
<span class="pl-en">.STACK </span><span class="pl-c1">100h</span>

<span class="pl-en">.DATA</span>
<span class="pl-c">    ; 注意：TSR运行时DS可能改变，变量存储在代码段</span>
<span class="pl-c">    ; 以下变量通过CS段前缀访问</span>

<span class="pl-en">.CODE</span>
<span class="pl-en">.STARTUP</span>
<span class="pl-k">jmp</span><span class="pl-en"> install_tsr</span><span class="pl-c">    ; 跳过数据区</span>

<span class="pl-c">    ; 变量存储在代码段 (保持驻留) </span>
<span class="pl-en">    dseg   db </span><span class="pl-s">'0'</span><span class="pl-s1">,</span><span class="pl-c1">0</span><span class="pl-c">    ; 当前显示字符</span>
<span class="pl-en">    cntr   db </span><span class="pl-c1">0</span><span class="pl-c">        ; 中断计数器</span>
<span class="pl-en">    old_ip dw </span><span class="pl-c1">0</span><span class="pl-c">        ; 原中断处理程序IP</span>
<span class="pl-en">    old_cs dw </span><span class="pl-c1">0</span><span class="pl-c">        ; 原中断处理程序CS</span>

<span class="pl-en">install_tsr:</span>
<span class="pl-c">    ; 保存原INT 8h中断向量</span>
<span class="pl-en">    </span><span class="pl-k">cli</span><span class="pl-c">                 ; 禁用中断</span>
<span class="pl-en">    </span><span class="pl-k">xor</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-c">          ; ES=0000h (中断向量表段) </span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">8</span><span class="pl-s1">*</span><span class="pl-c1">4</span><span class="pl-c">         ; INT 8h向量地址 (8h*4=20h) </span>

<span class="pl-c">    ; 保存原处理程序地址</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-en">:</span><span class="pl-s1">[</span><span class="pl-v">bx</span><span class="pl-s1">]</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> old_ip</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-en">:</span><span class="pl-s1">[</span><span class="pl-v">bx</span><span class="pl-s1">+</span><span class="pl-c1">2</span><span class="pl-s1">]</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> old_cs</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span>

<span class="pl-c">    ; 设置新中断向量</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> OFFSET isr</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-en">:</span><span class="pl-s1">[</span><span class="pl-v">bx</span><span class="pl-s1">],</span><span class="pl-en"> </span><span class="pl-v">ax</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">cs</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-en">:</span><span class="pl-s1">[</span><span class="pl-v">bx</span><span class="pl-s1">+</span><span class="pl-c1">2</span><span class="pl-s1">],</span><span class="pl-en"> </span><span class="pl-v">ax</span>
<span class="pl-en">    </span><span class="pl-k">sti</span><span class="pl-c">                 ; 重新启用中断</span>

<span class="pl-c">    ; 计算驻留内存大小并终止驻留</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> OFFSET tsr_end</span><span class="pl-c">  ; DX=程序结束地址</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cl</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">4</span>
<span class="pl-en">    </span><span class="pl-k">shr</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">cl</span><span class="pl-c">           ; 转换为段落 (除以16) </span>
<span class="pl-en">    </span><span class="pl-k">inc</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-c">               ; 向上取整</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">3100h</span><span class="pl-c">        ; AH=31h TSR功能，AL=返回码</span>
<span class="pl-en">    </span><span class="pl-k">int</span><span class="pl-en"> </span><span class="pl-c1">21h</span>

<span class="pl-c">; 中断服务程序 (ISR) </span>
<span class="pl-en">isr PROC far</span>
<span class="pl-en">	</span><span class="pl-k">pushf</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">di</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">si</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">bp</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">ds</span>
<span class="pl-en">    </span><span class="pl-k">push</span><span class="pl-en"> </span><span class="pl-v">es</span>

<span class="pl-c">    ; 使用CS段访问变量</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">cs</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ds</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">bx</span>

<span class="pl-c">    ; 更新计数器</span>
<span class="pl-en">    </span><span class="pl-k">inc</span><span class="pl-en"> </span><span class="pl-v">cs</span><span class="pl-en">:cntr</span>
<span class="pl-en">    </span><span class="pl-k">cmp</span><span class="pl-en"> </span><span class="pl-v">cs</span><span class="pl-en">:cntr</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">18</span><span class="pl-c">      ; 约1秒 (18.2次/秒) </span>
<span class="pl-en">    </span><span class="pl-k">jb</span><span class="pl-en"> chain_int</span>

<span class="pl-c">    ; 重置计数器并更新显示</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cs</span><span class="pl-en">:cntr</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">0</span>
<span class="pl-en">    </span><span class="pl-k">inc</span><span class="pl-en"> </span><span class="pl-v">cs</span><span class="pl-en">:dseg</span>
<span class="pl-en">    </span><span class="pl-k">cmp</span><span class="pl-en"> </span><span class="pl-v">cs</span><span class="pl-en">:dseg</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s">'9'</span>
<span class="pl-en">    </span><span class="pl-k">jbe</span><span class="pl-en"> update_screen</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cs</span><span class="pl-en">:dseg</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-s">'0'</span>

<span class="pl-en">update_screen:</span>
<span class="pl-c">    ; 直接写入显存B800h</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">0B800h</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">ax</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">di</span><span class="pl-s1">,</span><span class="pl-en"> (</span><span class="pl-c1">79</span><span class="pl-en">)</span><span class="pl-s1">*</span><span class="pl-c1">2</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">cs</span><span class="pl-en">:dseg</span>
<span class="pl-en">    </span><span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">es</span><span class="pl-en">:</span><span class="pl-s1">[</span><span class="pl-v">di</span><span class="pl-s1">],</span><span class="pl-en"> </span><span class="pl-v">al</span>

<span class="pl-en">chain_int:</span>
<span class="pl-c">    ; 恢复环境并链式调用原中断处理程序</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">es</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">ds</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">bp</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">si</span>
<span class="pl-en">    </span><span class="pl-k">pop</span><span class="pl-en"> </span><span class="pl-v">di</span>
<span class="pl-en">    </span><span class="pl-k">popf</span>
<span class="pl-en">    </span><span class="pl-k">jmp</span><span class="pl-en"> </span><span class="pl-v">cs</span><span class="pl-en">:dword ptr old_ip</span><span class="pl-c">  ; 跳转到原处理程序</span>

<span class="pl-en">isr ENDP</span>

<span class="pl-en">tsr_end:</span><span class="pl-c">   ; 标记TSR代码结束</span>
<span class="pl-en">END</span></pre></div>
<hr>
<h2>Lecture 11: 内存层次结构：动态与静态随机存储器</h2>
<h3>内存的层次结构</h3>
<h4>内存层次结构的重要性</h4>
<p>现代计算机系统采用<strong>内存层次结构 (Memory Hierarchy)</strong> 以平衡 <strong>速度</strong>、<strong>成本</strong> 和 <strong>容量</strong> 之间的矛盾。这种结构利用了程序访问数据的局部性原理，通过多层不同特性的存储器协同工作，实现高性能的内存系统。</p>
<ul>
<li><strong>高速缓存 (Cache)</strong> -&gt; <strong>主存储器 (Main Memory)</strong> -&gt; <strong>辅助存储器 (Secondary Storage)</strong> 构成金字塔结构。</li>
<li><strong>速度递减</strong>：从高速缓存到辅助存储器，访问速度<strong>依次降低</strong>。</li>
<li><strong>成本递减</strong>：从高速缓存到辅助存储器，单位存储容量的<strong>成本依次降低</strong>。</li>
<li><strong>容量递增</strong>：从高速缓存到辅助存储器，存储<strong>容量依次增大</strong>。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5f2251a1d9724f04f5aa19bab237399d68a8e26431e9ec4c49d2d7cd5a37ed3d/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f574650685572636d71486b517766562e706e67"><img src="https://camo.githubusercontent.com/5f2251a1d9724f04f5aa19bab237399d68a8e26431e9ec4c49d2d7cd5a37ed3d/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f574650685572636d71486b517766562e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/05/WFPhUrcmqHkQwfV.png" style="max-width: 100%;"></a></p>
<h3>主存储器 (Main Memory)</h3>
<h4>主存的分类：DRAM 与 SRAM</h4>
<p><strong>主存储器 (Main Memory)</strong>，也常被称为 <strong>内存</strong> 或 <strong>RAM (Random Access Memory)</strong>，是计算机系统中用于 <strong>高速</strong> 存储 <strong>正在运行的程序和数据</strong> 的关键组件.主存储器主要分为两种类型： <strong>DRAM (动态随机存取存储器)</strong> 和 <strong>SRAM (静态随机存取存储器)</strong>。</p>
<h4>静态随机存取存储器 (SRAM)</h4>
<p><strong>静态随机存取存储器 (Static Random Access Memory, SRAM)</strong>  是一种高速的半导体存储器，其特点包括：</p>
<ul>
<li><strong>构造原理</strong>：<strong>SRAM</strong> 基于 <strong>触发器 (Flip-Flops)</strong> 存储数据。每个存储位使用多个晶体管 (通常为 4-6 个) 构成触发器来保持数据状态。</li>
<li><strong>单元尺寸</strong>：由于使用触发器结构，<strong>SRAM 存储单元</strong> 的 <strong>尺寸较大</strong>，集成度相对较低。</li>
<li><strong>数据保持</strong>：<strong>SRAM</strong> 具有 <strong>易失性 (Volatile)</strong>，断电后数据会丢失。但只要供电，<strong>SRAM</strong> 就能<strong>静态地保持数据</strong>，<strong>无需刷新操作</strong>。</li>
<li><strong>访问速度</strong>：<strong>SRAM</strong> 的 <strong>访问速度非常快</strong>，远快于 <strong>DRAM</strong>，常用于构建 <strong>高速缓存 (Cache)</strong>。典型的 <strong>SRAM 访问时间</strong> 约为 <strong>10 纳秒 (10ns)</strong>。</li>
</ul>
<p><strong>SRAM 存储单元结构图</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b5ad2e83e2477dacb5b666fdb34fb0090ce4686f6a20cacd421cd534e14da132/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f734b505143353369344765684466382e6a7067"><img src="https://camo.githubusercontent.com/b5ad2e83e2477dacb5b666fdb34fb0090ce4686f6a20cacd421cd534e14da132/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f734b505143353369344765684466382e6a7067" alt="img" data-canonical-src="https://s2.loli.net/2025/02/05/sKPQC53i4GehDf8.jpg" style="max-width: 100%;"></a></p>
<p><strong>SRAM 访问方式示意图</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a175d29d3c4df1170d0668c990fb5092963bc33ababec0c374f29f806f5016d1/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f5548754f335a35746157524b71774a2e6a7067"><img src="https://camo.githubusercontent.com/a175d29d3c4df1170d0668c990fb5092963bc33ababec0c374f29f806f5016d1/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f5548754f335a35746157524b71774a2e6a7067" alt="img" data-canonical-src="https://s2.loli.net/2025/02/05/UHuO3Z5taWRKqwJ.jpg" style="max-width: 100%;"></a></p>
<h4>动态随机存取存储器 (DRAM)</h4>
<p><strong>动态随机存取存储器 (Dynamic Random Access Memory, DRAM)</strong>  是另一种常用的半导体存储器，其特性如下：</p>
<ul>
<li><strong>构造原理</strong>：<strong>DRAM</strong> 基于 <strong>MOSFET (金属氧化物半导体场效应晶体管)</strong> 的 <strong>栅极电容</strong> 存储数据。每个存储位使用一个晶体管和一个电容组成存储单元。</li>
<li><strong>存储密度</strong>：<strong>DRAM 存储单元</strong> 结构简单，<strong>尺寸小</strong>，可以实现 <strong>更高的存储密度</strong> (更大的存储容量)。</li>
<li><strong>成本</strong>：<strong>DRAM</strong> 的 <strong>制造成本较低</strong>，因此被广泛用作 <strong>主存储器</strong>。</li>
<li><strong>数据保持与刷新</strong>：<strong>DRAM</strong> 也是 <strong>易失性</strong> 存储器。由于电容会 <strong>漏电</strong>，<strong>DRAM</strong> 存储的数据需要 <strong>定期刷新 (Refresh)</strong> 才能保持。需要 <strong>额外的刷新控制电路</strong> 来完成刷新操作。</li>
<li><strong>访问速度</strong>：<strong>DRAM</strong> 的 <strong>访问速度相对较慢</strong>，典型的 <strong>DRAM 访问时间</strong> 约为 <strong>60 纳秒 (60ns)</strong>.在<strong>非访问状态下</strong>，<strong>DRAM 不消耗能量</strong>。.了提高读取速度，<strong>DRAM</strong> 在读取操作前会对存储单元进行 <strong>预充电 (Precharge)</strong>。因.，<strong>DRAM 的速度</strong> 通常以 <strong>总周期时间 T</strong> 来衡量，约为 <strong>访问时间的两倍</strong>。</li>
</ul>
<p><strong>DRAM 存储单元结构图</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ee3b6e9ee3202d120449ae902f2c00345a5938acd142a3fcbcec76aa870c221f/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f316474725156664a68394477656f422e706e67"><img src="https://camo.githubusercontent.com/ee3b6e9ee3202d120449ae902f2c00345a5938acd142a3fcbcec76aa870c221f/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f316474725156664a68394477656f422e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/05/1dtrQVfJh9DweoB.png" style="max-width: 100%;"></a></p>
<p><strong>4-bit DRAM 结构示意图</strong></p>
<p><strong>DRAM</strong> 通常以 <strong>阵列形式</strong> 组织，例如 <strong>4 位 DRAM 结构</strong>.通过 <strong>激活字线 (Word Line)</strong> 来选择 <strong>存储单元行</strong>，然后通过 <strong>列选择 (Column Select)</strong> 来选择 <strong>特定的位</strong> 进行读写操作。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/2f4b481317b4d8b99e7976ba6d68ff6e1e478c11e5f225363ca210192eedb1ee/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f5359796c6343374f366949665677542e706e67"><img src="https://camo.githubusercontent.com/2f4b481317b4d8b99e7976ba6d68ff6e1e478c11e5f225363ca210192eedb1ee/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f5359796c6343374f366949665677542e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/05/SYylcC7O6iIfVwT.png" style="max-width: 100%;"></a></p>
<h3>DRAM 读写与刷新周期</h3>
<h4>DRAM 的读写操作</h4>
<p><strong>DRAM 的读写操作</strong> 流程如下：</p>
<ol>
<li><strong>行激活 (Row Activation)</strong>：通过 <strong>激活字线 (Word Line)</strong> 选择 <strong>存储单元阵列中的一行</strong>.这会将选定行中 <strong>所有存储单元的数据</strong> <strong>读出</strong> 到 <strong>位线 (Bit Line)</strong>。</li>
<li><strong>列选择与数据传输 (Column Select &amp; Data Transfer)</strong>： 通过 <strong>激活列线 (Column Line)</strong> 和 <strong>列选择信号 (CAS, Column Address Select)</strong>， 从选定行中 <strong>选择特定的列</strong> (即 <strong>特定的存储单元</strong>)。</li>
<li><strong>数据写入 (Write)</strong> 或 <strong>读回 (Readback)</strong>：
<ul>
<li><strong>读取模式 (Read Mode)</strong>：<strong>列线被激活</strong>，选定存储单元的数据被 <strong>输出</strong>。同时，<strong>读出的数据</strong> 会被 <strong>写回 (Write Back)</strong> 到 <strong>存储单元</strong>，以 <strong>保持数据</strong>。</li>
<li><strong>写入模式 (Write Mode)</strong>：<strong>列线被激活</strong>，<strong>新的数据</strong> 通过 <strong>列线</strong> 被 <strong>写入</strong> 到选定的 <strong>存储单元</strong>。</li>
</ul>
</li>
</ol>
<h4>DRAM 刷新 (Refresh)</h4>
<p><strong>DRAM 刷新 (Refresh)</strong> 是维持 <strong>DRAM 数据完整性</strong> 的关键操作。</p>
<ul>
<li><strong>刷新必要性</strong>：由于 <strong>DRAM</strong> 使用 <strong>电容存储数据</strong>，电容上的电荷会 <strong>随时间泄漏</strong>。为了防止数据丢失，<strong>每个存储单元</strong> 必须 <strong>定期重新写入 (刷新)</strong>。</li>
<li><strong>刷新周期</strong>：通常，<strong>DRAM</strong> 的 <strong>刷新周期</strong> 为 <strong>每 2 毫秒 (2ms)</strong> 左右。这意味着 <strong>每个存储单元</strong> 必须 <strong>每 2ms 内至少刷新一次</strong>。</li>
<li><strong>刷新机制</strong>：<strong>DRAM 控制器</strong> 负责 <strong>自动执行刷新操作</strong>.<strong>RAS (Row Address Select)</strong> 和 <strong>CAS (Column Address Select)</strong> 信号线 被用于实现 <strong>刷新控制</strong>。.常采用 <strong>行刷新 (Row Refresh)</strong> 方式，即 <strong>每次刷新一行存储单元</strong>。</li>
</ul>
<h3>内存封装类型</h3>
<h4>常见内存封装</h4>
<p><strong>内存芯片</strong> 采用多种 <strong>封装形式 (Package)</strong>，以适应不同的应用场景和安装需求.常见的内存封装类型包括：</p>
<ul>
<li><strong>DIP (Dual In-line Package)</strong>：<strong>双列直插式封装</strong>，引脚呈双行排列，<strong>穿孔安装 (Through-hole)</strong>，体积较大，已较少使用。</li>
<li><strong>SIMM (Single In-line Memory Module)</strong>：<strong>单列直插式内存模块</strong>，引脚呈单行排列，<strong>表面安装 (Surface-mount)</strong>，体积较小，常用于早期计算机。</li>
<li><strong>DIMM (Dual In-line Memory Module)</strong>：<strong>双列直插式内存模块</strong>，引脚呈双行排列，<strong>表面安装</strong>，是目前最常见的内存封装形式。</li>
</ul>
<p><strong>内存封装类型示意图</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/851f11c3e2d2ae1b5b38e26e16b874a62508bd3875eb319b7f1961ebdac92f85/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f366f7762344a6c38326a6435714b502e706e67"><img src="https://camo.githubusercontent.com/851f11c3e2d2ae1b5b38e26e16b874a62508bd3875eb319b7f1961ebdac92f85/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f366f7762344a6c38326a6435714b502e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/05/6owb4Jl82jd5qKP.png" style="max-width: 100%;"></a></p>
<hr>
<h2>Lecture 12: 内存管理与缓存策略</h2>
<h3>访问局部性</h3>
<blockquote>
<p>在计算机科学中，<strong>引用局部性</strong>，也称为<strong>局部性原理</strong>，是指处理器在短时间内重复访问同一组内存位置的趋势。引用局部性有两种基本类型——<strong>时间局部性</strong>和<strong>空间局部性</strong>。时间局部性指的是在相对较短的时间内重复使用特定的数据和/或资源。空间局部性 (也称为数据局部性) 指的是使用相对接近的存储位置中的数据元素。顺序局部性是空间局部性的一种特殊情况，当数据元素以线性方式排列和访问时发生，例如遍历一维数组中的元素。</p>
<p>局部性是计算机系统中发生的一种可预测的行为。表现出强引用局部性的系统非常适合通过使用诸如<strong>缓存</strong>、<strong>内存预取</strong>以及处理器核心的高级<strong>分支预测器</strong>之类的技术来进行性能优化。</p>
</blockquote>
<h4>引用局部性的类型</h4>
<p><strong>引用局部性</strong>是指程序在执行过程中访问存储器的地址倾向于聚集在某些区域的特性。引用局部性是缓存得以有效工作的理论基础，可以分为两种主要类型：</p>
<ul>
<li>
<p><strong>时间局部性 (Temporal Locality)</strong>：</p>
<ul>
<li><strong>定义</strong>：如果某个内存地址在当前时刻被访问，那么在不久的将来，该地址很可能再次被访问。</li>
<li><strong>原理</strong>：程序倾向于重复使用最近访问过的数据和指令。例如，循环、函数调用、计数器等都会导致时间局部性。</li>
<li><strong>缓存优化</strong>：时间局部性使得将最近访问过的数据存储在高速缓存中变得有效，以便后续快速访问。</li>
</ul>
</li>
<li>
<p><strong>空间局部性 (Spatial Locality)</strong>：</p>
<ul>
<li><strong>定义</strong>：如果某个内存地址在当前时刻被访问，那么在不久的将来，其附近的内存地址也很可能被访问。</li>
<li><strong>原理</strong>：程序在访问某个数据时，很可能会访问与其相邻的数据。例如，顺序执行的指令、数组的顺序访问、结构体或对象的成员访问等都表现出空间局部性。</li>
<li><strong>缓存优化</strong>：空间局部性使得可以预取当前访问地址附近的数据块到缓存中，以减少未来访问的延迟。顺序局部性可以被看作是空间局部性的一种特殊情况，例如线性访问数组。</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a851813c123b2d81efac02f6549951ac28426578122cd68da9d8529d5cc07310/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f784c33475631686c734d426b6e72552e706e67"><img src="https://camo.githubusercontent.com/a851813c123b2d81efac02f6549951ac28426578122cd68da9d8529d5cc07310/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f784c33475631686c734d426b6e72552e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/05/xL3GV1hlsMBknrU.png" style="max-width: 100%;"></a></p>
<p><strong>示例</strong>：</p>
<ul>
<li>数据段中的数据访问倾向于展现空间局部性，因为相关数据通常存储在相邻的内存区域。</li>
<li>循环体内部的代码和数据访问倾向于展现时间局部性，因为循环会重复执行相同的指令和访问相同的数据。</li>
</ul>
<h3>缓存 (Cache)</h3>
<p><a href="https://www.bilibili.com/video/BV1aN411T7n8" rel="nofollow">理解计算机Cache (一) ：从块到缓存结构，以及逐步推出映射策略</a></p>
<p><a href="https://www.bilibili.com/video/BV1yg4y1Y7kA" rel="nofollow">理解计算机Cache (二) ：缓存与内存的交互</a></p>
<h4>缓存的工作原理</h4>
<p>**缓存 (Cache)**是一种高速、小容量的存储器，位于 **CPU (中央处理器) **和 **主存储器 (DRAM) **之间，用于缓解 CPU 与主存之间速度不匹配的问题。</p>
<ul>
<li>
<p><strong>数据复制</strong>：处理器当前正在使用的代码和数据，会从速度较慢的 **D-RAM (动态随机存取存储器) **中复制到速度更快的 **S-RAM (静态随机存取存储器) **缓存中。</p>
<p>例如，Intel i7 处理器的二级缓存 (L2 Cache) 为 8MB，通常搭配 8GB 的 DRAM 作为主内存。</p>
</li>
<li>
<p><strong>缓存命中 (Cache Hit) 与缓存未命中 (Cache Miss)</strong>：</p>
<p>当处理器发出内存地址请求时，缓存控制器 (Cache Controller) 会首先检查所需数据是否已存在于缓存中，这称为缓存查找 (Cache Lookup)。</p>
<ul>
<li><strong>缓存命中 (Cache Hit)</strong>：如果数据已存在于缓存中，则称为缓存命中。数据会直接从缓存高速传输到处理器，无需访问速度较慢的主内存，从而减少了访问延迟。</li>
<li><strong>缓存未命中 (Cache Miss)</strong>：如果数据不在缓存中，则称为缓存未命中。此时，缓存控制器需要从主内存读取数据并发送给处理器 (速度较慢) 。同时，为了利用局部性原理，缓存控制器会将读取的数据的副本也存入缓存，以便后续可能的访问。</li>
<li><strong>缓存命中率 (Hit Rate)</strong>：S-RAM 缓存命中次数占总读取次数的百分比，称为缓存命中率，是衡量缓存性能的重要指标。个人电脑的缓存命中率通常可以高达 90% 甚至更高。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>：缓存的工作原理类似于在处理器和主存之间建立一个“快速通道”，通过存储常用数据，减少了处理器访问慢速主存的次数，从而提高了程序的整体执行速度。</p>
<p><strong>x86 缓存模型</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/420d9da845da67557afe1fd8a6c5e655fc7f04d0cc86abd2391eb58510fc7b00/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f46456e3752765459396468627770742e706e67"><img src="https://camo.githubusercontent.com/420d9da845da67557afe1fd8a6c5e655fc7f04d0cc86abd2391eb58510fc7b00/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f46456e3752765459396468627770742e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/05/FEn7RvTY9dhbwpt.png" style="max-width: 100%;"></a></p>
<p><strong>典型缓存参数</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/25c4b197eec1f105268411d2a7e92cebd4ab1d730184ede213fd36787c33810d/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f694239527a54514832586c764f6f4b2e706e67"><img src="https://camo.githubusercontent.com/25c4b197eec1f105268411d2a7e92cebd4ab1d730184ede213fd36787c33810d/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30352f694239527a54514832586c764f6f4b2e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/05/iB9RzTQH2XlvOoK.png" style="max-width: 100%;"></a></p>
<h4>缓存组织方式</h4>
<p>缓存控制器包含一个缓存目录 (Cache Directory)，用于管理缓存中的数据。常见的缓存组织方式包括：</p>
<ul>
<li><strong>直接映射缓存 (Direct Mapped Cache)</strong>：
<ul>
<li><strong>单页映射</strong>：缓存被组织成只包含内存中单个页面的副本。</li>
<li><strong>地址冲突与抖动 (Thrashing)</strong>：如果处理器频繁地在不同页面之间快速切换，可能会导致抖动 (Thrashing) 现象。
<ul>
<li>抖动指的是缓存频繁地被新页面替换，而旧页面又很快被重新访问，导致缓存命中率极低，系统性能急剧下降。</li>
<li>直接映射缓存容易发生抖动，因为它对每个主存块的缓存位置是固定的。</li>
</ul>
</li>
<li><strong>性能影响</strong>：抖动会显著降低系统速度。</li>
</ul>
</li>
<li><strong>双路组相联缓存 (Two-Way Set Associative Cache)</strong>：
<ul>
<li><strong>双缓存组</strong>：使用两个独立的缓存 (或称为路 (Way)) 来存储数据。</li>
<li><strong>页面快速切换</strong>：允许在两个缓存组之间快速切换页面，降低了抖动的可能性。</li>
<li><strong>提高命中率</strong>：相较于直接映射缓存，组相联缓存提供了更高的灵活性，可以减少地址冲突，提高缓存命中率。</li>
</ul>
</li>
<li><strong>全相联缓存 (Fully Associative Cache)</strong>：
<ul>
<li><strong>任意位置存放</strong>：主存中的任何数据块可以被放置在缓存中的任何位置。</li>
<li><strong>缓存目录查找</strong>：每个缓存条目的缓存目录需要存储完整的 DRAM 地址和关联的数据。</li>
<li><strong>查找开销</strong>：由于需要搜索整个缓存目录来查找数据，查找速度可能较慢。</li>
<li><strong>数据替换策略</strong>：需要复杂的数据替换策略来决定当缓存满时，如何丢弃旧数据。例如：
<ul>
<li>随机丢弃 (Random Discard)：随机选择缓存行进行替换。</li>
<li>统一丢弃 (Uniform Discard)：按照某种预定规则丢弃缓存行。</li>
<li><strong>最近最少使用 (LRU, Least Recently Used)</strong>：替换最近最少被访问的缓存行。LRU 策略的实现较为复杂，需要记录每个缓存行的访问历史。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>直接映射缓存 (Direct Mapped Cache)</h4>
<p>直接映射缓存的地址映射机制如下 (以 80386 处理器为例)：</p>
<ul>
<li><strong>地址总线</strong>：80386 处理器具有 32 位地址总线，可以访问 2³²＝4 GBytes 的内存空间。</li>
<li><strong>数据总线</strong>：数据总线也是 32 位宽，每 4 个字节组成一个行 (Line)。</li>
<li><strong>缓存容量</strong>：80386 缓存包含 8196 行，总容量为 32KB (8196 行 * 4 字节/行 = 32784 字节 ≈ 32KB)。</li>
<li><strong>缓存块 (Block)</strong>：缓存将行组织成块 (Block)，每 8 行组成一个块，每个块大小为 32 字节 (8 行 * 4 字节/行 = 32 字节)。</li>
<li><strong>内存页面划分</strong>：缓存控制器将 4GB 内存空间划分为 2³²/32768＝131072 个页面 (Page)，每个页面大小为 32KB。</li>
<li><strong>直接映射规则</strong>：主内存的特定行总是映射到缓存中的相同行位置。</li>
<li><strong>缓存目录 (Tag Directory)</strong>：缓存目录存储每个缓存行对应的主内存页面位置 (称为标记 (Tag)).标记用于区分缓存行中存储的数据来自主内存的哪个页面。</li>
</ul>
<p>**内存地址分解 (虚拟地址) **</p>
<ul>
<li>A15-A31 (高 17 位)：标记 (Tag) 位，用于设置主内存中的页面。</li>
<li>A5-A14 (中间 10 位)：块索引 (Block Index) 位，用于设置缓存中的块号。</li>
<li>A2-A4 (低 3 位)：行索引 (Line Index) 位，用于设置块内的行号。</li>
<li>A0-A1 (最低 2 位)：字节偏移 (Byte Offset) 位，用于选择行内的特定字节。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c2fdd62546ba549b518c80da111b785b5ac333585330693384cab52c76a45820/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f46354f5a6f346b74567038636579442e706e67"><img src="https://camo.githubusercontent.com/c2fdd62546ba549b518c80da111b785b5ac333585330693384cab52c76a45820/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f46354f5a6f346b74567038636579442e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/06/F5OZo4ktVp8ceyD.png" style="max-width: 100%;"></a></p>
<p><strong>内存访问流程</strong>：</p>
<p><strong>内存访问流程</strong></p>
<ol>
<li><strong>CPU 生成虚拟地址：</strong> CPU 在执行指令时，生成一个 32 位 (或其他位数) 的虚拟地址，用于访问内存中的数据。</li>
<li><strong>缓存控制器接收虚拟地址：</strong> 缓存控制器拦截 CPU 发出的虚拟地址。</li>
<li><strong>缓存查找 (使用虚拟地址) ：</strong> 缓存控制器从虚拟地址中提取：
<ul>
<li><strong>标记位 (Tag Bits)：</strong> 用于与缓存目录中的标记进行比较。</li>
<li><strong>块索引位 (Index Bits)：</strong> 用于在缓存目录中选择对应的条目。</li>
<li><strong>块内偏移 (Offset Bits)：</strong> 用于在缓存块中选择特定的字节。<br>
缓存控制器使用索引位在缓存目录中找到对应的条目，并将提取的标记位与该条目中的标记进行比较.同时，检查该缓存行的有效位。</li>
</ul>
</li>
<li><strong>缓存命中/未命中判断：</strong>
<ul>
<li><strong>缓存命中 (Cache Hit)：</strong> 如果标记匹配且有效位为真，则发生缓存命中。</li>
<li><strong>数据读取：</strong> 缓存控制器使用偏移位从缓存块中读取对应的数据，并将数据返回给 CPU.地址转换到此为止不需要进行。</li>
<li><strong>缓存未命中 (Cache Miss)：</strong> 如果标记不匹配或有效位为假，则发生缓存未命中。</li>
</ul>
</li>
<li><strong>MMU 地址转换 (仅在缓存未命中时)：</strong>
<ul>
<li>缓存控制器将 <strong>虚拟地址</strong> 发送给 MMU。</li>
<li><strong>物理地址生成：</strong> MMU 将虚拟地址转换为物理地址。</li>
</ul>
</li>
<li><strong>内存访问 (DRAM)：</strong>
<ul>
<li>MMU 将 <strong>物理地址</strong> 发送给内存控制器。</li>
<li>内存控制器访问 DRAM，读取所需的数据。</li>
</ul>
</li>
<li><strong>缓存更新 (在缓存未命中时)：</strong>
<ul>
<li>缓存控制器将从 DRAM 中获取的数据存储到缓存中.这可能涉及到缓存行的替换 (Eviction)，例如使用 LRU (Least Recently Used) 算法。</li>
<li>缓存控制器更新缓存目录中的标记位和有效位。</li>
</ul>
</li>
<li><strong>数据返回给 CPU：</strong> 缓存控制器将从缓存中读取的数据 (现在数据已经在缓存中了) 返回给 CPU。</li>
</ol>
<h4>抖动 (Thrashing) 问题</h4>
<p>**抖动 (Thrashing)**问题在直接映射缓存中尤为突出。</p>
<ul>
<li><strong>抖动场景</strong>：当程序循环重复访问内存中不同页面的相同块索引位置。</li>
<li><strong>缓存冲突</strong>：由于直接映射缓存的映射规则，页面 0 的 X 块和页面 1 的 X 块会映射到缓存中的相同位置。</li>
<li><strong>频繁替换</strong>：每次访问都会导致缓存未命中，需要从 DRAM 重新加载数据到缓存，并替换之前缓存的内容。</li>
<li><strong>性能下降</strong>：导致每次内存访问都变成 DRAM 访问，缓存形同虚设，内存访问延迟增大，系统性能严重下降。</li>
</ul>
<p>例如，如果程序反复调用地址 0 和地址 32,768，则可能发生颠簸 (thrashing) ，导致缓存命中率严重下降！！！</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d9fabdb9f7ce241e5303bbb6f72638d615f77e7965f7a9f8c22945dd8fb508b9/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f48694e6447635a6f4b44354a5146492e706e67"><img src="https://camo.githubusercontent.com/d9fabdb9f7ce241e5303bbb6f72638d615f77e7965f7a9f8c22945dd8fb508b9/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f48694e6447635a6f4b44354a5146492e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/06/HiNdGcZoKD5JQFI.png" style="max-width: 100%;"></a></p>
<h4>全相联缓存 (Fully Associative Cache)</h4>
<p><strong>全相联缓存</strong>提供了最大的灵活性，但实现成本和复杂度也最高。</p>
<ul>
<li><strong>任意位置映射</strong>：主存中的任何行可以被写入缓存中的任意位置。</li>
<li><strong>缓存目录开销</strong>：缓存目录中的每个标记必须是完整的 30 位地址 (或其他位数，取决于地址空间大小) ，以唯一标识缓存行对应的主存地址。</li>
<li><strong>查找开销大</strong>：为了查找数据，必须搜索整个缓存目录，查找时间较长。</li>
</ul>
<p><strong>全相联缓存的缺点</strong>：</p>
<ol>
<li><strong>查找速度慢</strong>：需要遍历整个缓存目录才能确定缓存是否命中。</li>
<li><strong>替换策略复杂</strong>：当缓存满时，需要复杂的替换策略 (如 LRU) 来丢弃旧数据.LRU 策略的实现需要维护每个缓存行的访问历史信息，增加了硬件开销。</li>
</ol>
<p>全相联缓存由于实现复杂，成本高昂，在 PC (个人计算机) 中不常使用 (尤其是在 1995 年左右) 。</p>
<h4>组相联缓存 (Set Associative Cache)</h4>
<p><strong>组相联缓存</strong>平衡了<strong>直接映射缓存</strong>的抖动问题和<strong>全相联缓存</strong>高成本问题</p>
<ul>
<li><strong>多路缓存</strong>：将缓存分成多个组 (Set)，每个组包含多个路 (Way) (例如双路组相联就是每个组包含两条路，即两个独立的缓存块) 。</li>
<li><strong>灵活映射</strong>：主存中的一个块可以映射到组内任意一路的缓存行。</li>
<li><strong>地址映射</strong>：内存地址被划分为标记 (Tag)、组索引 (Set Index) 和块偏移 (Block Offset) 字段.组索引用于选择缓存组，标记用于在组内区分不同的主存块。</li>
</ul>
<p><strong>双路组相联缓存示意图</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/fef431e99fa5e7f7a42f60fe26c283d124f2b27ea0b3376998f6696fc35f92c8/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f6f6a55724d6239353767415931514f2e706e67"><img src="https://camo.githubusercontent.com/fef431e99fa5e7f7a42f60fe26c283d124f2b27ea0b3376998f6696fc35f92c8/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f6f6a55724d6239353767415931514f2e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/06/ojUrMb957gAY1QO.png" style="max-width: 100%;"></a></p>
<ul>
<li><strong>抖动缓解</strong>：在抖动场景中，例如程序循环访问页面 0 的 X 块和页面 1 的 X 块，双路组相联缓存可以将页面 0 的 X 块缓存到 Way 0，将页面 1 的 X 块缓存到 Way 1。</li>
<li><strong>减少冲突</strong>：从而避免了缓存冲突，提高了缓存命中率，改善了性能。</li>
<li><strong>替换策略</strong>：当缓存组满时，需要替换策略 (如 <strong>LRU (Least Recently Used) , 最近最少使用算法</strong>) 来决定替换哪一路的缓存行.LRU 位用于标记每个缓存路的最近使用情况，以便优先替换最近最少使用的缓存路。</li>
</ul>
<h4>缓存效率</h4>
<p>缓存虽然在空间容量上远小于内存，但它比内存快得多，在程序执行速度上起着至关重要的作用。由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此当 CPU 尝试访问的数据不在缓存中时，就会发生缓存未命中 (cache miss) ，此时 CPU 不得不从速度较慢的内存中加载所需数据。</p>
<h4>缓存未命中的原因</h4>
<ul>
<li><strong>强制性未命中 (Compulsory Miss)</strong>：
<ul>
<li><strong>首次访问</strong>：也称为冷启动未命中 (Cold Start Miss)。当程序第一次访问某个内存块时，该块不在缓存中，必须从 DRAM 中读取.强制性未命中是不可避免的。</li>
</ul>
</li>
<li><strong>容量未命中 (Capacity Miss)</strong>：
<ul>
<li><strong>缓存容量不足</strong>：如果程序频繁使用的内存块数量超过了缓存的容量，就会发生容量未命中.即使缓存已经装满了数据，但程序需要访问的数据仍然不在缓存中，需要从 DRAM 读取并替换缓存中的旧数据。</li>
<li>抖动也是容量未命中的一种表现形式。</li>
</ul>
</li>
<li><strong>冲突未命中 (Conflict Miss)</strong>：
<ul>
<li><strong>地址冲突</strong>：在直接映射缓存或组相联缓存中，由于地址映射的限制，不同的主存块可能映射到缓存中的相同位置 (或同一个组) .当程序频繁访问映射到相同缓存位置的不同主存块时，就会发生冲突未命中。</li>
</ul>
</li>
</ul>
<h4>缓存的效果评估：Amdahl 定律</h4>
<p>**Amdahl 定律 (Amdahl's Law)**用于评估通过改进系统资源 (例如使用缓存) 所能获得的性能提升。</p>
<p><strong>Amdahl 定律公式</strong>：</p>
<p>$Speedup = \frac{1}{(1-p) + \frac{p}{s}}$</p>
<p>公式中：</p>
<ul>
<li>Speedup (加速比)：使用改进资源后，系统性能提升的倍数。</li>
<li>s (资源改进带来的速度提升)：改进的资源 (例如缓存) 比原有资源 (例如 DRAM) 的速度提升倍数。</li>
<li>p (可加速部分占比)：程序执行时间中，可以受益于资源改进的部分所占的比例。</li>
</ul>
<p><strong>缓存性能提升示例</strong>：</p>
<p>假设：</p>
<ul>
<li>缓存将内存访问速度提升 10 倍 (从 100ns DRAM 访问时间降低到 10ns 缓存访问时间)，即 s＝10。</li>
<li>典型程序的缓存命中率为 95%，即程序执行时间中有 95% 的时间受益于缓存加速，p＝0.95。</li>
</ul>
<p><strong>计算加速比</strong>：</p>
<p>$Speedup = \frac{1}{(1-0.95) + \frac{0.95}{10}} = \frac{1}{0.05 + 0.095} = \frac{1}{0.145} \approx 6.89$</p>
<p><strong>结论</strong>：加入缓存后，内存访问速度比仅使用 DRAM 时提高了约 6.89 倍。</p>
<h4>有效访问时间 (EAT) 估算</h4>
<p>**有效访问时间 (Effective Access Time, EAT)**用于综合评估包含缓存的内存系统的平均访问性能。</p>
<p><strong>EAT 计算公式</strong>：</p>
<p>$\text{EAT} = (1 - \text{命中率}) \times \text{缓存访问时间} + \text{命中率} \times (\text{缓存访问时间} + \text{未命中惩罚})$</p>
<p><strong>EAT 估算示例</strong>：</p>
<p>假设：</p>
<ul>
<li>缓存访问时间：10 纳秒 (ns)。</li>
<li>缓存未命中率：5% (命中率 95%)，即 p＝0.95，未命中率 1-p＝0.05。</li>
<li>DRAM 访问时间：100 纳秒 (ns)。</li>
</ul>
<p><strong>计算 EAT</strong>：</p>
<p>$\begin{aligned} \text{EAT} &amp;= (1 - 0.95) \times 10 \text{ns} + 0.95 \times 100 \text{ns} \ &amp;= 0.05 \times 10 \text{ns} + 0.95 \times 100 \text{ns} \ &amp;= 0.5 \text{ns} + 95 \text{ns} \ &amp;\approx 14.5 \text{ns} \end{aligned}$</p>
<p><strong>加速比验证</strong>：</p>
<p>$\text{加速比} = \frac{\text{DRAM 访问时间}}{\text{EAT}} = \frac{100 \text{ns}}{14.5 \text{ns}} \approx 6.89$</p>
<p><strong>结论</strong>：内存系统的有效访问时间约为 14.5 纳秒，相较于 100 纳秒的 DRAM 访问时间，速度提升约为 6.89 倍，与 Amdahl 定律的计算结果一致。</p>
<h4>写策略 (Write Policies)</h4>
<p>**写策略 (Write Policies)**定义了数据写入缓存时，如何保证缓存和主内存数据一致性的策略。</p>
<ul>
<li>
<p><strong>写直通 (Write-Through)</strong>：</p>
<ul>
<li><strong>同步写入</strong>：每次向缓存写入数据时，同时也将数据写入主内存。</li>
<li><strong>数据一致性</strong>：缓存和主内存中的数据始终保持一致。</li>
<li><strong>写操作延迟</strong>：写操作的速度受限于 DRAM 的速度，写入速度较慢。</li>
<li><strong>读操作高速</strong>：读操作可以从高速缓存中进行，速度较快。</li>
</ul>
</li>
<li>
<p><strong>写回 (Write-Back)</strong>：</p>
<ul>
<li><strong>延迟写入</strong>：数据写入操作只写入缓存，暂不写入主内存。</li>
<li><strong>数据标记</strong>：被修改过的缓存行会被标记为“脏 (Dirty)”。</li>
<li><strong>替换时写回</strong>：只有当脏缓存行需要被替换 (例如，缓存满时) 时，才将脏数据写回主内存。</li>
<li><strong>写操作高速</strong>：写操作速度仅受限于缓存速度，写入速度较快。</li>
<li><strong>读操作高速</strong>：读操作也可以从高速缓存中进行，速度较快。</li>
<li><strong>数据一致性挑战</strong>：缓存和主内存数据在一段时间内可能不一致，数据一致性维护较为复杂.需要更复杂的机制 (例如监听 (Snooping) 或目录 (Directory) 协议) 来保证多处理器系统中缓存一致性。</li>
<li><strong>优点</strong>：减少了对主内存的写操作次数，提高了写性能。</li>
</ul>
</li>
</ul>
<p><strong>DMA (直接内存访问) 与缓存一致性</strong>：</p>
<p>**DMA (Direct Memory Access, 直接内存访问) **允许某些硬件设备 (例如 DMA 控制器) 直接读写主存储器，无需 CPU 的参与.DMA 操作可能导致缓存与主内存之间的数据不一致问题。</p>
<ul>
<li><strong>写直通缓存</strong>：写直通缓存在一定程度上可以缓解 DMA 缓存一致性问题，因为每次缓存写入都会同步更新主内存。</li>
<li><strong>写回缓存</strong>：写回缓存需要更复杂的机制来处理 DMA 缓存一致性，例如缓存刷新 (Cache Flush) 操作，强制将脏缓存行写回主内存，以确保 DMA 设备读取到最新的数据。</li>
</ul>
<h4>多级缓存 (Multilevel Caches)</h4>
<p>**多级缓存 (Multilevel Caches)**是现代高性能处理器中常用的缓存组织方式。</p>
<ul>
<li><strong>分级结构</strong>：采用多层缓存结构，例如 L1 缓存 (一级缓存) 、L2 缓存 (二级缓存) 、L3 缓存 (三级缓存) 等。</li>
<li><strong>速度与容量平衡</strong>：
<ul>
<li>**L1 缓存 (一级缓存) **：容量最小，速度最快，通常集成在 CPU 核心内部.L1 缓存追求最低的访问延迟，通常可以实现零等待状态 (Zero Wait State) 访问，即 <code class="notranslate">mov ax,[bx]</code> 指令可以在最少的时钟周期内完成。.型容量为 1KB - 32KB。</li>
<li>**L2 缓存 (二级缓存) **：容量比 L1 大，速度比 L1 慢，但比主存快.通常集成在 CPU 芯片上，但不一定在核心内部。.型容量为 2MB - 8MB。</li>
<li>**L3 缓存 (三级缓存) **：容量最大，速度最慢 (但仍比主存快).通常多个 CPU 核心共享 L3 缓存。.型容量可以达到数 MB 到数十 MB。</li>
</ul>
</li>
<li><strong>访问顺序</strong>：CPU 访问内存时，首先查找 L1 缓存，如果 L1 未命中，则查找 L2 缓存，依此类推，直到最后一级缓存或主内存。</li>
</ul>
<p><strong>示例参数</strong>：</p>
<ul>
<li><strong>一级缓存 (L1 Cache)</strong>: 例如 1KB - 32KB，零等待状态。</li>
<li><strong>二级缓存 (L2 Cache)</strong>: 例如 2MB，500MHz 运行频率。</li>
<li><strong>主存储器 (Main Memory)</strong>: 例如最大 64GB 容量。</li>
</ul>
<h4>DMA</h4>
<p>**DMA (Direct Memory Access, 直接内存访问) **技术允许某些硬件设备 (例如 DMA 控制器) 直接读写主存储器，无需 CPU 的参与。</p>
<ul>
<li><strong>CPU 解放</strong>：DMA 技术可以解放 CPU，使 CPU 可以并行处理其他任务，提高系统整体效率。</li>
<li><strong>高速数据传输</strong>：DMA 适用于高速数据传输的场景，例如硬盘数据读取、图形图像数据传输、音频数据传输等。</li>
<li><strong>应用设备</strong>：DMA 常用于帧捕获卡 (Frame Grabber)、声卡 (Sound Card) 等设备。</li>
</ul>
<h4>DMA 控制器 (DMA Controller)</h4>
<p>**DMA 控制器 (DMA Controller) **是实现 DMA 传输的关键硬件组件。</p>
<p><strong>DMA 控制器结构示意图</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/30587d858947a48af542a91c8c0b8036ec868d460381baf66c5ab1f508a61f7d/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f6f434f62525658716d6472326c41762e706e67"><img src="https://camo.githubusercontent.com/30587d858947a48af542a91c8c0b8036ec868d460381baf66c5ab1f508a61f7d/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f6f434f62525658716d6472326c41762e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/06/oCObRVXqmdr2lAv.png" style="max-width: 100%;"></a></p>
<p><strong>DMA 传输序列 (DMA Sequence)</strong></p>
<p>DMA 控制器通过一系列握手信号与 CPU 和外围设备协同工作，完成 DMA 数据传输。</p>
<ol>
<li>**DMA 请求：外围设备 (例如智能磁盘控制器) 准备好数据后，设置 DREQ 信号线为高电平，请求 DMA 传输。</li>
<li>**HOLD 请求：DMA 控制器接收到 DREQ 信号后，向 CPU 发送 HOLD 请求信号 (HOLD)。</li>
<li><strong>HOLD 响应</strong>：CPU 在完成当前总线周期后，释放总线控制权，并将 HLDA 信号线拉高，响应 DMA 请求。</li>
<li><strong>总线控制权转移</strong>：DMA 控制器接管数据总线、地址总线和控制总线的控制权.CPU 暂时与内存断开连接。</li>
<li><strong>DMA 确认</strong>：DMA 控制器向外围设备发送 DMA 确认信号 (DACK)，允许设备开始 DMA 传输。</li>
<li><strong>数据传输</strong>：外围设备 (例如智能磁盘驱动器) 通过 DMA 控制器直接向主内存写入数据或从主内存读取数据。</li>
<li><strong>HOLD 释放</strong>：DMA 传输完成后，DMA 控制器释放 HOLD 请求。</li>
<li><strong>CPU 恢复总线控制</strong>：CPU 重新获得总线控制权，HLDA 信号线被拉低。</li>
</ol>
<h3>ROM (只读存储器)</h3>
<p>**ROM (Read-Only Memory, 只读存储器) **是一种非易失性存储器，断电后数据不会丢失.ROM 通常用于存储固件 (Firmware) 和引导代码 (Boot Sequence Code)，例如 BIOS (基本输入/输出系统)。</p>
<h4>ROM 的类型</h4>
<ul>
<li>
<p><strong>掩膜 ROM (Mask Programmed ROM)</strong>：</p>
<ul>
<li><strong>制造时编程</strong>：程序在 ROM 芯片制造过程中被永久写入，出厂后无法更改。</li>
<li><strong>成本高，适用于大批量生产</strong>。</li>
</ul>
</li>
<li>
<p>**PROM (可编程 ROM, Programmable ROM) **：</p>
<ul>
<li><strong>一次性编程</strong>：用户可以使用 PROM 编程器写入程序一次.编程过程通常通过熔断器件内部的熔丝 (Fusible Links) 来实现。.旦编程，无法修改。</li>
</ul>
</li>
<li>
<p>**EPROM (可擦除可编程 ROM, Erasable Programmable ROM) **：</p>
<ul>
<li><strong>多次编程</strong>：用户可以多次擦除和重写程序。</li>
<li><strong>紫外线擦除</strong>：EPROM 通过紫外线 (UV Light) 照射擦除存储的数据.擦除过程需要将芯片从电路板上取下，并使用紫外线擦除器照射一段时间。</li>
<li><strong>电荷存储</strong>：EPROM 使用 FET (场效应晶体管) 栅极上的电荷存储数据.高电压编程会在绝缘栅极上注入电荷，改变 FET 的阈值电压，从而表示不同的数据状态。</li>
</ul>
</li>
</ul>
<p><strong>EPROM 编程与擦除原理示意图</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a08adb745664566fcd44f28fd1ae78eef2425c905ef17d6d23c6896d19f41d26/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f516a533166454c696155686446735a2e706e67"><img src="https://camo.githubusercontent.com/a08adb745664566fcd44f28fd1ae78eef2425c905ef17d6d23c6896d19f41d26/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f516a533166454c696155686446735a2e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/06/QjS1fELiaUhdFsZ.png" style="max-width: 100%;"></a></p>
<ul>
<li>**EEPROM (电可擦除可编程 ROM, Electrically Erasable Programmable ROM) **：
<ul>
<li><strong>电可擦除和编程</strong>：EEPROM 可以通过电信号进行擦除和重写，无需紫外线照射，也无需从电路板上取下芯片。</li>
<li><strong>字节或块擦除</strong>：EEPROM 可以按字节 (Byte) 或按块 (Block) 进行擦除，灵活性更高。</li>
<li><strong>应用广泛</strong>：EEPROM 常用于存储 BIOS 设置、固件升级等.Flash 存储器 (闪存) 是 EEPROM 的一种发展，具有更高的擦除和写入速度，更大的存储容量。</li>
</ul>
</li>
</ul>
<p><strong>2716 EPROM 引脚图</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3d8e3447fba6a95471b3aa70d7ae5a43973322ec73840b34cf02096c425c8801/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f5553353666637031427969496277502e706e67"><img src="https://camo.githubusercontent.com/3d8e3447fba6a95471b3aa70d7ae5a43973322ec73840b34cf02096c425c8801/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f5553353666637031427969496277502e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/06/US56fcp1ByiIbwP.png" style="max-width: 100%;"></a></p>
<h4>ROM 组合 (或与其他类型存储器组合)</h4>
<p>ROM 芯片 (或其他类型的存储器芯片) 可以通过芯片选择 (CS, Chip Select) 信号线和多路复用器 (Demultiplexer) 组合在同一内存空间中。</p>
<ul>
<li><strong>地址解码</strong>：多路复用器根据高位地址线译码产生不同的 CS 信号。</li>
<li><strong>芯片选择</strong>：每个 ROM 芯片的 CS 引脚连接到多路复用器的不同输出端。</li>
<li><strong>内存扩展</strong>：通过控制 CS 信号，可以选择访问特定的 ROM 芯片，从而扩展内存空间。</li>
</ul>
<p><strong>ROM 组合应用示意图</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/947e049cae86ea6ca36355a9240af7e0f09b2a95580beb972c75f26baa1f7dcb/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f53565068334c544b6932514d4a52422e706e67"><img src="https://camo.githubusercontent.com/947e049cae86ea6ca36355a9240af7e0f09b2a95580beb972c75f26baa1f7dcb/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30362f53565068334c544b6932514d4a52422e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/06/SVPh3LTKi2QMJRB.png" style="max-width: 100%;"></a></p>
<h3>虚拟内存 (Virtual Memory)</h3>
<p><a href="https://www.bilibili.com/video/BV1Ea411s7YT" rel="nofollow">【CSAPP-深入理解计算机系统】9-1. 虚拟内存</a></p>
<h4>虚拟内存的概念</h4>
<p>**虚拟内存 (Virtual Memory)**是一种内存管理技术，将磁盘 (硬盘) 的一部分作为内存的扩展来使用，使得程序可以访问比实际物理内存更大的地址空间。</p>
<ul>
<li>**虚拟地址空间 (Virtual Address Space) **：CPU 寻址的地址空间称为虚拟地址空间.在典型的 PC 系统中，虚拟地址空间可以是 64GB 甚至更大。</li>
<li>**物理内存 (Physical Memory) **：实际安装在计算机上的 RAM 容量称为物理内存 (或主内存) .例如 4GB RAM。</li>
<li><strong>地址映射</strong>：虚拟内存系统负责将虚拟地址映射到物理地址.并非所有虚拟地址都映射到物理内存。</li>
<li>**页面交换 (Paging) **：虚拟内存系统将虚拟地址空间和物理内存都划分成固定大小的块，称为页面 (Page).数据以页面为单位在物理内存和外部存储器 (硬盘) 之间交换。</li>
</ul>
<h4>虚拟内存的工作原理</h4>
<ul>
<li><strong>外存扩展</strong>：虚拟内存系统使用外部存储器 (硬盘) 作为主内存的扩展.不常用的数据页面被换出 (Swap Out) 到硬盘上，释放物理内存空间。</li>
<li><strong>按需调入</strong>：当 CPU 需要访问不在物理内存中的数据页面 (称为缺页 fault, Page Fault) 时，操作系统负责将所需页面从硬盘调入 (Swap In) 物理内存.如果物理内存已满，则需要替换物理内存中暂时不用的页面到硬盘上，腾出空间加载新页面。</li>
<li><strong>缓存相似性</strong>：虚拟内存的页面交换机制与缓存的工作方式类似.物理内存可以看作是硬盘数据的缓存。</li>
</ul>
<h4>虚拟内存的性能</h4>
<ul>
<li><strong>性能影响</strong>：虚拟内存的性能严重依赖于页面交换的效率.如果程序频繁发生缺页 fault，导致频繁的硬盘读写操作，系统性能会大幅下降，这被称为“磁盘抖动 (Disk Thrashing)”。拟内存的未命中惩罚 (Miss Penalty) 非常高，可能高达 100,000 个 CPU 时钟周期。</li>
<li><strong>内存不足与虚拟内存</strong>：在 Windows 等操作系统中，如果同时打开多个应用程序，容易耗尽物理内存.此时，操作系统会开始使用虚拟内存。系统性能会显著降低，运行速度变得非常缓慢。</li>
</ul>
<hr>
<h2>Lecture 13 A: 磁盘与CD-ROM</h2>
<h3>机械硬盘的结构</h3>
<ul>
<li>
<p><strong>盘片 (Platters):</strong></p>
<ul>
<li>
<p>这是存储数据的载体，通常由铝合金或玻璃制成，表面涂有磁性材料。</p>
</li>
<li>
<p>一个硬盘中可能包含多个盘片，增加存储容量。</p>
</li>
<li>
<p>盘片正反两面都可以用来存储数据。</p>
</li>
<li>
<p>盘片被格式化成磁道 (Tracks) 和扇区 (Sectors)。</p>
</li>
</ul>
</li>
<li>
<p><strong>磁头 (Heads):</strong></p>
<ul>
<li>
<p>用于读取和写入盘片上的数据。</p>
</li>
<li>
<p>每个盘片的每个面都有一个对应的磁头。</p>
</li>
<li>
<p>磁头通过电磁感应原理，改变盘片表面的磁性方向来写入数据，或者感应磁性方向来读取数据。</p>
</li>
<li>
<p>磁头悬浮在盘片表面上方极小的距离 (几纳米) ，高速旋转时不会直接接触盘片，依靠气垫效应 (air bearing) 来维持。</p>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/20193ceb0c7b96b303510a57daf19261765c226dbc35443fdc67d82996e42525/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f5557726d76694d4e7468584464426f2e706e67"><img src="https://camo.githubusercontent.com/20193ceb0c7b96b303510a57daf19261765c226dbc35443fdc67d82996e42525/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f5557726d76694d4e7468584464426f2e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/UWrmviMNthXDdBo.png" style="max-width: 100%;"></a></p>
<p>在每一个盘片上有多个磁道，每个磁道可以分为多个扇区，通常情况下，每个扇区可以存储 512 byte 的数据</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/fd88c66b5bf79a21812d5a26048edd191448393f2a71488f53438bdb9666ddc1/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f71564f706c356448654b75595451582e706e67"><img src="https://camo.githubusercontent.com/fd88c66b5bf79a21812d5a26048edd191448393f2a71488f53438bdb9666ddc1/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f71564f706c356448654b75595451582e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/qVOpl5dHeKuYTQX.png" style="max-width: 100%;"></a></p>
<h3>编码方式</h3>
<p><strong>两个事实：</strong></p>
<ul>
<li>磁记录介质通过改变磁极方向 (即磁通转换) 来存储数据。 磁通转换越频繁，单位面积内能存储的信息量就越少。</li>
<li>限制连续 0 的数量可以优化磁记录过程。 长时间没有磁通转换可能会导致时钟同步困难和信号衰减。 通过控制游程长度，可以避免这些问题，并提高存储密度。</li>
</ul>
<h4>FM 编码</h4>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b62a927b43b5ef7b9e38577c0de52ca6dea4321fea3f8c0a23536dc656e9b0b8/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f6b457831593979577252465a5875442e706e67"><img src="https://camo.githubusercontent.com/b62a927b43b5ef7b9e38577c0de52ca6dea4321fea3f8c0a23536dc656e9b0b8/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f6b457831593979577252465a5875442e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/kEx1Y9yWrRFZXuD.png" style="max-width: 100%;"></a></p>
<p>在 FM 编码中，每个位周期 (Bit Cell) 都包含一个时钟转换 (Clock Transition) ，位于位周期的起始位置。</p>
<ul>
<li><strong>0</strong> 在位周期中间<strong>没有</strong>数据转换。</li>
<li><strong>1</strong> 在位周期中间<strong>有</strong>数据转换。</li>
</ul>
<h4>锁相环</h4>
<p>一个能从数据信号中提取时钟信号的装置</p>
<h4>MFM 编码</h4>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/923722782953a1c673104b8fe52034ca44f269daed9a4044782bbfdb71aebd76/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f763957435545696b787a51726d4a362e706e67"><img src="https://camo.githubusercontent.com/923722782953a1c673104b8fe52034ca44f269daed9a4044782bbfdb71aebd76/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f763957435545696b787a51726d4a362e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/v9WCUEikxzQrmJ6.png" style="max-width: 100%;"></a></p>
<p>MFM 编码减少了磁通转换的次数，这意味着在单位时间内需要写入的磁通变化更少。这降低了对磁记录系统的带宽要求，并减少了因频繁转换而引起的信号失真。</p>
<ul>
<li>
<p><strong>0</strong> 如果前一位是 0，则在位周期开始处进行转换；如果前一位是 1，则不进行转换。</p>
</li>
<li>
<p><strong>1</strong> 在位周期开始处进行转换。</p>
</li>
</ul>
<h4>RLL 编码</h4>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/1d7eeff763094004cb56fe79100548ce3889648e634f26c12f015b50fa2336af/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f7275676c5136355a44565945326e612e706e67"><img src="https://camo.githubusercontent.com/1d7eeff763094004cb56fe79100548ce3889648e634f26c12f015b50fa2336af/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f7275676c5136355a44565945326e612e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/ruglQ65ZDVYE2na.png" style="max-width: 100%;"></a></p>
<p>RLL 编码通过限制连续的 0 (零) 的数量来优化磁记录过程。说是比 MFM 编码好 40%</p>
<h3>性能参数</h3>
<p><strong>访问时间 (Access Time):</strong> 从请求数据到接收到数据之间的时间，通常为 20 mS。</p>
<p><strong>寻道时间 (Seek Time):</strong> 磁头移动到特定位置所需的时间，通常为 12 mS。</p>
<p><strong>延迟时间 (Latency Time):</strong>  例如锁相环 (PLL) 等开始从磁道读取数据所需的时间，为 8 mS。</p>
<p><strong>传输速率 (Transfer Rate):</strong> 从磁盘以持续速率读取数据的速率。10 Mbits/Sec (硬盘 HD)，1 Mbit/sec (软盘 Floppy)。</p>
<h3>磁道/扇区格式</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/1230f30cb2f9a97726a6e0db9a8560d59e56965e70f2eefcf62aac903277182f/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f44574f6c676b5375504e794c4169632e706e67"><img src="https://camo.githubusercontent.com/1230f30cb2f9a97726a6e0db9a8560d59e56965e70f2eefcf62aac903277182f/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f44574f6c676b5375504e794c4169632e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/DWOlgkSuPNyLAic.png" style="max-width: 100%;"></a></p>
<p>磁道，扇区上面会存储一些控制信息</p>
<h3>磁盘控制器</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7620fecdb846992b3df2ca47cf071ed2b706eef22b70f8690d3204dbf6ac5688/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f6b3432466576706a6144505a6748372e706e67"><img src="https://camo.githubusercontent.com/7620fecdb846992b3df2ca47cf071ed2b706eef22b70f8690d3204dbf6ac5688/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f6b3432466576706a6144505a6748372e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/k42FevpjaDPZgH7.png" style="max-width: 100%;"></a></p>
<p>磁盘有一个自己的控制器来响应 CPU 的 I/O 操作，并且维护磁盘逻辑块号和物理磁盘扇区的关系</p>
<h3>差错检测与纠正</h3>
<p>最简单的就是直接记录 <strong>校验和</strong>，复杂一点就上 <strong>CRC</strong> 或者 <strong>汉明码</strong></p>
<h3>磁盘格式</h3>
<ol>
<li>磁盘引导</li>
<li>文件分配表</li>
<li>文件分配表副本</li>
<li>根目录</li>
<li>数据区</li>
</ol>
<h3>FAT/簇</h3>
<p>FAT 是一种简单且广泛使用的文件系统，簇是 FAT 文件系统用于存储数据的最小单位。 一个簇由一个或多个连续的扇区组成。其硬盘大小限制是 <strong>2GB</strong>，簇大小限制是 <strong>32,768 bytes</strong>，至少需要一个簇来存储文件，所以假如簇很大却存了一个很小的文件，会导致浪费</p>
<p>FAT 32 是 FAT 16 的升级，最大支持 268435456 个簇，适用于较大的硬盘</p>
<p>FAT 32 有回收站机制</p>
<h3>根目录</h3>
<p><strong>字节编号 (Byte Number)</strong></p>
<ul>
<li>0-7:   文件名 (Filename)</li>
<li>8-10:  扩展名 (Extension)</li>
<li>11:   文件属性 (File Attribute), 1 读取 (Read), 2 隐藏 (Hidden), 4 系统文件 (System file), ....</li>
<li>12-21:  保留 (Reserved)</li>
<li>22-23:  文件创建时间 (Time file was created)</li>
<li>24-25:  文件创建日期 (Date the file was created)</li>
<li>26-27:  起始簇号 (Starting cluster number)</li>
<li>28-31:  文件大小 (字节)  (File size in bytes)</li>
</ul>
<p>根目录标识特定文件的 FAT 中的第一个簇，FAT 的第一个簇入口将包含第二个簇的簇号。此过程会持续进行，直到链接足够的簇以包含文件大小。 (很像链表)</p>
<p>长这样：</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7b6e71ec0464bd96df3afd04360b16396bc010e481eb7cfcd6315be46653dc21/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f6163624734334b554c66535a5954562e706e67"><img src="https://camo.githubusercontent.com/7b6e71ec0464bd96df3afd04360b16396bc010e481eb7cfcd6315be46653dc21/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f6163624734334b554c66535a5954562e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/acbG43KULfSZYTV.png" style="max-width: 100%;"></a></p>
<h3>连接方式</h3>
<p><strong>IDE (Integrated Disk Electronics)</strong></p>
<ul>
<li>增强型 IDE (EIDE，也称为 ATA-2) 支持更大的硬盘，并允许连接四个设备，包括磁盘、磁带和 CD-ROM。</li>
<li>传统的 IDE 支持两个容量小于或等于 528MB 的硬盘。</li>
</ul>
<p><strong>SCSI (Small Computer Systems Interface)</strong></p>
<ul>
<li>SCSI 使用 50 芯电缆，被 Macintosh 计算机、RISC 工作站、小型机甚至某些大型机使用，也可用于 PC。</li>
<li>SCSI 允许将多个设备链接在一起 (<del>菊花链</del>) ，且在硬盘备份到磁带机时，微处理器无需运行。SCSI 电缆需要端接 (terminating)。</li>
</ul>
<h3>RAID 磁盘阵列</h3>
<ul>
<li>RAID Level 0: 数据条带化 (Striping) 跨越四个磁盘，提高速度，但不提供数据完整性改进 (没有冗余)。</li>
<li>RAID Level 1: 磁盘镜像 (Mirroring)，没有条带化，在一个磁盘上维护另一个磁盘的副本。</li>
<li>RAID Level 3: 条带化，带有一个额外的专用奇偶校验磁盘 (parity disk)。 只有 20% 的磁盘用于存储冗余信息。</li>
<li>RAID Level 5: 数据和奇偶校验条带化跨越 5 个磁盘。</li>
<li>RAID Level 10: 数据条带化跨越两个磁盘，磁盘进行镜像。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ec496d310388ec05fd7a046c6719ff198c482d31d7bc64a76d2f61a7399b7206/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f46576c724e6549516d3975366932562e706e67"><img src="https://camo.githubusercontent.com/ec496d310388ec05fd7a046c6719ff198c482d31d7bc64a76d2f61a7399b7206/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f46576c724e6549516d3975366932562e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/FWlrNeIQm9u6i2V.png" style="max-width: 100%;"></a></p>
<h3>光盘</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/540b574f33226e51e07cec4cdb76a4709dee7d4976e88b4c972a82768af2e0c6/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f38456c5533784e5a543941564a677a2e706e67"><img src="https://camo.githubusercontent.com/540b574f33226e51e07cec4cdb76a4709dee7d4976e88b4c972a82768af2e0c6/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30372f38456c5533784e5a543941564a677a2e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/07/8ElU3xNZT9AVJgz.png" style="max-width: 100%;"></a></p>
<p>单层DVD的容量为4.7GB，CD的容量为680MB，而双面双层DVD的容量可达17GB，CD既可以通过母盘复制/压制进行批量生产，也可以使用CD-R或CD-RW技术进行单独创建。</p>
<hr>
<h2>Lecture 13 B: 硬件保护</h2>
<h3>I/O 结构</h3>
<p>微处理器 (µP) 通过 UART (通用异步收发器) 与外部设备进行数据传输，UART 里面有一个<strong>缓冲区</strong>能加快数据传输。<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/84629e586ab01928ff592ed59c612b58fc60446f380a8e691963006934b5e40a/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30382f4e336e6d32725534536b4267654a702e706e67"><img src="https://camo.githubusercontent.com/84629e586ab01928ff592ed59c612b58fc60446f380a8e691963006934b5e40a/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30382f4e336e6d32725534536b4267654a702e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/08/N3nm2rU4SkBgeJp.png" style="max-width: 100%;"></a></p>
<h3>同步 I/O</h3>
<p>在同步 I/O 中，应用程序发起 I/O 操作后，<strong>必须等待</strong> I/O 操作完成才能继续执行后续代码。 也就是说，应用程序会被 <strong>阻塞</strong> 在 I/O 操作上，直到数据传输完成。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/df08b987ecd5eae642d28ac2712ee8f2f0153cf7ab8ee9eb50fb65f55cf79eb8/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30382f6f314362694f7667754d537a6a77472e706e67"><img src="https://camo.githubusercontent.com/df08b987ecd5eae642d28ac2712ee8f2f0153cf7ab8ee9eb50fb65f55cf79eb8/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30382f6f314362694f7667754d537a6a77472e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/08/o1CbiOvguMSzjwG.png" style="max-width: 100%;"></a></p>
<h3>异步 I/O</h3>
<p>在异步 I/O 中，应用程序发起 I/O 操作后， <strong>无需等待</strong> I/O 操作完成就可以继续执行后续代码。 操作系统或 I/O 设备会在后台执行 I/O 操作，并在操作完成后通过中断等机制通知应用程序。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/590d05a14af8e2e2e721cb560ed04fcd082871108783b576591c5191faa1ad29/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30382f66556d7279317539354e4a646c54532e706e67"><img src="https://camo.githubusercontent.com/590d05a14af8e2e2e721cb560ed04fcd082871108783b576591c5191faa1ad29/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30382f66556d7279317539354e4a646c54532e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/08/fUmry1u95NJdlTS.png" style="max-width: 100%;"></a></p>
<h3>硬件保护</h3>
<p>CPU允许两种操作模式。在寄存器中的一个位设置了CPU正在运行的模式。</p>
<ul>
<li>**用户模式 (User Mode): **代表用户运行的代码。</li>
<li>**监控模式 (Monitor Mode): **代表操作系统运行的代码。</li>
</ul>
<p>在用户模式下，应用不能切换到监控模式。操作系统在启动用户程序之前，会先切换到监控模式，然后创建一个新的进程或线程，并将控制权交给该进程或线程。只有在监控模式下才能使用能够危害其他程序的特权指令。因此只有通过操作系统，用户程序才能和硬件交互</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/9d4d85b19879f4ac46266bb02a818740aee7bfbc093e01b81d96069c25a05312/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30382f50376b347376656e474c67437a70542e706e67"><img src="https://camo.githubusercontent.com/9d4d85b19879f4ac46266bb02a818740aee7bfbc093e01b81d96069c25a05312/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f30382f50376b347376656e474c67437a70542e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/08/P7k4svenGLgCzpT.png" style="max-width: 100%;"></a></p>
<h3>内存保护</h3>
<p>恶意程序在没有内存保护的情况下能直接修改中断向量表，造成严重的系统异常！！！</p>
<h3>CPU 保护</h3>
<p>操作系统理念有一个计时器，规定了一个程序最长能占用的CPU周期，防止某个进程霸占 CPU 导致系统崩溃，计时器中断触发会保存当前上下文，然后把控制权交给下一个进程</p>
<hr>
<h2>Lecture 14: CISC/RISC 向量处理器与并行处理器</h2>
<h3>RISC vs CISC</h3>
<h4>CISC (Complex Instruction Set)</h4>
<p><strong>核心理念</strong>：通过丰富的指令集和寻址方式，尽可能地用一条指令完成复杂的任务。</p>
<ul>
<li><strong>指令集丰富</strong>：指令数量多，包含大量复杂指令，以及多种寻址方式。</li>
<li><strong>汇编编程友好</strong>：汇编代码编写相对容易，因为高级操作可以通过单条指令完成。</li>
<li><strong>特定指令执行速度快</strong>：针对特定应用优化的复杂指令，执行效率高。</li>
<li><strong>指令解码复杂</strong>：由于指令长度不一、格式多样，解码过程复杂，增加硬件开销。</li>
<li><strong>程序体积较小</strong>：完成相同任务所需的指令数量较少，程序体积相对较小。</li>
</ul>
<h4>RISC (Reduced Instruction Set)</h4>
<p><strong>核心理念</strong>：简化指令集，使用少量、简单、定长的指令，并通过优化指令执行流程来提高整体性能。</p>
<ul>
<li><strong>指令集精简</strong>：指令数量少，指令格式统一，寻址方式简单。</li>
<li><strong>指令执行效率高</strong>：绝大多数指令都可以在一个时钟周期内完成。</li>
<li><strong>编译器要求高</strong>：生成 RISC 代码的编译器设计难度较高。</li>
<li><strong>内存性能要求高</strong>：需要快速的内存访问，以保证指令流的持续供应。</li>
<li><strong>性能更好</strong>：指令执行效率高，流水线优化使得并发执行成为可能。</li>
<li><strong>通用寄存器多</strong>：依赖大量通用寄存器，减少对内存的访问，提高数据处理速度。</li>
<li><strong>优化指令流水线</strong>：允许同时执行多条指令。</li>
</ul>
<h4>CISC 和 RISC 在追求更好性能时的策略</h4>
<ul>
<li><strong>CISC</strong> 的策略 是让机器指令更像高级语言，这样编译器更容易生成代码，程序也更小更快。许多 CISC 编译器实际上只使用指令集中的一部分。</li>
<li><strong>RISC</strong> 的策略是优化最常用指令的执行效率，减少内存访问，并充分利用指令流水线和寄存器。RISC 设计侧重于通过使用寄存器（可以看作是非常快的本地缓存）和优化指令的执行流程来提高速度。</li>
</ul>
<h4>CISC 和 RISC 实现乘法</h4>
<p><strong>RISC 实现乘法</strong></p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">.STARTUP</span>

<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">0</span><span class="pl-c">        ; 初始化结果寄存器 AX 为 0</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">100</span><span class="pl-c">      ; 乘数 100 放入 DX 寄存器</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">123</span><span class="pl-c">      ; 被乘数 123 放入 BX 寄存器</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">cx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">8</span><span class="pl-c">        ; 循环次数设置为 8 (假设进行 8 位乘法)</span>

<span class="pl-en">back:</span>
<span class="pl-en">    </span><span class="pl-k">rcr</span><span class="pl-en"> </span><span class="pl-v">dx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">1</span><span class="pl-c">    ; 将 DX 寄存器最低位循环移入 CF (进位标志位)</span>
<span class="pl-en">    </span><span class="pl-k">jnc</span><span class="pl-en"> over</span><span class="pl-c">     ; 如果 CF = 0 (最低位为 0)，则跳转到 over 标签</span>
<span class="pl-en">    </span><span class="pl-k">add</span><span class="pl-en"> </span><span class="pl-v">ax</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-c">   ; 如果 CF = 1 (最低位为 1)，则将 BX 累加到 AX (部分积)</span>

<span class="pl-en">over:</span>
<span class="pl-en">    </span><span class="pl-k">shl</span><span class="pl-en"> </span><span class="pl-v">bx</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">1</span><span class="pl-c">    ; 将 BX 寄存器左移一位，相当于乘以 2</span>
<span class="pl-en">    </span><span class="pl-k">loop</span><span class="pl-en"> back</span><span class="pl-c">    ; 循环计数器 CX 减 1，如果 CX != 0，则跳转到 back 标签继续循环</span>

<span class="pl-k">call</span><span class="pl-en"> Print</span>
<span class="pl-en">.EXIT</span></pre></div>
<p><strong>CISC 实现乘法</strong></p>
<div class="highlight highlight-source-assembly"><pre class="notranslate"><span class="pl-en">.STARTUP</span>

<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">dl</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">100</span><span class="pl-c">    ; 乘数 100 放入 DL 寄存器</span>
<span class="pl-k">mov</span><span class="pl-en"> </span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-en"> </span><span class="pl-c1">123</span><span class="pl-c">    ; 被乘数 123 放入 AL 寄存器</span>

<span class="pl-k">mul</span><span class="pl-en"> </span><span class="pl-v">dl</span><span class="pl-c">         ; 执行乘法指令 mul，AL * DL，结果存储在 AX 寄存器</span>

<span class="pl-k">call</span><span class="pl-en"> Print</span>
<span class="pl-en">.EXIT</span></pre></div>
<h3>流水线</h3>
<p>早期 CPU 执行一条指令从出生到入土，非得霸占整个逻辑处理单元不撒手。Fetch, Decode, Execute 三兄弟明明能各干各的，非得搞什么"一条龙服务"——结果就是ALU天天摸鱼，寄存器天天加班。图灵的在天之灵振臂高呼：杂鱼 CPU 就应该狠狠的填满🥵，上流水线！</p>
<h4>流水线执行：时间管理大师の骚操作</h4>
<ol>
<li>周期1：Ins.1刚扒上Fetch的窗口，CPU就开始偷瞄下一条</li>
<li>周期2：Ins.1在Decode里翻来覆去，Ins.2已经蹲在Fetch门口催单</li>
<li>周期3：Ins.1终于Execute，后面俩小弟Ins.2/3直接卡成贪吃蛇</li>
<li>周期4：Ins.1 Execute 完了，提起裤子直接跑了，轮到 Ins.2 上场接力</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/af8cede97c48c79416c78804aaa02f7b26ae7974ce1f8b3d9cc2cfd0eed85b79/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31312f41587562786f5333687973507a38462e706e67"><img src="https://camo.githubusercontent.com/af8cede97c48c79416c78804aaa02f7b26ae7974ce1f8b3d9cc2cfd0eed85b79/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31312f41587562786f5333687973507a38462e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/11/AXubxoS3hysPz8F.png" style="max-width: 100%;"></a></p>
<p>【奔腾の骚操作手册】</p>
<ul>
<li><strong>分支预测</strong>：我全都要！左手预取老实人指令，右手偷跑分支代码，赌狗の胜利</li>
<li><strong>双核の野望</strong>：U/V两个执行单元宛如双车道飙车，前提是别碰上"简单指令+无依赖"这种稀有精英怪</li>
<li><strong>硬连线玄学</strong>：简单指令直接焊死在电路板上，复杂指令？不存在的，RISC正统在Intel（战术后仰）</li>
<li><strong>写回の艺术</strong>：寄存器更新比微博热搜还快，标志位翻脸比翻书还勤</li>
</ul>
<h4>流水线の黑暗面：你以为的效率革命，其实是 CPU 的血泪史</h4>
<p><strong>1. 资源冲突：CPU版《鱿鱼游戏》</strong></p>
<ul>
<li>内存总线就是独木桥，两条指令同时过？直接给你踹下去！ALU、寄存器全特么是限量款，抢不到资源的指令只能蹲在流水线里斗地主</li>
</ul>
<p><strong>2. 控制依赖：薛定谔的跳转指令</strong></p>
<ul>
<li>分支预测？预测个锤子！当你的jump指令在流水线里蹦迪时，后面跟的一串指令全是开盲盒——猜对了叫"分支预测成功"，猜错了？恭喜喜提"清空流水线大礼包"！</li>
</ul>
<p><strong>3. 数据依赖：套娃式死亡连环call</strong></p>
<ul>
<li>想算A=B+C？先等B从内存爬出来！</li>
<li>要搞D=A*2？麻烦前面那个算A的别摸鱼！</li>
<li>最骚的是进位标志位——这玩意儿就像祖传染色体，少一个bit整个运算家族都得绝后</li>
</ul>
<h4>浮点运算の流水线魔法：从牛车到高铁的骚操作</h4>
<p><strong>标量运算の原始社会：</strong></p>
<ul>
<li>24步苦力操作，每个加法都得把C/S/A/N四件套从头撸到尾</li>
<li>流水线？不存在的！ALU就像单身狗热炕头——每次只能宠幸一个阶段</li>
<li>寄存器疯狂007：刚伺候完Check又要搞Shift，CPU直接过劳死预警</li>
</ul>
<p><strong>流水线の工业革命：</strong></p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="center">周期</th>
<th align="center">C (Check if Zero)</th>
<th align="center">S (Shift)</th>
<th align="center">A (Add)</th>
<th align="center">N (Normalize)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">1</td>
<td align="center">加法 1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">加法 2</td>
<td align="center">加法 1</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">加法 3</td>
<td align="center">加法 2</td>
<td align="center">加法 1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">加法 4</td>
<td align="center">加法 3</td>
<td align="center">加法 2</td>
<td align="center">加法 1</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">加法 5</td>
<td align="center">加法 4</td>
<td align="center">加法 3</td>
<td align="center">加法 2</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">加法 6</td>
<td align="center">加法 5</td>
<td align="center">加法 4</td>
<td align="center">加法 3</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"></td>
<td align="center">加法 6</td>
<td align="center">加法 5</td>
<td align="center">加法 4</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">加法 6</td>
<td align="center">加法 5</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">加法 6</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p>（拍黑板）看见没？资本家CPU的终极奥义：</p>
<ul>
<li><strong>四阶段流水线化身血汗工厂</strong>：Check工人刚摸鱼完，Shift工人立刻接盘</li>
<li><strong>每个时钟周期都在榨干硬件</strong>：6个加法只付9个周期的工资（6+4-1），比周扒皮还狠</li>
<li><strong>前戏与收尾の量子纠缠</strong>：前3周期在填流水线（热身），后6-1=5周期疯狂输出（冲业绩）</li>
</ul>
<p>假如还有这个屠龙宝剑，计算8个加法甚至只要5周期！</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/cfc19db94550f81522ef37dcda2c0dc0e9f5bb645e1de9c594ba2cff7b61f839/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31312f34675052766137634371516d6975652e706e67"><img src="https://camo.githubusercontent.com/cfc19db94550f81522ef37dcda2c0dc0e9f5bb645e1de9c594ba2cff7b61f839/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31312f34675052766137634371516d6975652e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/11/4gPRva7cCqQmiue.png" style="max-width: 100%;"></a></p>
<h3>向量处理</h3>
<p>例如要计算 $\begin{bmatrix}1\2\3\end{bmatrix}+\begin{bmatrix}3\4\5\end{bmatrix}=\begin{bmatrix}4\6\8\end{bmatrix}$ 使用标量处理至少需要3个周期，但是加上流水线和并行处理可能能在一个周期内解决</p>
<h3>M. Flynn 并行处理器分类</h3>
<ul>
<li><strong>SISD (单指令流单数据流)</strong>：使用单个处理器来解释对单个数据块的单条指令。通过流水线技术实现并行。</li>
<li><strong>SIMD (单指令流多数据流)</strong>：使用单条指令来控制多个处理单元。例如，向量处理器。</li>
<li><strong>MIMD (多指令流多数据流)</strong>：一组处理器同时执行对不同数据块的不同指令。</li>
</ul>
<h3>多处理器</h3>
<p>共享内存，受限于内存带宽，不能做到很大的规模</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f56b03b482610016c220995813b26b8fb0fca8f3f0aa39cef69b6ed1d8fa7d7b/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31312f516f5a384b437564445835745554342e706e67"><img src="https://camo.githubusercontent.com/f56b03b482610016c220995813b26b8fb0fca8f3f0aa39cef69b6ed1d8fa7d7b/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31312f516f5a384b437564445835745554342e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/11/QoZ8KCudDX5tUT4.png" style="max-width: 100%;"></a></p>
<h3>多计算机</h3>
<p>每个处理器由自己独立的内存，说白了就是分布式系统，通过PVM来交换数据</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8149b4199b74a1ed5776ad24bb7ae039dd0bbf2f06a1e783d8e4a44c12cc6754/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31312f4b63456f5067394e535664617a6a752e706e67"><img src="https://camo.githubusercontent.com/8149b4199b74a1ed5776ad24bb7ae039dd0bbf2f06a1e783d8e4a44c12cc6754/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31312f4b63456f5067394e535664617a6a752e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/11/KcEoPg9NSVdazju.png" style="max-width: 100%;"></a></p>
<h3>拓扑架构</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/23df89d37811ae515c062a2e3a72e9be29f1c448b844bbb83f0804f845a16325/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31312f7773747a694f5552344278764b4a392e706e67"><img src="https://camo.githubusercontent.com/23df89d37811ae515c062a2e3a72e9be29f1c448b844bbb83f0804f845a16325/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31312f7773747a694f5552344278764b4a392e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/11/wstziOUR4BxvKJ9.png" style="max-width: 100%;"></a></p>
<ul>
<li>环形结构 ring，最远距离 n/2</li>
<li>网状结构 mesh，最远距离 2n-2</li>
<li>树形结构 tree，一般适用于分治的系统</li>
<li>超立方体结构，一共有 $2^n$ 个节点，每个节点连出去 $\log_2(n)$ 条边。最远距离 n</li>
</ul>
<h3>超标量处理器</h3>
<p>一次能执行多条指令的 CPU，前提是指令之间不存在依赖或者冲突关系</p>
<p>好的，我将根据您提供的信息，对并行系统进行重写，力求更清晰、准确和易懂：</p>
<h3>并行系统</h3>
<p>并行系统本质上是由多个处理器组成的计算系统，旨在通过同时执行多个任务来提高性能和可靠性。 它们可以被视为多处理器系统，具有以下关键特征：</p>
<ul>
<li>
<p><strong>紧耦合性 (Tightly Coupled)</strong>：</p>
<ul>
<li>
<p>并行系统中的处理器共享相同的物理资源，例如总线、时钟和外围设备。</p>
</li>
<li>
<p>处理器之间通过共享内存进行通信，这意味着它们可以访问相同的内存地址空间。</p>
</li>
<li>
<p><strong>缺点</strong>：这种紧密的集成限制了系统的可扩展性，因为增加处理器的数量会导致资源竞争和通信瓶颈。</p>
</li>
<li>
<p><strong>对比</strong>：与此相反，分布式系统（也称为多计算机系统）中的处理器不共享总线和时钟。它们通过专用的通信链路（例如网络连接）进行通信，并使用消息传递协议来交换数据。这种架构称为松耦合 (loosely coupled)，具有更好的可扩展性。</p>
</li>
</ul>
</li>
<li>
<p><strong>容错性 (Fault Tolerance)</strong>：</p>
<ul>
<li>
<p>并行系统设计的一个重要目标是在部分硬件发生故障时仍能继续运行。</p>
</li>
<li>
<p>如果某个处理器出现故障，其他处理器应能够接管其任务，从而确保系统继续提供服务，尽管性能可能会有所降低（这种特性称为<strong>优雅降级</strong> graceful degradation）。</p>
</li>
</ul>
</li>
</ul>
<h4>并行系统的分类</h4>
<p>根据处理器之间的关系和任务分配方式，并行系统可以分为以下几种类型：</p>
<ul>
<li>
<p><strong>串联系统 (Tandem Systems)</strong>：</p>
<ul>
<li>
<p>每个进程复制两份，分别在两个独立的处理器上同时运行。</p>
</li>
<li>
<p>其中一个进程作为主进程 (primary)，另一个作为备份进程 (backup)。</p>
</li>
<li>
<p>在固定时间间隔，主进程的状态和数据被复制到备份进程。</p>
</li>
<li>
<p>如果主进程发生故障，备份进程可以立即接管，从而实现零停机时间。</p>
</li>
<li>
<p><strong>应用场景</strong>：尽管这种方式比较昂贵，但对于需要极高可靠性的关键应用（例如银行系统和证券交易所）至关重要。</p>
</li>
</ul>
</li>
<li>
<p><strong>非对称系统 (Asymmetric Systems)</strong>：</p>
<ul>
<li>
<p>有一个主处理器 (master processor) 负责控制和协调其他从处理器 (slave processors)。</p>
</li>
<li>
<p>每个处理器都被分配特定的任务。</p>
</li>
<li>
<p>主处理器负责将任务分配给从处理器，并收集和汇总结果。</p>
</li>
<li>
<p><strong>优点</strong>：易于实现和管理。</p>
</li>
<li>
<p><strong>缺点</strong>：主处理器容易成为瓶颈。</p>
</li>
</ul>
</li>
<li>
<p><strong>对称系统 (Symmetric Systems)</strong>：</p>
<ul>
<li>
<p>所有处理器地位相同，运行相同的操作系统副本。</p>
</li>
<li>
<p>处理器之间可以相互通信，并共享系统资源。</p>
</li>
<li>
<p>任务可以动态地分配给任何可用的处理器。</p>
</li>
<li>
<p><strong>优点</strong>：更好的负载均衡和容错性。</p>
</li>
<li>
<p><strong>缺点</strong>：需要更复杂的操作系统和调度算法。</p>
</li>
</ul>
</li>
</ul>
<h4>并行系统的优点</h4>
<ul>
<li>
<p><strong>资源共享 (Resource Sharing)</strong>：并行系统允许系统中的处理器共享各种资源，例如打印机、存储设备和网络连接，从而降低成本和提高资源利用率。</p>
</li>
<li>
<p><strong>计算加速 (Computation Speedup)</strong>：通过将计算任务分解成多个子任务，并在多个处理器上并行执行，可以显著缩短计算时间。</p>
</li>
<li>
<p><strong>可靠性 (Reliability)</strong>：并行系统具有内在的冗余性。如果某个处理器发生故障，其他处理器可以继续运行，从而提高系统的可靠性。</p>
</li>
<li>
<p><strong>通信 (Communication)</strong>：并行系统允许系统中的处理器之间进行远距离通信，从而实现协作和数据共享</p>
</li>
</ul>
<hr>
<h2>Lecture 15: 总线</h2>
<h3>总线</h3>
<p>总线 (Buses) 是一组共享的通信线路，用于连接计算机的不同组件，并提供使用该线路的标准。</p>
<ul>
<li><strong>系统内通信 (Intrasystem communication)</strong>：连接计算机内部的各种组件，距离小于一米，<strong>通过大量并行的总线来实现。</strong></li>
<li><strong>系统间通信 (Intersystem communication)</strong>：连接计算机和远距离的硬件，<strong>通常使用串行链路来实现。</strong></li>
</ul>
<h4>计算机总线</h4>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a59b8802d83532219261b1a80c6499a35168d9efc5cae1ec17e421b1db0b4012/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f4b414d7770664f45735235566776482e706e67"><img src="https://camo.githubusercontent.com/a59b8802d83532219261b1a80c6499a35168d9efc5cae1ec17e421b1db0b4012/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f4b414d7770664f45735235566776482e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/12/KAMwpfOEsR5VgvH.png" style="max-width: 100%;"></a></p>
<ul>
<li><strong>地址总线 (Address Bus):</strong> 当计算机希望从内存或 I/O 设备读取/写入数据时，地址总线会指定要访问的位置。 它只能输出。</li>
<li><strong>数据总线 (Data Bus):</strong> 一种双向总线，用于将数据传输到 CPU 和从 CPU 传输数据。</li>
<li><strong>控制总线 (Control Bus):</strong> 一组输入/输出线路，用于控制读取/写入操作期间的事件序列。</li>
<li><strong>专用总线 (Dedicated Bus):</strong> 专用总线仅用于连接两个设备。</li>
<li><strong>共享总线 (Shared Bus):</strong> 在早起计算机系统中，虽然地址总线、数据总线和控制总线在逻辑上是分离的，但在一些早期的、简单的系统中，它们可能会在物理上共享同一组线路。</li>
</ul>
<h4>总线时序 (Bus Timing)</h4>
<p>在任何一个时间点，只能有一个设备可以发送数据，所有其他设备必须监听或忽略数据。 发送控制信息的设备被称为主设备 (master)，其他单元被称为从设备 (slave)，总线会产生瓶颈。</p>
<ul>
<li><strong>同步总线 (Synchronous Buses)</strong> 包含一个时钟信号，该信号允许每个项目在主设备和从设备都知道的预定时间段内传输。 可能实现非常快的数据速率。 然而，系统会变得和总线上最慢的设备一样慢。</li>
<li><strong>异步总线 (Asynchronous Buses)</strong> 不包含时钟信号，要传输的每个项目都伴随一组用于排序传输的控制信号。 这有时涉及握手 (handshaking)。</li>
</ul>
<h4>PC 总线</h4>
<p><strong>PC 中的主要总线类型：ISA 和 PCI</strong></p>
<p>早期的 PC 中主要有两种总线：ISA 和 PCI。</p>
<ul>
<li>
<p><strong>ISA (Industry Standard Architecture) 总线：</strong></p>
<ul>
<li>这是一种较老的总线标准，虽然速度较慢，但具有良好的兼容性，可以连接各种外设。</li>
<li>最初是 8 位，运行频率 4.8MHz。 后来扩展到 16 位，运行频率 8MHz。</li>
<li>ISA 设备通过 ISA 连接器与主板相连。 8 位 ISA 设备只使用连接器的一部分，而 16 位设备使用整个连接器。</li>
</ul>
</li>
<li>
<p><strong>PCI (Peripheral Component Interconnect) 总线：</strong></p>
<ul>
<li>随着技术的发展，PCI 总线逐渐取代 ISA，成为目前最常见的 I/O 总线。</li>
<li>PCI 提供更高的带宽，通常为 32 位宽，运行频率 33MHz。</li>
<li>通过 PCI 控制器来管理总线上的设备访问和仲裁。</li>
<li>PCI 的一个重要优势是支持即插即用 (plug and play)，简化了硬件的安装和配置过程。</li>
</ul>
<p>不过现在都是用 PCIE 了</p>
</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b3bd8c885ec97c16b4d35dc7c78aa5c0ef0015e8e79005a82ddfc1b60bca04a3/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f354f47576d735964336b50656f79612e706e67"><img src="https://camo.githubusercontent.com/b3bd8c885ec97c16b4d35dc7c78aa5c0ef0015e8e79005a82ddfc1b60bca04a3/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f354f47576d735964336b50656f79612e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/12/5OGWmsYd3kPeoya.png" style="max-width: 100%;"></a></p>
<h3>争用</h3>
<p>像计算机上的地址总线这样的单向总线易于实现。 CPU 产生地址，所有设备监视地址线路。</p>
<p>但是数据总线这样的一些总线需要双向传输数据。如果两个输出连接在一起，结果称为争用。 小则数据损坏，严重就直接把电路烧了，就像这样：</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ae359f7e8b88ab2397cf0e9bbdc619d1efdd45ddf95b714e7fcedeea57fe3d2e/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f796336656d387141487577345264442e706e67"><img src="https://camo.githubusercontent.com/ae359f7e8b88ab2397cf0e9bbdc619d1efdd45ddf95b714e7fcedeea57fe3d2e/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f796336656d387141487577345264442e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/12/yc6em8qAHuw4RdD.png" style="max-width: 100%;"></a></p>
<h4>电流吸收逻辑</h4>
<p>当然也可以这样，接一个上拉电阻，限制最大电流，这样就不会烧坏电路了，不过这种方案有速度慢和浪费电力等缺点</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ad5c6a52bc59fd0f6bf26fd9109f2bd32f3aa9c86ad8255bf9e13710d89615a3/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f6a62556753414537686371653164442e706e67"><img src="https://camo.githubusercontent.com/ad5c6a52bc59fd0f6bf26fd9109f2bd32f3aa9c86ad8255bf9e13710d89615a3/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f6a62556753414537686371653164442e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/12/jbUgSAE7hcqe1dD.png" style="max-width: 100%;"></a></p>
<h4>使用三态缓冲器</h4>
<p>三态设备用另一根控制线来断开设备与总线的连接。当断开连接的时候，它的输入阻抗 (High-impedance) 变得非常大，这样就能避免总线争用的情况了。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d78000112080e71ff661fb56ed2733557963bdf69542507ef657bbbebfb3c7bc/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f416752626d57326f54474e567a61692e706e67"><img src="https://camo.githubusercontent.com/d78000112080e71ff661fb56ed2733557963bdf69542507ef657bbbebfb3c7bc/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f416752626d57326f54474e567a61692e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/12/AgRbmW2oTGNVzai.png" style="max-width: 100%;"></a></p>
<h3>仲裁 (Arbitration)</h3>
<p>不同设备可能希望同时使用总线，这个时候需要总线仲裁用于避免总线上的冲突或竞争。</p>
<h4>级联 (Cascading)</h4>
<p>当设备想要使用总线时，它会拉高 Request 信号。 如果 Busy 信号为高电平，表示总线正忙，控制器将忽略新的 Request 信号。 反之，如果 Busy 信号为低电平，控制器则发送 Grant 信号给该设备，允许其使用总线。 收到 Grant 信号后，设备会立即拉高 Busy 信号，并将数据放到总线上传输。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/2236858fc8daf6f4d1dad3f370e400a091e1bc6c76fd5675af98fc4a5632a143/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f6c6231706a484c66457552775339692e706e67"><img src="https://camo.githubusercontent.com/2236858fc8daf6f4d1dad3f370e400a091e1bc6c76fd5675af98fc4a5632a143/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f6c6231706a484c66457552775339692e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/12/lb1pjHLfEuRwS9i.png" style="max-width: 100%;"></a></p>
<h4>轮询 (Polling)</h4>
<p>当设备想要使用总线时，它会拉高 Request 信号。 一旦收到请求，控制单元就开始挨个查看轮询线，看看哪个设备想要用总线。 找到了想用的，就把 Busy 信号拉高，然后把数据线连通，让这个设备用。</p>
<p>通俗一点来就像点名一样：设备想用总线先举手 (发出请求)。然后控制器一个一个地问：“1 号，你要用总线吗？ 2 号，你要用总线吗？ 3 号，你要用总线吗？...”，一旦点到某个举手的设备，控制单元就说：“好，给你用！” 然后把 Busy 信号设为“忙碌”，并把数据线连通，让这个设备传输数据。“点名”的顺序决定了谁先被服务，也就是谁的优先级最高。 如果 1 号总是先被点到，那么 1 号的优先级就最高。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/14074bcff487df4bbc756fd3227aa4ce910498a0ac5d03850535484fb8d19f38/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f31386b784c4f615a71775442674a722e706e67"><img src="https://camo.githubusercontent.com/14074bcff487df4bbc756fd3227aa4ce910498a0ac5d03850535484fb8d19f38/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f31386b784c4f615a71775442674a722e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/12/18kxLOaZqwTBgJr.png" style="max-width: 100%;"></a></p>
<h4>独立请求 (Independent Request)</h4>
<p>每个外设单元都有单独的请求线 (Request) 和授权线 (Grant)。优先级由总线控制单元来决定。不过缺点就是比较复杂，因为每个单元都需要单独的请求线和授权线。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5ad2deac1d4769704971b5267c8a2e9524433efc3a76a37bf370ea44447ba580/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f72626c66746d5938617779647831702e706e67"><img src="https://camo.githubusercontent.com/5ad2deac1d4769704971b5267c8a2e9524433efc3a76a37bf370ea44447ba580/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f72626c66746d5938617779647831702e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/12/rblftmY8awydx1p.png" style="max-width: 100%;"></a></p>
<hr>
<h2>Lecture 16: 闪存与 FPGA</h2>
<h3>闪存</h3>
<p><strong>闪存 (Flash)</strong> 的存储单元包含一个带控制栅和浮动栅的存储晶体管。浮动栅通过薄氧化层与晶体管隔离，用于存储电荷并控制电流。</p>
<ul>
<li><strong>写入</strong>：在高电场下，通过在源极和漏极施加强负电荷，在控制栅上施加强正电荷，使电子穿过薄氧化层进入浮动栅。此时 FET 源极和漏极之间的 p 掺杂沟道可以轻松地流动电流，表示 <code class="notranslate">1</code>。</li>
<li><strong>擦除</strong>：在控制栅上施加强负电荷，迫使电子进入具有强正电荷的沟道，减少 p 掺杂沟道中的空穴，导致电导率大幅下降。表示 <code class="notranslate">0</code>。</li>
<li><strong>数据保持</strong>：由于氧化层的电隔离，浮动栅中捕获的电子不依赖于 Flash 存储单元是否接收电源。Flash RAM 可以无需电源即可保存内容多年，因此可用作计算机的存储介质。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a7d6ceb6d626454ed14f581a9708cdcc6190ad360b5737514f31dcb5f9b48c3e/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f70794c436e505a4437664274624b352e706e67"><img src="https://camo.githubusercontent.com/a7d6ceb6d626454ed14f581a9708cdcc6190ad360b5737514f31dcb5f9b48c3e/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f70794c436e505a4437664274624b352e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/12/pyLCnPZD7fBtbK5.png" style="max-width: 100%;"></a></p>
<h4>NAND Flash VS NOR Flash</h4>
<p>Flash RAM 分为 NOR 和 NAND Flash 存储器。</p>
<ul>
<li><strong>NOR Flash</strong>：不使用共享组件，可以并行连接各个存储单元，从而可以单独随机访问所有数据。</li>
<li><strong>NAND Flash</strong>：单元更紧凑，位线更少，浮动栅晶体管串在一起以增加存储密度。更适合串行数据访问。</li>
<li><strong>编程方式</strong>：NOR Flash 按字节级别编程数据，NAND Flash 按页级别编程数据（大于字节但小于块）。</li>
<li><strong>读写速度</strong>：NOR Flash 读取数据速度快，但在擦除和写入方面通常比 NAND 慢。</li>
<li><strong>功耗</strong>：NAND Flash 在写入密集型应用中比 NOR Flash 消耗更少的功率。</li>
<li><strong>成本</strong>：NOR Flash 存储器通常生产成本更高。</li>
</ul>
<h4>SSD</h4>
<p>基于 Flash 的介质基于硅基板，因此被称为固态设备。有很多种接口：2.5"SATA, mSATA, M.2, PCle Add-In Card</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a29cf9c6855158a6879f7069abf96f716c02ed7e9785fb4de8b5e193e342d877/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f5132544c647670464d444e677366682e706e67"><img src="https://camo.githubusercontent.com/a29cf9c6855158a6879f7069abf96f716c02ed7e9785fb4de8b5e193e342d877/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f5132544c647670464d444e677366682e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/12/Q2TLdvpFMDNgsfh.png" style="max-width: 100%;"></a></p>
<h3>FPGA</h3>
<blockquote>
<p><strong>现场可编程逻辑门阵列</strong>（英语：field-programmable gate array，缩写为<strong>FPGA</strong>）以PAL、GAL、CPLD等可编程逻辑器件为技术基础发展而成。作为特殊应用集成电路中的一种半定制电路，它既弥补全定制电路不足，又克服原有可编程逻辑控制器逻辑门数有限的缺点。可以利用逻辑合成和布局、布线工具软件，快速地刻录至FPGA上进行测试，这一过程是现代集成电路设计验证的技术主流。这些可编程逻辑组件可以被用来实现一些基本的逻辑门数字电路（比如与门、或门、异或门、非门）或者更复杂一些的组合逻辑功能，比如译码器等。在大多数的FPGA里面，这些可编辑的组件里也包含记忆组件，例如触发器（Flip－flop）或者其他更加完整的记忆块，从而构成时序逻辑电路。</p>
<p>系统设计师可以根据需要，通过可编辑的连接，把FPGA内部的逻辑块连接起来。这就好像一个电路试验板被放在了一个芯片里。一个出厂后的成品FPGA的逻辑块和连接可以按照设计者的需要而改变，所以FPGA可以完成所需要的逻辑功能。</p>
<p>FPGA一般来说比特殊应用集成电路（ASIC）的速度要慢，无法完成更复杂的设计，并且会消耗更多的电能。但是，FPGA具有很多优点，比如可以快速成品，而且其内部逻辑可以被设计者反复修改，从而改正程序中的错误，此外，使用FPGA进行调试的成本较低。厂商也可能会提供便宜、但是编辑能力有限的FPGA产品。因为这些芯片有的可编辑能力较差，所以这些设计的开发是在普通的FPGA上完成的，然后将设计转移到一个类似于专用集成电路的芯片上。在一些技术更新比较快的行业，FPGA几乎是电子系统中的必要部件，因为在大批量供货前，必须迅速抢占市场，这时FPGA方便灵活的优势就显得很重要。</p>
</blockquote>
<p>FPGA (Field Programmable Gate Array) 是一种 SSD 设备。通过硬件描述语言 (HDL) 描述的电路，可以烧录到FPGA上，在原型设计产品（如微波炉或洗衣机）时，工程师可以为 FPGA 编写软件来测试系统的功能，对于大众消费产品，使用 FPGA 进行原型设计更便宜，因为 HDL 程序可用于设置掩模以构建特定应用集成电路 (ASIC) 芯片，该芯片的生产成本非常低。</p>
<h4>FPGA 结构</h4>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c7ef8d6334184ac6ea16c1ff003d2f5b75dfc1f39a1331246d297e334ce4ad1f/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f46445a3748526a4e58476f74316e7a2e706e67"><img src="https://camo.githubusercontent.com/c7ef8d6334184ac6ea16c1ff003d2f5b75dfc1f39a1331246d297e334ce4ad1f/68747470733a2f2f73322e6c6f6c692e6e65742f323032352f30322f31322f46445a3748526a4e58476f74316e7a2e706e67" alt="img" data-canonical-src="https://s2.loli.net/2025/02/12/FDZ7HRjNXGot1nz.png" style="max-width: 100%;"></a></p>
<h4>Verilog</h4>
<p>有几种 HDL，但最常用于教学的是 Verilog。与工业中使用的 VHDL 不同，Verilog 是一种更易于学习的语言，并且可以执行 VHDL 可以执行的几乎所有功能。</p>
<p>用 Verilog 编写的 SR 锁存器的简单结构描述</p>
<div class="highlight highlight-source-verilog"><pre class="notranslate"><span class="pl-k">module</span> <span class="pl-en">SRlatch</span>(
  <span class="pl-k">output</span> Q, Q_bar,
  <span class="pl-k">input</span> S, R);
  <span class="pl-ent">nor</span> <span class="pl-ent">N1</span>(Q_bar, S, Q);
  <span class="pl-ent">nor</span> <span class="pl-ent">N2</span>(Q, R, Q_bar);
<span class="pl-k">endmodule</span></pre></div>
<hr>
<p><strong>The End ～～～ : )</strong></p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://koolcandy.github.io">win8!</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","koolcandy/koolcandy.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script>MathJax = {tex: {inlineMath: [["$", "$"]]}};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</html>
